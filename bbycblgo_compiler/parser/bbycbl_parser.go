// Code generated from bbyCBL.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // bbyCBL

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type bbyCBLParser struct {
	*antlr.BaseParser
}

var BbyCBLParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func bbycblParserInit() {
	staticData := &BbyCBLParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "','", "'.'", "'('", "')'", "'+'", "'-'", "'*'", "'/'",
		"'**'", "'='", "'<>'", "'<='", "'>='", "'<'", "'>'", "'==='", "'=='",
	}
	staticData.SymbolicNames = []string{
		"", "FLOAT", "NUMBER", "DATE", "DATE_UNDERSCORE", "ANY_DATE", "ANY_DATE_UNDERSCORE",
		"IDENTIFICATION_DIVISION", "DATA_DIVISION", "PROCEDURE_DIVISION", "PROGRAM_ID",
		"AUTHOR", "DATE_WRITTEN", "INSTALLATION", "SECURITY", "DATE_COMPILED",
		"BASE", "COPY", "DESCRIPTION", "PICTURE", "IS", "LIKE", "OCCURS", "ACCEPT",
		"ADD", "ALSO", "ALTER", "AND", "BY", "CALL", "CONTENT", "DELIMITED_BY",
		"DELIMITED", "DISPLAY", "DIVIDE", "ELSE", "END", "OFF", "END_EVALUATE",
		"END_IF", "ERROR", "EVALUATE", "FALSE", "FROM", "GIVING", "GO", "IF",
		"INTO", "LOOP", "LOW_VALUES", "MOVE", "MULTIPLY", "NEXT_SENTENCE", "NEXT",
		"SENTENCE", "NOT", "OF", "ON", "OR", "OTHER", "PERFORM", "PROCEED",
		"REFERENCE", "REMAINDER", "REPLACING", "RUN", "SIGNAL", "SIZE", "SPACE",
		"SPACES", "STOP", "SUBTRACT", "THEN", "THROUGH", "TIMES", "TO", "TRUE",
		"UNTIL", "USING", "VALUE", "VARYING", "WHEN", "WHILE", "WITH_NO_ADVANCING",
		"WITH", "NO", "ADVANCING", "XOR", "COMMA", "DOT", "LPAREN", "RPAREN",
		"PLUS", "MINUS", "MULT", "DIV", "POW", "EQ", "NE", "LE", "GE", "LT",
		"GT", "TRIPLE_EQUAL", "DOUBLE_EQUAL", "STRING", "HIGH_VALUES", "IDENTIFIER",
		"WS",
	}
	staticData.RuleNames = []string{
		"program", "identificationDivision", "identificationClause", "freeFormText",
		"dataDivision", "dataEntry", "dataCopyStmt", "levelNumber", "pictureClause",
		"picturePattern", "pictureElement", "likeClause", "occursClause", "procedureDivision",
		"usingClause", "paragraph", "sentence", "statement", "identifier", "simpleId",
		"evalSubject", "acceptStmt", "addStmt", "alterStmt", "callStmt", "copySource",
		"copyStmt", "replacePair", "replaceBlock", "equalDelim", "displayItem",
		"delimiterSpec", "valueSpec", "displayStmt", "withNoAdvancingClause",
		"divideStmt", "evaluateStmt", "givingClause", "gotoStmt", "ifStmt",
		"loopStmt", "loopContent", "loopControl", "moveStmt", "multiplyStmt",
		"nextSentenceStmt", "performStmt", "signalStmt", "stopStmt", "subtractStmt",
		"untilClause", "varyingClause", "varyingStmt", "whenClause", "whileClause",
		"exprList", "condition", "simpleCond", "comparator", "identifierSegment",
		"qualifiedId", "expr", "literal",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 108, 807, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 1,
		0, 1, 0, 3, 0, 129, 8, 0, 1, 0, 3, 0, 132, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1,
		5, 1, 138, 8, 1, 10, 1, 12, 1, 141, 9, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 3, 2, 150, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 163, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 180,
		8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 4, 2,
		192, 8, 2, 11, 2, 12, 2, 193, 3, 2, 196, 8, 2, 1, 2, 3, 2, 199, 8, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 209, 8, 2, 1, 2, 1,
		2, 3, 2, 213, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 4, 3, 224, 8, 3, 11, 3, 12, 3, 225, 1, 4, 1, 4, 1, 4, 5, 4, 231, 8,
		4, 10, 4, 12, 4, 234, 9, 4, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 240, 8, 5, 1,
		5, 3, 5, 243, 8, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6, 4, 6, 251, 8, 6,
		11, 6, 12, 6, 252, 3, 6, 255, 8, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8,
		3, 8, 263, 8, 8, 1, 8, 1, 8, 1, 9, 4, 9, 268, 8, 9, 11, 9, 12, 9, 269,
		1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 276, 8, 10, 1, 10, 1, 10, 1, 10, 3,
		10, 281, 8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 5, 11, 287, 8, 11, 10, 11,
		12, 11, 290, 9, 11, 1, 12, 1, 12, 1, 12, 3, 12, 295, 8, 12, 1, 13, 1, 13,
		1, 13, 3, 13, 300, 8, 13, 1, 13, 1, 13, 1, 13, 5, 13, 305, 8, 13, 10, 13,
		12, 13, 308, 9, 13, 1, 14, 1, 14, 1, 14, 4, 14, 313, 8, 14, 11, 14, 12,
		14, 314, 1, 15, 1, 15, 1, 15, 5, 15, 320, 8, 15, 10, 15, 12, 15, 323, 9,
		15, 1, 16, 4, 16, 326, 8, 16, 11, 16, 12, 16, 327, 1, 16, 1, 16, 5, 16,
		332, 8, 16, 10, 16, 12, 16, 335, 9, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 357, 8, 17, 1, 18, 1, 18, 1,
		18, 4, 18, 362, 8, 18, 11, 18, 12, 18, 363, 1, 18, 3, 18, 367, 8, 18, 1,
		19, 1, 19, 1, 20, 1, 20, 3, 20, 373, 8, 20, 1, 21, 1, 21, 1, 21, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 383, 8, 22, 10, 22, 12, 22, 386, 9,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 392, 8, 22, 1, 23, 1, 23, 1, 23,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 405, 8,
		24, 1, 25, 1, 25, 3, 25, 409, 8, 25, 1, 26, 1, 26, 1, 26, 1, 26, 4, 26,
		415, 8, 26, 11, 26, 12, 26, 416, 3, 26, 419, 8, 26, 1, 26, 3, 26, 422,
		8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 4, 28, 430, 8, 28, 11,
		28, 12, 28, 431, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 3, 30, 440,
		8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 447, 8, 31, 1, 32, 1,
		32, 1, 32, 3, 32, 452, 8, 32, 1, 33, 1, 33, 4, 33, 456, 8, 33, 11, 33,
		12, 33, 457, 1, 33, 3, 33, 461, 8, 33, 1, 33, 5, 33, 464, 8, 33, 10, 33,
		12, 33, 467, 9, 33, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 473, 8, 34, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 480, 8, 35, 10, 35, 12, 35, 483, 9,
		35, 1, 35, 1, 35, 3, 35, 487, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		5, 35, 494, 8, 35, 10, 35, 12, 35, 497, 9, 35, 1, 35, 1, 35, 3, 35, 501,
		8, 35, 3, 35, 503, 8, 35, 1, 36, 1, 36, 3, 36, 507, 8, 36, 1, 36, 1, 36,
		5, 36, 511, 8, 36, 10, 36, 12, 36, 514, 9, 36, 1, 36, 4, 36, 517, 8, 36,
		11, 36, 12, 36, 518, 1, 36, 1, 36, 1, 36, 3, 36, 524, 8, 36, 3, 36, 526,
		8, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1,
		39, 1, 39, 4, 39, 539, 8, 39, 11, 39, 12, 39, 540, 1, 39, 1, 39, 4, 39,
		545, 8, 39, 11, 39, 12, 39, 546, 3, 39, 549, 8, 39, 1, 39, 3, 39, 552,
		8, 39, 1, 40, 1, 40, 5, 40, 556, 8, 40, 10, 40, 12, 40, 559, 9, 40, 1,
		40, 1, 40, 3, 40, 563, 8, 40, 1, 41, 1, 41, 1, 41, 3, 41, 568, 8, 41, 1,
		42, 1, 42, 1, 42, 3, 42, 573, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 585, 8, 44, 10, 44, 12, 44, 588,
		9, 44, 1, 45, 1, 45, 3, 45, 592, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 597,
		8, 45, 3, 45, 599, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 605, 8, 46,
		1, 46, 1, 46, 1, 46, 3, 46, 610, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3,
		46, 616, 8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 623, 8, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 630, 8, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 1, 47, 3, 47, 637, 8, 47, 3, 47, 639, 8, 47, 3, 47, 641, 8, 47,
		1, 48, 1, 48, 1, 48, 3, 48, 646, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 5, 49, 653, 8, 49, 10, 49, 12, 49, 656, 9, 49, 1, 50, 1, 50, 1, 50,
		1, 51, 1, 51, 1, 51, 3, 51, 664, 8, 51, 1, 51, 1, 51, 3, 51, 668, 8, 51,
		1, 51, 1, 51, 3, 51, 672, 8, 51, 1, 51, 1, 51, 3, 51, 676, 8, 51, 1, 52,
		1, 52, 3, 52, 680, 8, 52, 1, 53, 1, 53, 1, 53, 4, 53, 685, 8, 53, 11, 53,
		12, 53, 686, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 693, 8, 53, 1, 53, 1, 53,
		1, 53, 1, 53, 3, 53, 699, 8, 53, 5, 53, 701, 8, 53, 10, 53, 12, 53, 704,
		9, 53, 1, 53, 3, 53, 707, 8, 53, 1, 53, 4, 53, 710, 8, 53, 11, 53, 12,
		53, 711, 3, 53, 714, 8, 53, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 3, 55, 721,
		8, 55, 1, 55, 5, 55, 724, 8, 55, 10, 55, 12, 55, 727, 9, 55, 1, 56, 1,
		56, 1, 56, 5, 56, 732, 8, 56, 10, 56, 12, 56, 735, 9, 56, 1, 57, 1, 57,
		1, 57, 1, 57, 1, 57, 3, 57, 742, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3,
		57, 748, 8, 57, 1, 57, 3, 57, 751, 8, 57, 1, 57, 1, 57, 1, 57, 3, 57, 756,
		8, 57, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 765, 8,
		59, 10, 59, 12, 59, 768, 9, 59, 1, 60, 1, 60, 1, 60, 4, 60, 773, 8, 60,
		11, 60, 12, 60, 774, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 789, 8, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 5, 61, 800, 8, 61, 10, 61, 12,
		61, 803, 9, 61, 1, 62, 1, 62, 1, 62, 1, 431, 1, 122, 63, 0, 2, 4, 6, 8,
		10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
		46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
		82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 0, 11, 5, 0, 2, 6, 10, 12, 70, 70, 92, 93,
		107, 107, 2, 0, 2, 2, 107, 107, 3, 0, 30, 30, 62, 62, 79, 79, 13, 0, 3,
		6, 10, 18, 21, 21, 23, 30, 32, 32, 34, 34, 36, 37, 40, 42, 45, 51, 53,
		62, 65, 82, 84, 87, 106, 107, 1, 0, 103, 104, 2, 0, 36, 36, 39, 39, 3,
		0, 27, 27, 58, 58, 87, 87, 1, 0, 97, 102, 1, 0, 94, 95, 1, 0, 92, 93, 2,
		0, 1, 6, 105, 105, 900, 0, 126, 1, 0, 0, 0, 2, 135, 1, 0, 0, 0, 4, 212,
		1, 0, 0, 0, 6, 223, 1, 0, 0, 0, 8, 227, 1, 0, 0, 0, 10, 235, 1, 0, 0, 0,
		12, 246, 1, 0, 0, 0, 14, 258, 1, 0, 0, 0, 16, 260, 1, 0, 0, 0, 18, 267,
		1, 0, 0, 0, 20, 280, 1, 0, 0, 0, 22, 282, 1, 0, 0, 0, 24, 291, 1, 0, 0,
		0, 26, 296, 1, 0, 0, 0, 28, 312, 1, 0, 0, 0, 30, 316, 1, 0, 0, 0, 32, 325,
		1, 0, 0, 0, 34, 356, 1, 0, 0, 0, 36, 366, 1, 0, 0, 0, 38, 368, 1, 0, 0,
		0, 40, 372, 1, 0, 0, 0, 42, 374, 1, 0, 0, 0, 44, 391, 1, 0, 0, 0, 46, 393,
		1, 0, 0, 0, 48, 400, 1, 0, 0, 0, 50, 408, 1, 0, 0, 0, 52, 410, 1, 0, 0,
		0, 54, 423, 1, 0, 0, 0, 56, 427, 1, 0, 0, 0, 58, 435, 1, 0, 0, 0, 60, 437,
		1, 0, 0, 0, 62, 446, 1, 0, 0, 0, 64, 451, 1, 0, 0, 0, 66, 453, 1, 0, 0,
		0, 68, 472, 1, 0, 0, 0, 70, 502, 1, 0, 0, 0, 72, 504, 1, 0, 0, 0, 74, 527,
		1, 0, 0, 0, 76, 530, 1, 0, 0, 0, 78, 534, 1, 0, 0, 0, 80, 553, 1, 0, 0,
		0, 82, 567, 1, 0, 0, 0, 84, 572, 1, 0, 0, 0, 86, 574, 1, 0, 0, 0, 88, 579,
		1, 0, 0, 0, 90, 598, 1, 0, 0, 0, 92, 615, 1, 0, 0, 0, 94, 640, 1, 0, 0,
		0, 96, 642, 1, 0, 0, 0, 98, 647, 1, 0, 0, 0, 100, 657, 1, 0, 0, 0, 102,
		660, 1, 0, 0, 0, 104, 679, 1, 0, 0, 0, 106, 713, 1, 0, 0, 0, 108, 715,
		1, 0, 0, 0, 110, 718, 1, 0, 0, 0, 112, 728, 1, 0, 0, 0, 114, 755, 1, 0,
		0, 0, 116, 757, 1, 0, 0, 0, 118, 759, 1, 0, 0, 0, 120, 769, 1, 0, 0, 0,
		122, 788, 1, 0, 0, 0, 124, 804, 1, 0, 0, 0, 126, 128, 3, 2, 1, 0, 127,
		129, 3, 8, 4, 0, 128, 127, 1, 0, 0, 0, 128, 129, 1, 0, 0, 0, 129, 131,
		1, 0, 0, 0, 130, 132, 3, 26, 13, 0, 131, 130, 1, 0, 0, 0, 131, 132, 1,
		0, 0, 0, 132, 133, 1, 0, 0, 0, 133, 134, 5, 0, 0, 1, 134, 1, 1, 0, 0, 0,
		135, 139, 5, 7, 0, 0, 136, 138, 3, 4, 2, 0, 137, 136, 1, 0, 0, 0, 138,
		141, 1, 0, 0, 0, 139, 137, 1, 0, 0, 0, 139, 140, 1, 0, 0, 0, 140, 3, 1,
		0, 0, 0, 141, 139, 1, 0, 0, 0, 142, 143, 5, 10, 0, 0, 143, 149, 5, 89,
		0, 0, 144, 150, 3, 36, 18, 0, 145, 150, 5, 3, 0, 0, 146, 150, 5, 4, 0,
		0, 147, 150, 5, 5, 0, 0, 148, 150, 5, 6, 0, 0, 149, 144, 1, 0, 0, 0, 149,
		145, 1, 0, 0, 0, 149, 146, 1, 0, 0, 0, 149, 147, 1, 0, 0, 0, 149, 148,
		1, 0, 0, 0, 150, 151, 1, 0, 0, 0, 151, 213, 5, 89, 0, 0, 152, 153, 5, 11,
		0, 0, 153, 154, 5, 89, 0, 0, 154, 155, 3, 6, 3, 0, 155, 156, 5, 89, 0,
		0, 156, 213, 1, 0, 0, 0, 157, 158, 5, 12, 0, 0, 158, 162, 5, 89, 0, 0,
		159, 163, 5, 3, 0, 0, 160, 163, 5, 4, 0, 0, 161, 163, 3, 6, 3, 0, 162,
		159, 1, 0, 0, 0, 162, 160, 1, 0, 0, 0, 162, 161, 1, 0, 0, 0, 163, 164,
		1, 0, 0, 0, 164, 213, 5, 89, 0, 0, 165, 166, 5, 13, 0, 0, 166, 167, 5,
		89, 0, 0, 167, 168, 3, 6, 3, 0, 168, 169, 5, 89, 0, 0, 169, 213, 1, 0,
		0, 0, 170, 171, 5, 14, 0, 0, 171, 172, 5, 89, 0, 0, 172, 173, 3, 6, 3,
		0, 173, 174, 5, 89, 0, 0, 174, 213, 1, 0, 0, 0, 175, 176, 5, 15, 0, 0,
		176, 179, 5, 89, 0, 0, 177, 180, 5, 3, 0, 0, 178, 180, 3, 6, 3, 0, 179,
		177, 1, 0, 0, 0, 179, 178, 1, 0, 0, 0, 180, 181, 1, 0, 0, 0, 181, 213,
		5, 89, 0, 0, 182, 183, 5, 16, 0, 0, 183, 184, 5, 89, 0, 0, 184, 185, 3,
		6, 3, 0, 185, 186, 5, 89, 0, 0, 186, 213, 1, 0, 0, 0, 187, 188, 5, 17,
		0, 0, 188, 195, 3, 50, 25, 0, 189, 191, 5, 64, 0, 0, 190, 192, 3, 54, 27,
		0, 191, 190, 1, 0, 0, 0, 192, 193, 1, 0, 0, 0, 193, 191, 1, 0, 0, 0, 193,
		194, 1, 0, 0, 0, 194, 196, 1, 0, 0, 0, 195, 189, 1, 0, 0, 0, 195, 196,
		1, 0, 0, 0, 196, 198, 1, 0, 0, 0, 197, 199, 5, 89, 0, 0, 198, 197, 1, 0,
		0, 0, 198, 199, 1, 0, 0, 0, 199, 213, 1, 0, 0, 0, 200, 201, 5, 18, 0, 0,
		201, 202, 5, 89, 0, 0, 202, 203, 3, 6, 3, 0, 203, 204, 5, 89, 0, 0, 204,
		213, 1, 0, 0, 0, 205, 206, 3, 38, 19, 0, 206, 208, 5, 89, 0, 0, 207, 209,
		3, 6, 3, 0, 208, 207, 1, 0, 0, 0, 208, 209, 1, 0, 0, 0, 209, 210, 1, 0,
		0, 0, 210, 211, 5, 89, 0, 0, 211, 213, 1, 0, 0, 0, 212, 142, 1, 0, 0, 0,
		212, 152, 1, 0, 0, 0, 212, 157, 1, 0, 0, 0, 212, 165, 1, 0, 0, 0, 212,
		170, 1, 0, 0, 0, 212, 175, 1, 0, 0, 0, 212, 182, 1, 0, 0, 0, 212, 187,
		1, 0, 0, 0, 212, 200, 1, 0, 0, 0, 212, 205, 1, 0, 0, 0, 213, 5, 1, 0, 0,
		0, 214, 224, 3, 38, 19, 0, 215, 224, 5, 105, 0, 0, 216, 224, 5, 2, 0, 0,
		217, 224, 5, 1, 0, 0, 218, 224, 3, 124, 62, 0, 219, 224, 5, 3, 0, 0, 220,
		224, 5, 4, 0, 0, 221, 224, 5, 5, 0, 0, 222, 224, 5, 6, 0, 0, 223, 214,
		1, 0, 0, 0, 223, 215, 1, 0, 0, 0, 223, 216, 1, 0, 0, 0, 223, 217, 1, 0,
		0, 0, 223, 218, 1, 0, 0, 0, 223, 219, 1, 0, 0, 0, 223, 220, 1, 0, 0, 0,
		223, 221, 1, 0, 0, 0, 223, 222, 1, 0, 0, 0, 224, 225, 1, 0, 0, 0, 225,
		223, 1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 7, 1, 0, 0, 0, 227, 232, 5,
		8, 0, 0, 228, 231, 3, 10, 5, 0, 229, 231, 3, 12, 6, 0, 230, 228, 1, 0,
		0, 0, 230, 229, 1, 0, 0, 0, 231, 234, 1, 0, 0, 0, 232, 230, 1, 0, 0, 0,
		232, 233, 1, 0, 0, 0, 233, 9, 1, 0, 0, 0, 234, 232, 1, 0, 0, 0, 235, 236,
		3, 14, 7, 0, 236, 239, 3, 36, 18, 0, 237, 240, 3, 16, 8, 0, 238, 240, 3,
		22, 11, 0, 239, 237, 1, 0, 0, 0, 239, 238, 1, 0, 0, 0, 239, 240, 1, 0,
		0, 0, 240, 242, 1, 0, 0, 0, 241, 243, 3, 24, 12, 0, 242, 241, 1, 0, 0,
		0, 242, 243, 1, 0, 0, 0, 243, 244, 1, 0, 0, 0, 244, 245, 5, 89, 0, 0, 245,
		11, 1, 0, 0, 0, 246, 247, 5, 17, 0, 0, 247, 254, 3, 50, 25, 0, 248, 250,
		5, 64, 0, 0, 249, 251, 3, 54, 27, 0, 250, 249, 1, 0, 0, 0, 251, 252, 1,
		0, 0, 0, 252, 250, 1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253, 255, 1, 0, 0,
		0, 254, 248, 1, 0, 0, 0, 254, 255, 1, 0, 0, 0, 255, 256, 1, 0, 0, 0, 256,
		257, 5, 89, 0, 0, 257, 13, 1, 0, 0, 0, 258, 259, 5, 2, 0, 0, 259, 15, 1,
		0, 0, 0, 260, 262, 5, 19, 0, 0, 261, 263, 5, 20, 0, 0, 262, 261, 1, 0,
		0, 0, 262, 263, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 265, 3, 18, 9, 0,
		265, 17, 1, 0, 0, 0, 266, 268, 3, 20, 10, 0, 267, 266, 1, 0, 0, 0, 268,
		269, 1, 0, 0, 0, 269, 267, 1, 0, 0, 0, 269, 270, 1, 0, 0, 0, 270, 19, 1,
		0, 0, 0, 271, 275, 7, 0, 0, 0, 272, 273, 5, 90, 0, 0, 273, 274, 5, 2, 0,
		0, 274, 276, 5, 91, 0, 0, 275, 272, 1, 0, 0, 0, 275, 276, 1, 0, 0, 0, 276,
		281, 1, 0, 0, 0, 277, 278, 5, 90, 0, 0, 278, 279, 7, 1, 0, 0, 279, 281,
		5, 91, 0, 0, 280, 271, 1, 0, 0, 0, 280, 277, 1, 0, 0, 0, 281, 21, 1, 0,
		0, 0, 282, 283, 5, 21, 0, 0, 283, 288, 3, 118, 59, 0, 284, 285, 5, 56,
		0, 0, 285, 287, 3, 118, 59, 0, 286, 284, 1, 0, 0, 0, 287, 290, 1, 0, 0,
		0, 288, 286, 1, 0, 0, 0, 288, 289, 1, 0, 0, 0, 289, 23, 1, 0, 0, 0, 290,
		288, 1, 0, 0, 0, 291, 292, 5, 22, 0, 0, 292, 294, 5, 2, 0, 0, 293, 295,
		5, 74, 0, 0, 294, 293, 1, 0, 0, 0, 294, 295, 1, 0, 0, 0, 295, 25, 1, 0,
		0, 0, 296, 299, 5, 9, 0, 0, 297, 298, 5, 78, 0, 0, 298, 300, 3, 28, 14,
		0, 299, 297, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301,
		306, 5, 89, 0, 0, 302, 305, 3, 30, 15, 0, 303, 305, 3, 32, 16, 0, 304,
		302, 1, 0, 0, 0, 304, 303, 1, 0, 0, 0, 305, 308, 1, 0, 0, 0, 306, 304,
		1, 0, 0, 0, 306, 307, 1, 0, 0, 0, 307, 27, 1, 0, 0, 0, 308, 306, 1, 0,
		0, 0, 309, 310, 5, 28, 0, 0, 310, 311, 7, 2, 0, 0, 311, 313, 3, 122, 61,
		0, 312, 309, 1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314, 312, 1, 0, 0, 0, 314,
		315, 1, 0, 0, 0, 315, 29, 1, 0, 0, 0, 316, 317, 3, 36, 18, 0, 317, 321,
		5, 89, 0, 0, 318, 320, 3, 32, 16, 0, 319, 318, 1, 0, 0, 0, 320, 323, 1,
		0, 0, 0, 321, 319, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 31, 1, 0, 0,
		0, 323, 321, 1, 0, 0, 0, 324, 326, 3, 34, 17, 0, 325, 324, 1, 0, 0, 0,
		326, 327, 1, 0, 0, 0, 327, 325, 1, 0, 0, 0, 327, 328, 1, 0, 0, 0, 328,
		329, 1, 0, 0, 0, 329, 333, 5, 89, 0, 0, 330, 332, 5, 89, 0, 0, 331, 330,
		1, 0, 0, 0, 332, 335, 1, 0, 0, 0, 333, 331, 1, 0, 0, 0, 333, 334, 1, 0,
		0, 0, 334, 33, 1, 0, 0, 0, 335, 333, 1, 0, 0, 0, 336, 357, 3, 42, 21, 0,
		337, 357, 3, 44, 22, 0, 338, 357, 3, 98, 49, 0, 339, 357, 3, 88, 44, 0,
		340, 357, 3, 70, 35, 0, 341, 357, 3, 86, 43, 0, 342, 357, 3, 66, 33, 0,
		343, 357, 3, 72, 36, 0, 344, 357, 3, 78, 39, 0, 345, 357, 3, 80, 40, 0,
		346, 357, 3, 92, 46, 0, 347, 357, 3, 90, 45, 0, 348, 357, 3, 76, 38, 0,
		349, 357, 3, 48, 24, 0, 350, 357, 3, 52, 26, 0, 351, 357, 3, 94, 47, 0,
		352, 357, 3, 96, 48, 0, 353, 357, 3, 46, 23, 0, 354, 357, 3, 104, 52, 0,
		355, 357, 5, 16, 0, 0, 356, 336, 1, 0, 0, 0, 356, 337, 1, 0, 0, 0, 356,
		338, 1, 0, 0, 0, 356, 339, 1, 0, 0, 0, 356, 340, 1, 0, 0, 0, 356, 341,
		1, 0, 0, 0, 356, 342, 1, 0, 0, 0, 356, 343, 1, 0, 0, 0, 356, 344, 1, 0,
		0, 0, 356, 345, 1, 0, 0, 0, 356, 346, 1, 0, 0, 0, 356, 347, 1, 0, 0, 0,
		356, 348, 1, 0, 0, 0, 356, 349, 1, 0, 0, 0, 356, 350, 1, 0, 0, 0, 356,
		351, 1, 0, 0, 0, 356, 352, 1, 0, 0, 0, 356, 353, 1, 0, 0, 0, 356, 354,
		1, 0, 0, 0, 356, 355, 1, 0, 0, 0, 357, 35, 1, 0, 0, 0, 358, 361, 3, 38,
		19, 0, 359, 360, 5, 56, 0, 0, 360, 362, 3, 38, 19, 0, 361, 359, 1, 0, 0,
		0, 362, 363, 1, 0, 0, 0, 363, 361, 1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364,
		367, 1, 0, 0, 0, 365, 367, 3, 38, 19, 0, 366, 358, 1, 0, 0, 0, 366, 365,
		1, 0, 0, 0, 367, 37, 1, 0, 0, 0, 368, 369, 7, 3, 0, 0, 369, 39, 1, 0, 0,
		0, 370, 373, 3, 110, 55, 0, 371, 373, 3, 112, 56, 0, 372, 370, 1, 0, 0,
		0, 372, 371, 1, 0, 0, 0, 373, 41, 1, 0, 0, 0, 374, 375, 5, 23, 0, 0, 375,
		376, 3, 110, 55, 0, 376, 43, 1, 0, 0, 0, 377, 378, 5, 24, 0, 0, 378, 379,
		3, 110, 55, 0, 379, 380, 5, 75, 0, 0, 380, 384, 3, 110, 55, 0, 381, 383,
		3, 74, 37, 0, 382, 381, 1, 0, 0, 0, 383, 386, 1, 0, 0, 0, 384, 382, 1,
		0, 0, 0, 384, 385, 1, 0, 0, 0, 385, 392, 1, 0, 0, 0, 386, 384, 1, 0, 0,
		0, 387, 388, 5, 24, 0, 0, 388, 389, 3, 110, 55, 0, 389, 390, 3, 74, 37,
		0, 390, 392, 1, 0, 0, 0, 391, 377, 1, 0, 0, 0, 391, 387, 1, 0, 0, 0, 392,
		45, 1, 0, 0, 0, 393, 394, 5, 26, 0, 0, 394, 395, 3, 36, 18, 0, 395, 396,
		5, 75, 0, 0, 396, 397, 5, 61, 0, 0, 397, 398, 5, 75, 0, 0, 398, 399, 3,
		36, 18, 0, 399, 47, 1, 0, 0, 0, 400, 401, 5, 29, 0, 0, 401, 404, 3, 122,
		61, 0, 402, 403, 5, 78, 0, 0, 403, 405, 3, 28, 14, 0, 404, 402, 1, 0, 0,
		0, 404, 405, 1, 0, 0, 0, 405, 49, 1, 0, 0, 0, 406, 409, 5, 105, 0, 0, 407,
		409, 3, 38, 19, 0, 408, 406, 1, 0, 0, 0, 408, 407, 1, 0, 0, 0, 409, 51,
		1, 0, 0, 0, 410, 411, 5, 17, 0, 0, 411, 418, 3, 50, 25, 0, 412, 414, 5,
		64, 0, 0, 413, 415, 3, 54, 27, 0, 414, 413, 1, 0, 0, 0, 415, 416, 1, 0,
		0, 0, 416, 414, 1, 0, 0, 0, 416, 417, 1, 0, 0, 0, 417, 419, 1, 0, 0, 0,
		418, 412, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419, 421, 1, 0, 0, 0, 420,
		422, 3, 36, 18, 0, 421, 420, 1, 0, 0, 0, 421, 422, 1, 0, 0, 0, 422, 53,
		1, 0, 0, 0, 423, 424, 3, 56, 28, 0, 424, 425, 5, 28, 0, 0, 425, 426, 3,
		56, 28, 0, 426, 55, 1, 0, 0, 0, 427, 429, 3, 58, 29, 0, 428, 430, 9, 0,
		0, 0, 429, 428, 1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431, 432, 1, 0, 0, 0,
		431, 429, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 434, 3, 58, 29, 0, 434,
		57, 1, 0, 0, 0, 435, 436, 7, 4, 0, 0, 436, 59, 1, 0, 0, 0, 437, 439, 3,
		122, 61, 0, 438, 440, 3, 62, 31, 0, 439, 438, 1, 0, 0, 0, 439, 440, 1,
		0, 0, 0, 440, 61, 1, 0, 0, 0, 441, 442, 5, 31, 0, 0, 442, 447, 3, 64, 32,
		0, 443, 444, 5, 32, 0, 0, 444, 445, 5, 28, 0, 0, 445, 447, 3, 64, 32, 0,
		446, 441, 1, 0, 0, 0, 446, 443, 1, 0, 0, 0, 447, 63, 1, 0, 0, 0, 448, 452,
		3, 122, 61, 0, 449, 452, 5, 67, 0, 0, 450, 452, 5, 68, 0, 0, 451, 448,
		1, 0, 0, 0, 451, 449, 1, 0, 0, 0, 451, 450, 1, 0, 0, 0, 452, 65, 1, 0,
		0, 0, 453, 455, 5, 33, 0, 0, 454, 456, 3, 60, 30, 0, 455, 454, 1, 0, 0,
		0, 456, 457, 1, 0, 0, 0, 457, 455, 1, 0, 0, 0, 457, 458, 1, 0, 0, 0, 458,
		460, 1, 0, 0, 0, 459, 461, 3, 68, 34, 0, 460, 459, 1, 0, 0, 0, 460, 461,
		1, 0, 0, 0, 461, 465, 1, 0, 0, 0, 462, 464, 3, 60, 30, 0, 463, 462, 1,
		0, 0, 0, 464, 467, 1, 0, 0, 0, 465, 463, 1, 0, 0, 0, 465, 466, 1, 0, 0,
		0, 466, 67, 1, 0, 0, 0, 467, 465, 1, 0, 0, 0, 468, 469, 5, 84, 0, 0, 469,
		470, 5, 85, 0, 0, 470, 473, 5, 86, 0, 0, 471, 473, 5, 83, 0, 0, 472, 468,
		1, 0, 0, 0, 472, 471, 1, 0, 0, 0, 473, 69, 1, 0, 0, 0, 474, 475, 5, 34,
		0, 0, 475, 476, 3, 110, 55, 0, 476, 477, 5, 47, 0, 0, 477, 481, 3, 110,
		55, 0, 478, 480, 3, 74, 37, 0, 479, 478, 1, 0, 0, 0, 480, 483, 1, 0, 0,
		0, 481, 479, 1, 0, 0, 0, 481, 482, 1, 0, 0, 0, 482, 486, 1, 0, 0, 0, 483,
		481, 1, 0, 0, 0, 484, 485, 5, 63, 0, 0, 485, 487, 3, 110, 55, 0, 486, 484,
		1, 0, 0, 0, 486, 487, 1, 0, 0, 0, 487, 503, 1, 0, 0, 0, 488, 489, 5, 34,
		0, 0, 489, 490, 3, 110, 55, 0, 490, 491, 5, 28, 0, 0, 491, 495, 3, 110,
		55, 0, 492, 494, 3, 74, 37, 0, 493, 492, 1, 0, 0, 0, 494, 497, 1, 0, 0,
		0, 495, 493, 1, 0, 0, 0, 495, 496, 1, 0, 0, 0, 496, 500, 1, 0, 0, 0, 497,
		495, 1, 0, 0, 0, 498, 499, 5, 63, 0, 0, 499, 501, 3, 110, 55, 0, 500, 498,
		1, 0, 0, 0, 500, 501, 1, 0, 0, 0, 501, 503, 1, 0, 0, 0, 502, 474, 1, 0,
		0, 0, 502, 488, 1, 0, 0, 0, 503, 71, 1, 0, 0, 0, 504, 506, 5, 41, 0, 0,
		505, 507, 3, 40, 20, 0, 506, 505, 1, 0, 0, 0, 506, 507, 1, 0, 0, 0, 507,
		512, 1, 0, 0, 0, 508, 509, 5, 25, 0, 0, 509, 511, 3, 40, 20, 0, 510, 508,
		1, 0, 0, 0, 511, 514, 1, 0, 0, 0, 512, 510, 1, 0, 0, 0, 512, 513, 1, 0,
		0, 0, 513, 516, 1, 0, 0, 0, 514, 512, 1, 0, 0, 0, 515, 517, 3, 106, 53,
		0, 516, 515, 1, 0, 0, 0, 517, 518, 1, 0, 0, 0, 518, 516, 1, 0, 0, 0, 518,
		519, 1, 0, 0, 0, 519, 525, 1, 0, 0, 0, 520, 526, 5, 38, 0, 0, 521, 523,
		5, 36, 0, 0, 522, 524, 3, 36, 18, 0, 523, 522, 1, 0, 0, 0, 523, 524, 1,
		0, 0, 0, 524, 526, 1, 0, 0, 0, 525, 520, 1, 0, 0, 0, 525, 521, 1, 0, 0,
		0, 526, 73, 1, 0, 0, 0, 527, 528, 5, 44, 0, 0, 528, 529, 3, 110, 55, 0,
		529, 75, 1, 0, 0, 0, 530, 531, 5, 45, 0, 0, 531, 532, 5, 75, 0, 0, 532,
		533, 3, 110, 55, 0, 533, 77, 1, 0, 0, 0, 534, 535, 5, 46, 0, 0, 535, 536,
		3, 112, 56, 0, 536, 538, 5, 72, 0, 0, 537, 539, 3, 34, 17, 0, 538, 537,
		1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 538, 1, 0, 0, 0, 540, 541, 1, 0,
		0, 0, 541, 548, 1, 0, 0, 0, 542, 544, 5, 35, 0, 0, 543, 545, 3, 34, 17,
		0, 544, 543, 1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546, 544, 1, 0, 0, 0, 546,
		547, 1, 0, 0, 0, 547, 549, 1, 0, 0, 0, 548, 542, 1, 0, 0, 0, 548, 549,
		1, 0, 0, 0, 549, 551, 1, 0, 0, 0, 550, 552, 7, 5, 0, 0, 551, 550, 1, 0,
		0, 0, 551, 552, 1, 0, 0, 0, 552, 79, 1, 0, 0, 0, 553, 557, 5, 48, 0, 0,
		554, 556, 3, 82, 41, 0, 555, 554, 1, 0, 0, 0, 556, 559, 1, 0, 0, 0, 557,
		555, 1, 0, 0, 0, 557, 558, 1, 0, 0, 0, 558, 560, 1, 0, 0, 0, 559, 557,
		1, 0, 0, 0, 560, 562, 5, 36, 0, 0, 561, 563, 3, 36, 18, 0, 562, 561, 1,
		0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 81, 1, 0, 0, 0, 564, 568, 3, 84, 42,
		0, 565, 568, 3, 34, 17, 0, 566, 568, 3, 32, 16, 0, 567, 564, 1, 0, 0, 0,
		567, 565, 1, 0, 0, 0, 567, 566, 1, 0, 0, 0, 568, 83, 1, 0, 0, 0, 569, 573,
		3, 102, 51, 0, 570, 573, 3, 108, 54, 0, 571, 573, 3, 100, 50, 0, 572, 569,
		1, 0, 0, 0, 572, 570, 1, 0, 0, 0, 572, 571, 1, 0, 0, 0, 573, 85, 1, 0,
		0, 0, 574, 575, 5, 50, 0, 0, 575, 576, 3, 110, 55, 0, 576, 577, 5, 75,
		0, 0, 577, 578, 3, 110, 55, 0, 578, 87, 1, 0, 0, 0, 579, 580, 5, 51, 0,
		0, 580, 581, 3, 110, 55, 0, 581, 582, 5, 28, 0, 0, 582, 586, 3, 110, 55,
		0, 583, 585, 3, 74, 37, 0, 584, 583, 1, 0, 0, 0, 585, 588, 1, 0, 0, 0,
		586, 584, 1, 0, 0, 0, 586, 587, 1, 0, 0, 0, 587, 89, 1, 0, 0, 0, 588, 586,
		1, 0, 0, 0, 589, 591, 5, 52, 0, 0, 590, 592, 3, 36, 18, 0, 591, 590, 1,
		0, 0, 0, 591, 592, 1, 0, 0, 0, 592, 599, 1, 0, 0, 0, 593, 594, 5, 53, 0,
		0, 594, 596, 5, 54, 0, 0, 595, 597, 3, 36, 18, 0, 596, 595, 1, 0, 0, 0,
		596, 597, 1, 0, 0, 0, 597, 599, 1, 0, 0, 0, 598, 589, 1, 0, 0, 0, 598,
		593, 1, 0, 0, 0, 599, 91, 1, 0, 0, 0, 600, 601, 5, 60, 0, 0, 601, 604,
		3, 122, 61, 0, 602, 603, 5, 73, 0, 0, 603, 605, 3, 122, 61, 0, 604, 602,
		1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605, 609, 1, 0, 0, 0, 606, 607, 3, 122,
		61, 0, 607, 608, 5, 74, 0, 0, 608, 610, 1, 0, 0, 0, 609, 606, 1, 0, 0,
		0, 609, 610, 1, 0, 0, 0, 610, 616, 1, 0, 0, 0, 611, 612, 5, 60, 0, 0, 612,
		613, 3, 110, 55, 0, 613, 614, 5, 74, 0, 0, 614, 616, 1, 0, 0, 0, 615, 600,
		1, 0, 0, 0, 615, 611, 1, 0, 0, 0, 616, 93, 1, 0, 0, 0, 617, 618, 5, 66,
		0, 0, 618, 619, 5, 37, 0, 0, 619, 620, 5, 57, 0, 0, 620, 622, 5, 40, 0,
		0, 621, 623, 3, 36, 18, 0, 622, 621, 1, 0, 0, 0, 622, 623, 1, 0, 0, 0,
		623, 641, 1, 0, 0, 0, 624, 625, 5, 66, 0, 0, 625, 626, 3, 38, 19, 0, 626,
		627, 5, 57, 0, 0, 627, 629, 5, 40, 0, 0, 628, 630, 3, 36, 18, 0, 629, 628,
		1, 0, 0, 0, 629, 630, 1, 0, 0, 0, 630, 641, 1, 0, 0, 0, 631, 632, 5, 66,
		0, 0, 632, 638, 3, 122, 61, 0, 633, 634, 5, 57, 0, 0, 634, 636, 5, 40,
		0, 0, 635, 637, 3, 36, 18, 0, 636, 635, 1, 0, 0, 0, 636, 637, 1, 0, 0,
		0, 637, 639, 1, 0, 0, 0, 638, 633, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639,
		641, 1, 0, 0, 0, 640, 617, 1, 0, 0, 0, 640, 624, 1, 0, 0, 0, 640, 631,
		1, 0, 0, 0, 641, 95, 1, 0, 0, 0, 642, 645, 5, 70, 0, 0, 643, 646, 5, 65,
		0, 0, 644, 646, 3, 36, 18, 0, 645, 643, 1, 0, 0, 0, 645, 644, 1, 0, 0,
		0, 645, 646, 1, 0, 0, 0, 646, 97, 1, 0, 0, 0, 647, 648, 5, 71, 0, 0, 648,
		649, 3, 110, 55, 0, 649, 650, 5, 43, 0, 0, 650, 654, 3, 110, 55, 0, 651,
		653, 3, 74, 37, 0, 652, 651, 1, 0, 0, 0, 653, 656, 1, 0, 0, 0, 654, 652,
		1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 99, 1, 0, 0, 0, 656, 654, 1, 0,
		0, 0, 657, 658, 5, 77, 0, 0, 658, 659, 3, 112, 56, 0, 659, 101, 1, 0, 0,
		0, 660, 663, 5, 80, 0, 0, 661, 664, 3, 120, 60, 0, 662, 664, 3, 118, 59,
		0, 663, 661, 1, 0, 0, 0, 663, 662, 1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664,
		667, 1, 0, 0, 0, 665, 666, 5, 43, 0, 0, 666, 668, 3, 122, 61, 0, 667, 665,
		1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 671, 1, 0, 0, 0, 669, 670, 5, 75,
		0, 0, 670, 672, 3, 122, 61, 0, 671, 669, 1, 0, 0, 0, 671, 672, 1, 0, 0,
		0, 672, 675, 1, 0, 0, 0, 673, 674, 5, 28, 0, 0, 674, 676, 3, 122, 61, 0,
		675, 673, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676, 103, 1, 0, 0, 0, 677,
		680, 3, 102, 51, 0, 678, 680, 5, 80, 0, 0, 679, 677, 1, 0, 0, 0, 679, 678,
		1, 0, 0, 0, 680, 105, 1, 0, 0, 0, 681, 682, 5, 81, 0, 0, 682, 684, 5, 59,
		0, 0, 683, 685, 3, 34, 17, 0, 684, 683, 1, 0, 0, 0, 685, 686, 1, 0, 0,
		0, 686, 684, 1, 0, 0, 0, 686, 687, 1, 0, 0, 0, 687, 714, 1, 0, 0, 0, 688,
		689, 5, 81, 0, 0, 689, 692, 3, 40, 20, 0, 690, 691, 5, 73, 0, 0, 691, 693,
		3, 40, 20, 0, 692, 690, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 702, 1,
		0, 0, 0, 694, 695, 5, 25, 0, 0, 695, 698, 3, 40, 20, 0, 696, 697, 5, 73,
		0, 0, 697, 699, 3, 40, 20, 0, 698, 696, 1, 0, 0, 0, 698, 699, 1, 0, 0,
		0, 699, 701, 1, 0, 0, 0, 700, 694, 1, 0, 0, 0, 701, 704, 1, 0, 0, 0, 702,
		700, 1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 706, 1, 0, 0, 0, 704, 702,
		1, 0, 0, 0, 705, 707, 5, 25, 0, 0, 706, 705, 1, 0, 0, 0, 706, 707, 1, 0,
		0, 0, 707, 709, 1, 0, 0, 0, 708, 710, 3, 34, 17, 0, 709, 708, 1, 0, 0,
		0, 710, 711, 1, 0, 0, 0, 711, 709, 1, 0, 0, 0, 711, 712, 1, 0, 0, 0, 712,
		714, 1, 0, 0, 0, 713, 681, 1, 0, 0, 0, 713, 688, 1, 0, 0, 0, 714, 107,
		1, 0, 0, 0, 715, 716, 5, 82, 0, 0, 716, 717, 3, 112, 56, 0, 717, 109, 1,
		0, 0, 0, 718, 725, 3, 122, 61, 0, 719, 721, 5, 88, 0, 0, 720, 719, 1, 0,
		0, 0, 720, 721, 1, 0, 0, 0, 721, 722, 1, 0, 0, 0, 722, 724, 3, 122, 61,
		0, 723, 720, 1, 0, 0, 0, 724, 727, 1, 0, 0, 0, 725, 723, 1, 0, 0, 0, 725,
		726, 1, 0, 0, 0, 726, 111, 1, 0, 0, 0, 727, 725, 1, 0, 0, 0, 728, 733,
		3, 114, 57, 0, 729, 730, 7, 6, 0, 0, 730, 732, 3, 114, 57, 0, 731, 729,
		1, 0, 0, 0, 732, 735, 1, 0, 0, 0, 733, 731, 1, 0, 0, 0, 733, 734, 1, 0,
		0, 0, 734, 113, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 736, 737, 5, 90, 0, 0,
		737, 738, 3, 112, 56, 0, 738, 739, 5, 91, 0, 0, 739, 756, 1, 0, 0, 0, 740,
		742, 5, 55, 0, 0, 741, 740, 1, 0, 0, 0, 741, 742, 1, 0, 0, 0, 742, 743,
		1, 0, 0, 0, 743, 747, 3, 122, 61, 0, 744, 745, 3, 116, 58, 0, 745, 746,
		3, 122, 61, 0, 746, 748, 1, 0, 0, 0, 747, 744, 1, 0, 0, 0, 747, 748, 1,
		0, 0, 0, 748, 756, 1, 0, 0, 0, 749, 751, 5, 55, 0, 0, 750, 749, 1, 0, 0,
		0, 750, 751, 1, 0, 0, 0, 751, 752, 1, 0, 0, 0, 752, 753, 3, 116, 58, 0,
		753, 754, 3, 122, 61, 0, 754, 756, 1, 0, 0, 0, 755, 736, 1, 0, 0, 0, 755,
		741, 1, 0, 0, 0, 755, 750, 1, 0, 0, 0, 756, 115, 1, 0, 0, 0, 757, 758,
		7, 7, 0, 0, 758, 117, 1, 0, 0, 0, 759, 766, 3, 38, 19, 0, 760, 761, 5,
		90, 0, 0, 761, 762, 3, 122, 61, 0, 762, 763, 5, 91, 0, 0, 763, 765, 1,
		0, 0, 0, 764, 760, 1, 0, 0, 0, 765, 768, 1, 0, 0, 0, 766, 764, 1, 0, 0,
		0, 766, 767, 1, 0, 0, 0, 767, 119, 1, 0, 0, 0, 768, 766, 1, 0, 0, 0, 769,
		772, 3, 118, 59, 0, 770, 771, 5, 56, 0, 0, 771, 773, 3, 118, 59, 0, 772,
		770, 1, 0, 0, 0, 773, 774, 1, 0, 0, 0, 774, 772, 1, 0, 0, 0, 774, 775,
		1, 0, 0, 0, 775, 121, 1, 0, 0, 0, 776, 777, 6, 61, -1, 0, 777, 778, 5,
		92, 0, 0, 778, 789, 3, 122, 61, 9, 779, 780, 5, 93, 0, 0, 780, 789, 3,
		122, 61, 8, 781, 782, 5, 90, 0, 0, 782, 783, 3, 122, 61, 0, 783, 784, 5,
		91, 0, 0, 784, 789, 1, 0, 0, 0, 785, 789, 3, 124, 62, 0, 786, 789, 3, 120,
		60, 0, 787, 789, 3, 118, 59, 0, 788, 776, 1, 0, 0, 0, 788, 779, 1, 0, 0,
		0, 788, 781, 1, 0, 0, 0, 788, 785, 1, 0, 0, 0, 788, 786, 1, 0, 0, 0, 788,
		787, 1, 0, 0, 0, 789, 801, 1, 0, 0, 0, 790, 791, 10, 7, 0, 0, 791, 792,
		5, 96, 0, 0, 792, 800, 3, 122, 61, 8, 793, 794, 10, 6, 0, 0, 794, 795,
		7, 8, 0, 0, 795, 800, 3, 122, 61, 7, 796, 797, 10, 5, 0, 0, 797, 798, 7,
		9, 0, 0, 798, 800, 3, 122, 61, 6, 799, 790, 1, 0, 0, 0, 799, 793, 1, 0,
		0, 0, 799, 796, 1, 0, 0, 0, 800, 803, 1, 0, 0, 0, 801, 799, 1, 0, 0, 0,
		801, 802, 1, 0, 0, 0, 802, 123, 1, 0, 0, 0, 803, 801, 1, 0, 0, 0, 804,
		805, 7, 10, 0, 0, 805, 125, 1, 0, 0, 0, 107, 128, 131, 139, 149, 162, 179,
		193, 195, 198, 208, 212, 223, 225, 230, 232, 239, 242, 252, 254, 262, 269,
		275, 280, 288, 294, 299, 304, 306, 314, 321, 327, 333, 356, 363, 366, 372,
		384, 391, 404, 408, 416, 418, 421, 431, 439, 446, 451, 457, 460, 465, 472,
		481, 486, 495, 500, 502, 506, 512, 518, 523, 525, 540, 546, 548, 551, 557,
		562, 567, 572, 586, 591, 596, 598, 604, 609, 615, 622, 629, 636, 638, 640,
		645, 654, 663, 667, 671, 675, 679, 686, 692, 698, 702, 706, 711, 713, 720,
		725, 733, 741, 747, 750, 755, 766, 774, 788, 799, 801,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// bbyCBLParserInit initializes any static state used to implement bbyCBLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewbbyCBLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func BbyCBLParserInit() {
	staticData := &BbyCBLParserStaticData
	staticData.once.Do(bbycblParserInit)
}

// NewbbyCBLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewbbyCBLParser(input antlr.TokenStream) *bbyCBLParser {
	BbyCBLParserInit()
	this := new(bbyCBLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &BbyCBLParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "bbyCBL.g4"

	return this
}

// bbyCBLParser tokens.
const (
	bbyCBLParserEOF                     = antlr.TokenEOF
	bbyCBLParserFLOAT                   = 1
	bbyCBLParserNUMBER                  = 2
	bbyCBLParserDATE                    = 3
	bbyCBLParserDATE_UNDERSCORE         = 4
	bbyCBLParserANY_DATE                = 5
	bbyCBLParserANY_DATE_UNDERSCORE     = 6
	bbyCBLParserIDENTIFICATION_DIVISION = 7
	bbyCBLParserDATA_DIVISION           = 8
	bbyCBLParserPROCEDURE_DIVISION      = 9
	bbyCBLParserPROGRAM_ID              = 10
	bbyCBLParserAUTHOR                  = 11
	bbyCBLParserDATE_WRITTEN            = 12
	bbyCBLParserINSTALLATION            = 13
	bbyCBLParserSECURITY                = 14
	bbyCBLParserDATE_COMPILED           = 15
	bbyCBLParserBASE                    = 16
	bbyCBLParserCOPY                    = 17
	bbyCBLParserDESCRIPTION             = 18
	bbyCBLParserPICTURE                 = 19
	bbyCBLParserIS                      = 20
	bbyCBLParserLIKE                    = 21
	bbyCBLParserOCCURS                  = 22
	bbyCBLParserACCEPT                  = 23
	bbyCBLParserADD                     = 24
	bbyCBLParserALSO                    = 25
	bbyCBLParserALTER                   = 26
	bbyCBLParserAND                     = 27
	bbyCBLParserBY                      = 28
	bbyCBLParserCALL                    = 29
	bbyCBLParserCONTENT                 = 30
	bbyCBLParserDELIMITED_BY            = 31
	bbyCBLParserDELIMITED               = 32
	bbyCBLParserDISPLAY                 = 33
	bbyCBLParserDIVIDE                  = 34
	bbyCBLParserELSE                    = 35
	bbyCBLParserEND                     = 36
	bbyCBLParserOFF                     = 37
	bbyCBLParserEND_EVALUATE            = 38
	bbyCBLParserEND_IF                  = 39
	bbyCBLParserERROR                   = 40
	bbyCBLParserEVALUATE                = 41
	bbyCBLParserFALSE                   = 42
	bbyCBLParserFROM                    = 43
	bbyCBLParserGIVING                  = 44
	bbyCBLParserGO                      = 45
	bbyCBLParserIF                      = 46
	bbyCBLParserINTO                    = 47
	bbyCBLParserLOOP                    = 48
	bbyCBLParserLOW_VALUES              = 49
	bbyCBLParserMOVE                    = 50
	bbyCBLParserMULTIPLY                = 51
	bbyCBLParserNEXT_SENTENCE           = 52
	bbyCBLParserNEXT                    = 53
	bbyCBLParserSENTENCE                = 54
	bbyCBLParserNOT                     = 55
	bbyCBLParserOF                      = 56
	bbyCBLParserON                      = 57
	bbyCBLParserOR                      = 58
	bbyCBLParserOTHER                   = 59
	bbyCBLParserPERFORM                 = 60
	bbyCBLParserPROCEED                 = 61
	bbyCBLParserREFERENCE               = 62
	bbyCBLParserREMAINDER               = 63
	bbyCBLParserREPLACING               = 64
	bbyCBLParserRUN                     = 65
	bbyCBLParserSIGNAL                  = 66
	bbyCBLParserSIZE                    = 67
	bbyCBLParserSPACE                   = 68
	bbyCBLParserSPACES                  = 69
	bbyCBLParserSTOP                    = 70
	bbyCBLParserSUBTRACT                = 71
	bbyCBLParserTHEN                    = 72
	bbyCBLParserTHROUGH                 = 73
	bbyCBLParserTIMES                   = 74
	bbyCBLParserTO                      = 75
	bbyCBLParserTRUE                    = 76
	bbyCBLParserUNTIL                   = 77
	bbyCBLParserUSING                   = 78
	bbyCBLParserVALUE                   = 79
	bbyCBLParserVARYING                 = 80
	bbyCBLParserWHEN                    = 81
	bbyCBLParserWHILE                   = 82
	bbyCBLParserWITH_NO_ADVANCING       = 83
	bbyCBLParserWITH                    = 84
	bbyCBLParserNO                      = 85
	bbyCBLParserADVANCING               = 86
	bbyCBLParserXOR                     = 87
	bbyCBLParserCOMMA                   = 88
	bbyCBLParserDOT                     = 89
	bbyCBLParserLPAREN                  = 90
	bbyCBLParserRPAREN                  = 91
	bbyCBLParserPLUS                    = 92
	bbyCBLParserMINUS                   = 93
	bbyCBLParserMULT                    = 94
	bbyCBLParserDIV                     = 95
	bbyCBLParserPOW                     = 96
	bbyCBLParserEQ                      = 97
	bbyCBLParserNE                      = 98
	bbyCBLParserLE                      = 99
	bbyCBLParserGE                      = 100
	bbyCBLParserLT                      = 101
	bbyCBLParserGT                      = 102
	bbyCBLParserTRIPLE_EQUAL            = 103
	bbyCBLParserDOUBLE_EQUAL            = 104
	bbyCBLParserSTRING                  = 105
	bbyCBLParserHIGH_VALUES             = 106
	bbyCBLParserIDENTIFIER              = 107
	bbyCBLParserWS                      = 108
)

// bbyCBLParser rules.
const (
	bbyCBLParserRULE_program                = 0
	bbyCBLParserRULE_identificationDivision = 1
	bbyCBLParserRULE_identificationClause   = 2
	bbyCBLParserRULE_freeFormText           = 3
	bbyCBLParserRULE_dataDivision           = 4
	bbyCBLParserRULE_dataEntry              = 5
	bbyCBLParserRULE_dataCopyStmt           = 6
	bbyCBLParserRULE_levelNumber            = 7
	bbyCBLParserRULE_pictureClause          = 8
	bbyCBLParserRULE_picturePattern         = 9
	bbyCBLParserRULE_pictureElement         = 10
	bbyCBLParserRULE_likeClause             = 11
	bbyCBLParserRULE_occursClause           = 12
	bbyCBLParserRULE_procedureDivision      = 13
	bbyCBLParserRULE_usingClause            = 14
	bbyCBLParserRULE_paragraph              = 15
	bbyCBLParserRULE_sentence               = 16
	bbyCBLParserRULE_statement              = 17
	bbyCBLParserRULE_identifier             = 18
	bbyCBLParserRULE_simpleId               = 19
	bbyCBLParserRULE_evalSubject            = 20
	bbyCBLParserRULE_acceptStmt             = 21
	bbyCBLParserRULE_addStmt                = 22
	bbyCBLParserRULE_alterStmt              = 23
	bbyCBLParserRULE_callStmt               = 24
	bbyCBLParserRULE_copySource             = 25
	bbyCBLParserRULE_copyStmt               = 26
	bbyCBLParserRULE_replacePair            = 27
	bbyCBLParserRULE_replaceBlock           = 28
	bbyCBLParserRULE_equalDelim             = 29
	bbyCBLParserRULE_displayItem            = 30
	bbyCBLParserRULE_delimiterSpec          = 31
	bbyCBLParserRULE_valueSpec              = 32
	bbyCBLParserRULE_displayStmt            = 33
	bbyCBLParserRULE_withNoAdvancingClause  = 34
	bbyCBLParserRULE_divideStmt             = 35
	bbyCBLParserRULE_evaluateStmt           = 36
	bbyCBLParserRULE_givingClause           = 37
	bbyCBLParserRULE_gotoStmt               = 38
	bbyCBLParserRULE_ifStmt                 = 39
	bbyCBLParserRULE_loopStmt               = 40
	bbyCBLParserRULE_loopContent            = 41
	bbyCBLParserRULE_loopControl            = 42
	bbyCBLParserRULE_moveStmt               = 43
	bbyCBLParserRULE_multiplyStmt           = 44
	bbyCBLParserRULE_nextSentenceStmt       = 45
	bbyCBLParserRULE_performStmt            = 46
	bbyCBLParserRULE_signalStmt             = 47
	bbyCBLParserRULE_stopStmt               = 48
	bbyCBLParserRULE_subtractStmt           = 49
	bbyCBLParserRULE_untilClause            = 50
	bbyCBLParserRULE_varyingClause          = 51
	bbyCBLParserRULE_varyingStmt            = 52
	bbyCBLParserRULE_whenClause             = 53
	bbyCBLParserRULE_whileClause            = 54
	bbyCBLParserRULE_exprList               = 55
	bbyCBLParserRULE_condition              = 56
	bbyCBLParserRULE_simpleCond             = 57
	bbyCBLParserRULE_comparator             = 58
	bbyCBLParserRULE_identifierSegment      = 59
	bbyCBLParserRULE_qualifiedId            = 60
	bbyCBLParserRULE_expr                   = 61
	bbyCBLParserRULE_literal                = 62
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentificationDivision() IIdentificationDivisionContext
	EOF() antlr.TerminalNode
	DataDivision() IDataDivisionContext
	ProcedureDivision() IProcedureDivisionContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) IdentificationDivision() IIdentificationDivisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentificationDivisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentificationDivisionContext)
}

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEOF, 0)
}

func (s *ProgramContext) DataDivision() IDataDivisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDivisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDivisionContext)
}

func (s *ProgramContext) ProcedureDivision() IProcedureDivisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDivisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, bbyCBLParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(126)
		p.IdentificationDivision()
	}
	p.SetState(128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserDATA_DIVISION {
		{
			p.SetState(127)
			p.DataDivision()
		}

	}
	p.SetState(131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserPROCEDURE_DIVISION {
		{
			p.SetState(130)
			p.ProcedureDivision()
		}

	}
	{
		p.SetState(133)
		p.Match(bbyCBLParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentificationDivisionContext is an interface to support dynamic dispatch.
type IIdentificationDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFICATION_DIVISION() antlr.TerminalNode
	AllIdentificationClause() []IIdentificationClauseContext
	IdentificationClause(i int) IIdentificationClauseContext

	// IsIdentificationDivisionContext differentiates from other interfaces.
	IsIdentificationDivisionContext()
}

type IdentificationDivisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentificationDivisionContext() *IdentificationDivisionContext {
	var p = new(IdentificationDivisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identificationDivision
	return p
}

func InitEmptyIdentificationDivisionContext(p *IdentificationDivisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identificationDivision
}

func (*IdentificationDivisionContext) IsIdentificationDivisionContext() {}

func NewIdentificationDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentificationDivisionContext {
	var p = new(IdentificationDivisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_identificationDivision

	return p
}

func (s *IdentificationDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentificationDivisionContext) IDENTIFICATION_DIVISION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserIDENTIFICATION_DIVISION, 0)
}

func (s *IdentificationDivisionContext) AllIdentificationClause() []IIdentificationClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentificationClauseContext); ok {
			len++
		}
	}

	tst := make([]IIdentificationClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentificationClauseContext); ok {
			tst[i] = t.(IIdentificationClauseContext)
			i++
		}
	}

	return tst
}

func (s *IdentificationDivisionContext) IdentificationClause(i int) IIdentificationClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentificationClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentificationClauseContext)
}

func (s *IdentificationDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentificationDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentificationDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterIdentificationDivision(s)
	}
}

func (s *IdentificationDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitIdentificationDivision(s)
	}
}

func (s *IdentificationDivisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitIdentificationDivision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) IdentificationDivision() (localctx IIdentificationDivisionContext) {
	localctx = NewIdentificationDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, bbyCBLParserRULE_identificationDivision)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(135)
		p.Match(bbyCBLParserIDENTIFICATION_DIVISION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9218841179211693176) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&6597077893119) != 0) {
		{
			p.SetState(136)
			p.IdentificationClause()
		}

		p.SetState(141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentificationClauseContext is an interface to support dynamic dispatch.
type IIdentificationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROGRAM_ID() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	DATE() antlr.TerminalNode
	DATE_UNDERSCORE() antlr.TerminalNode
	ANY_DATE() antlr.TerminalNode
	ANY_DATE_UNDERSCORE() antlr.TerminalNode
	AUTHOR() antlr.TerminalNode
	FreeFormText() IFreeFormTextContext
	DATE_WRITTEN() antlr.TerminalNode
	INSTALLATION() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	DATE_COMPILED() antlr.TerminalNode
	BASE() antlr.TerminalNode
	COPY() antlr.TerminalNode
	CopySource() ICopySourceContext
	REPLACING() antlr.TerminalNode
	AllReplacePair() []IReplacePairContext
	ReplacePair(i int) IReplacePairContext
	DESCRIPTION() antlr.TerminalNode
	SimpleId() ISimpleIdContext

	// IsIdentificationClauseContext differentiates from other interfaces.
	IsIdentificationClauseContext()
}

type IdentificationClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentificationClauseContext() *IdentificationClauseContext {
	var p = new(IdentificationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identificationClause
	return p
}

func InitEmptyIdentificationClauseContext(p *IdentificationClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identificationClause
}

func (*IdentificationClauseContext) IsIdentificationClauseContext() {}

func NewIdentificationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentificationClauseContext {
	var p = new(IdentificationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_identificationClause

	return p
}

func (s *IdentificationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentificationClauseContext) PROGRAM_ID() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPROGRAM_ID, 0)
}

func (s *IdentificationClauseContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserDOT)
}

func (s *IdentificationClauseContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, i)
}

func (s *IdentificationClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentificationClauseContext) DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE, 0)
}

func (s *IdentificationClauseContext) DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_UNDERSCORE, 0)
}

func (s *IdentificationClauseContext) ANY_DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE, 0)
}

func (s *IdentificationClauseContext) ANY_DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE_UNDERSCORE, 0)
}

func (s *IdentificationClauseContext) AUTHOR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserAUTHOR, 0)
}

func (s *IdentificationClauseContext) FreeFormText() IFreeFormTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFreeFormTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFreeFormTextContext)
}

func (s *IdentificationClauseContext) DATE_WRITTEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_WRITTEN, 0)
}

func (s *IdentificationClauseContext) INSTALLATION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserINSTALLATION, 0)
}

func (s *IdentificationClauseContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSECURITY, 0)
}

func (s *IdentificationClauseContext) DATE_COMPILED() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_COMPILED, 0)
}

func (s *IdentificationClauseContext) BASE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBASE, 0)
}

func (s *IdentificationClauseContext) COPY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCOPY, 0)
}

func (s *IdentificationClauseContext) CopySource() ICopySourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopySourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopySourceContext)
}

func (s *IdentificationClauseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREPLACING, 0)
}

func (s *IdentificationClauseContext) AllReplacePair() []IReplacePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplacePairContext); ok {
			len++
		}
	}

	tst := make([]IReplacePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplacePairContext); ok {
			tst[i] = t.(IReplacePairContext)
			i++
		}
	}

	return tst
}

func (s *IdentificationClauseContext) ReplacePair(i int) IReplacePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePairContext)
}

func (s *IdentificationClauseContext) DESCRIPTION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDESCRIPTION, 0)
}

func (s *IdentificationClauseContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *IdentificationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentificationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentificationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterIdentificationClause(s)
	}
}

func (s *IdentificationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitIdentificationClause(s)
	}
}

func (s *IdentificationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitIdentificationClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) IdentificationClause() (localctx IIdentificationClauseContext) {
	localctx = NewIdentificationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, bbyCBLParserRULE_identificationClause)
	var _la int

	p.SetState(212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(142)
			p.Match(bbyCBLParserPROGRAM_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(143)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(144)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(145)
				p.Match(bbyCBLParserDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(146)
				p.Match(bbyCBLParserDATE_UNDERSCORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(147)
				p.Match(bbyCBLParserANY_DATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(148)
				p.Match(bbyCBLParserANY_DATE_UNDERSCORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(151)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(152)
			p.Match(bbyCBLParserAUTHOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(153)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(154)
			p.FreeFormText()
		}
		{
			p.SetState(155)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(157)
			p.Match(bbyCBLParserDATE_WRITTEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(158)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(159)
				p.Match(bbyCBLParserDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(160)
				p.Match(bbyCBLParserDATE_UNDERSCORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(161)
				p.FreeFormText()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(164)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(165)
			p.Match(bbyCBLParserINSTALLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(166)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(167)
			p.FreeFormText()
		}
		{
			p.SetState(168)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(170)
			p.Match(bbyCBLParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(171)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(172)
			p.FreeFormText()
		}
		{
			p.SetState(173)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(175)
			p.Match(bbyCBLParserDATE_COMPILED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(176)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(177)
				p.Match(bbyCBLParserDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(178)
				p.FreeFormText()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(181)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(182)
			p.Match(bbyCBLParserBASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(183)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(184)
			p.FreeFormText()
		}
		{
			p.SetState(185)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(187)
			p.Match(bbyCBLParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(188)
			p.CopySource()
		}
		p.SetState(195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserREPLACING {
			{
				p.SetState(189)
				p.Match(bbyCBLParserREPLACING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(191)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == bbyCBLParserTRIPLE_EQUAL || _la == bbyCBLParserDOUBLE_EQUAL {
				{
					p.SetState(190)
					p.ReplacePair()
				}

				p.SetState(193)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserDOT {
			{
				p.SetState(197)
				p.Match(bbyCBLParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(200)
			p.Match(bbyCBLParserDESCRIPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(201)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(202)
			p.FreeFormText()
		}
		{
			p.SetState(203)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(205)
			p.SimpleId()
		}
		{
			p.SetState(206)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9218841179211693182) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&7696589520895) != 0) {
			{
				p.SetState(207)
				p.FreeFormText()
			}

		}
		{
			p.SetState(210)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFreeFormTextContext is an interface to support dynamic dispatch.
type IFreeFormTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleId() []ISimpleIdContext
	SimpleId(i int) ISimpleIdContext
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode
	AllNUMBER() []antlr.TerminalNode
	NUMBER(i int) antlr.TerminalNode
	AllFLOAT() []antlr.TerminalNode
	FLOAT(i int) antlr.TerminalNode
	AllLiteral() []ILiteralContext
	Literal(i int) ILiteralContext
	AllDATE() []antlr.TerminalNode
	DATE(i int) antlr.TerminalNode
	AllDATE_UNDERSCORE() []antlr.TerminalNode
	DATE_UNDERSCORE(i int) antlr.TerminalNode
	AllANY_DATE() []antlr.TerminalNode
	ANY_DATE(i int) antlr.TerminalNode
	AllANY_DATE_UNDERSCORE() []antlr.TerminalNode
	ANY_DATE_UNDERSCORE(i int) antlr.TerminalNode

	// IsFreeFormTextContext differentiates from other interfaces.
	IsFreeFormTextContext()
}

type FreeFormTextContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFreeFormTextContext() *FreeFormTextContext {
	var p = new(FreeFormTextContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_freeFormText
	return p
}

func InitEmptyFreeFormTextContext(p *FreeFormTextContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_freeFormText
}

func (*FreeFormTextContext) IsFreeFormTextContext() {}

func NewFreeFormTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FreeFormTextContext {
	var p = new(FreeFormTextContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_freeFormText

	return p
}

func (s *FreeFormTextContext) GetParser() antlr.Parser { return s.parser }

func (s *FreeFormTextContext) AllSimpleId() []ISimpleIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleIdContext); ok {
			len++
		}
	}

	tst := make([]ISimpleIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleIdContext); ok {
			tst[i] = t.(ISimpleIdContext)
			i++
		}
	}

	return tst
}

func (s *FreeFormTextContext) SimpleId(i int) ISimpleIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *FreeFormTextContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserSTRING)
}

func (s *FreeFormTextContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSTRING, i)
}

func (s *FreeFormTextContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserNUMBER)
}

func (s *FreeFormTextContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNUMBER, i)
}

func (s *FreeFormTextContext) AllFLOAT() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserFLOAT)
}

func (s *FreeFormTextContext) FLOAT(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserFLOAT, i)
}

func (s *FreeFormTextContext) AllLiteral() []ILiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralContext); ok {
			len++
		}
	}

	tst := make([]ILiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralContext); ok {
			tst[i] = t.(ILiteralContext)
			i++
		}
	}

	return tst
}

func (s *FreeFormTextContext) Literal(i int) ILiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *FreeFormTextContext) AllDATE() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserDATE)
}

func (s *FreeFormTextContext) DATE(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE, i)
}

func (s *FreeFormTextContext) AllDATE_UNDERSCORE() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserDATE_UNDERSCORE)
}

func (s *FreeFormTextContext) DATE_UNDERSCORE(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_UNDERSCORE, i)
}

func (s *FreeFormTextContext) AllANY_DATE() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserANY_DATE)
}

func (s *FreeFormTextContext) ANY_DATE(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE, i)
}

func (s *FreeFormTextContext) AllANY_DATE_UNDERSCORE() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserANY_DATE_UNDERSCORE)
}

func (s *FreeFormTextContext) ANY_DATE_UNDERSCORE(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE_UNDERSCORE, i)
}

func (s *FreeFormTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FreeFormTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FreeFormTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterFreeFormText(s)
	}
}

func (s *FreeFormTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitFreeFormText(s)
	}
}

func (s *FreeFormTextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitFreeFormText(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) FreeFormText() (localctx IFreeFormTextContext) {
	localctx = NewFreeFormTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, bbyCBLParserRULE_freeFormText)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9218841179211693182) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&7696589520895) != 0) {
		p.SetState(223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(214)
				p.SimpleId()
			}

		case 2:
			{
				p.SetState(215)
				p.Match(bbyCBLParserSTRING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(216)
				p.Match(bbyCBLParserNUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(217)
				p.Match(bbyCBLParserFLOAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(218)
				p.Literal()
			}

		case 6:
			{
				p.SetState(219)
				p.Match(bbyCBLParserDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 7:
			{
				p.SetState(220)
				p.Match(bbyCBLParserDATE_UNDERSCORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(221)
				p.Match(bbyCBLParserANY_DATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 9:
			{
				p.SetState(222)
				p.Match(bbyCBLParserANY_DATE_UNDERSCORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDivisionContext is an interface to support dynamic dispatch.
type IDataDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATA_DIVISION() antlr.TerminalNode
	AllDataEntry() []IDataEntryContext
	DataEntry(i int) IDataEntryContext
	AllDataCopyStmt() []IDataCopyStmtContext
	DataCopyStmt(i int) IDataCopyStmtContext

	// IsDataDivisionContext differentiates from other interfaces.
	IsDataDivisionContext()
}

type DataDivisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDivisionContext() *DataDivisionContext {
	var p = new(DataDivisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataDivision
	return p
}

func InitEmptyDataDivisionContext(p *DataDivisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataDivision
}

func (*DataDivisionContext) IsDataDivisionContext() {}

func NewDataDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDivisionContext {
	var p = new(DataDivisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_dataDivision

	return p
}

func (s *DataDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDivisionContext) DATA_DIVISION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATA_DIVISION, 0)
}

func (s *DataDivisionContext) AllDataEntry() []IDataEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataEntryContext); ok {
			len++
		}
	}

	tst := make([]IDataEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataEntryContext); ok {
			tst[i] = t.(IDataEntryContext)
			i++
		}
	}

	return tst
}

func (s *DataDivisionContext) DataEntry(i int) IDataEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataEntryContext)
}

func (s *DataDivisionContext) AllDataCopyStmt() []IDataCopyStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataCopyStmtContext); ok {
			len++
		}
	}

	tst := make([]IDataCopyStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataCopyStmtContext); ok {
			tst[i] = t.(IDataCopyStmtContext)
			i++
		}
	}

	return tst
}

func (s *DataDivisionContext) DataCopyStmt(i int) IDataCopyStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCopyStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCopyStmtContext)
}

func (s *DataDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDataDivision(s)
	}
}

func (s *DataDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDataDivision(s)
	}
}

func (s *DataDivisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitDataDivision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) DataDivision() (localctx IDataDivisionContext) {
	localctx = NewDataDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, bbyCBLParserRULE_dataDivision)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(227)
		p.Match(bbyCBLParserDATA_DIVISION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(232)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserNUMBER || _la == bbyCBLParserCOPY {
		p.SetState(230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case bbyCBLParserNUMBER:
			{
				p.SetState(228)
				p.DataEntry()
			}

		case bbyCBLParserCOPY:
			{
				p.SetState(229)
				p.DataCopyStmt()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(234)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataEntryContext is an interface to support dynamic dispatch.
type IDataEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LevelNumber() ILevelNumberContext
	Identifier() IIdentifierContext
	DOT() antlr.TerminalNode
	PictureClause() IPictureClauseContext
	LikeClause() ILikeClauseContext
	OccursClause() IOccursClauseContext

	// IsDataEntryContext differentiates from other interfaces.
	IsDataEntryContext()
}

type DataEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataEntryContext() *DataEntryContext {
	var p = new(DataEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataEntry
	return p
}

func InitEmptyDataEntryContext(p *DataEntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataEntry
}

func (*DataEntryContext) IsDataEntryContext() {}

func NewDataEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataEntryContext {
	var p = new(DataEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_dataEntry

	return p
}

func (s *DataEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *DataEntryContext) LevelNumber() ILevelNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelNumberContext)
}

func (s *DataEntryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataEntryContext) DOT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, 0)
}

func (s *DataEntryContext) PictureClause() IPictureClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPictureClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPictureClauseContext)
}

func (s *DataEntryContext) LikeClause() ILikeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikeClauseContext)
}

func (s *DataEntryContext) OccursClause() IOccursClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOccursClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOccursClauseContext)
}

func (s *DataEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDataEntry(s)
	}
}

func (s *DataEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDataEntry(s)
	}
}

func (s *DataEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitDataEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) DataEntry() (localctx IDataEntryContext) {
	localctx = NewDataEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, bbyCBLParserRULE_dataEntry)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(235)
		p.LevelNumber()
	}
	{
		p.SetState(236)
		p.Identifier()
	}
	p.SetState(239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserPICTURE:
		{
			p.SetState(237)
			p.PictureClause()
		}

	case bbyCBLParserLIKE:
		{
			p.SetState(238)
			p.LikeClause()
		}

	case bbyCBLParserOCCURS, bbyCBLParserDOT:

	default:
	}
	p.SetState(242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserOCCURS {
		{
			p.SetState(241)
			p.OccursClause()
		}

	}
	{
		p.SetState(244)
		p.Match(bbyCBLParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCopyStmtContext is an interface to support dynamic dispatch.
type IDataCopyStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COPY() antlr.TerminalNode
	CopySource() ICopySourceContext
	DOT() antlr.TerminalNode
	REPLACING() antlr.TerminalNode
	AllReplacePair() []IReplacePairContext
	ReplacePair(i int) IReplacePairContext

	// IsDataCopyStmtContext differentiates from other interfaces.
	IsDataCopyStmtContext()
}

type DataCopyStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCopyStmtContext() *DataCopyStmtContext {
	var p = new(DataCopyStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataCopyStmt
	return p
}

func InitEmptyDataCopyStmtContext(p *DataCopyStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataCopyStmt
}

func (*DataCopyStmtContext) IsDataCopyStmtContext() {}

func NewDataCopyStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCopyStmtContext {
	var p = new(DataCopyStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_dataCopyStmt

	return p
}

func (s *DataCopyStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCopyStmtContext) COPY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCOPY, 0)
}

func (s *DataCopyStmtContext) CopySource() ICopySourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopySourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopySourceContext)
}

func (s *DataCopyStmtContext) DOT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, 0)
}

func (s *DataCopyStmtContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREPLACING, 0)
}

func (s *DataCopyStmtContext) AllReplacePair() []IReplacePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplacePairContext); ok {
			len++
		}
	}

	tst := make([]IReplacePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplacePairContext); ok {
			tst[i] = t.(IReplacePairContext)
			i++
		}
	}

	return tst
}

func (s *DataCopyStmtContext) ReplacePair(i int) IReplacePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePairContext)
}

func (s *DataCopyStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCopyStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCopyStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDataCopyStmt(s)
	}
}

func (s *DataCopyStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDataCopyStmt(s)
	}
}

func (s *DataCopyStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitDataCopyStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) DataCopyStmt() (localctx IDataCopyStmtContext) {
	localctx = NewDataCopyStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, bbyCBLParserRULE_dataCopyStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(246)
		p.Match(bbyCBLParserCOPY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(247)
		p.CopySource()
	}
	p.SetState(254)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserREPLACING {
		{
			p.SetState(248)
			p.Match(bbyCBLParserREPLACING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == bbyCBLParserTRIPLE_EQUAL || _la == bbyCBLParserDOUBLE_EQUAL {
			{
				p.SetState(249)
				p.ReplacePair()
			}

			p.SetState(252)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(256)
		p.Match(bbyCBLParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILevelNumberContext is an interface to support dynamic dispatch.
type ILevelNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode

	// IsLevelNumberContext differentiates from other interfaces.
	IsLevelNumberContext()
}

type LevelNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelNumberContext() *LevelNumberContext {
	var p = new(LevelNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_levelNumber
	return p
}

func InitEmptyLevelNumberContext(p *LevelNumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_levelNumber
}

func (*LevelNumberContext) IsLevelNumberContext() {}

func NewLevelNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelNumberContext {
	var p = new(LevelNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_levelNumber

	return p
}

func (s *LevelNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelNumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNUMBER, 0)
}

func (s *LevelNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LevelNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLevelNumber(s)
	}
}

func (s *LevelNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLevelNumber(s)
	}
}

func (s *LevelNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitLevelNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) LevelNumber() (localctx ILevelNumberContext) {
	localctx = NewLevelNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, bbyCBLParserRULE_levelNumber)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(258)
		p.Match(bbyCBLParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPictureClauseContext is an interface to support dynamic dispatch.
type IPictureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PICTURE() antlr.TerminalNode
	PicturePattern() IPicturePatternContext
	IS() antlr.TerminalNode

	// IsPictureClauseContext differentiates from other interfaces.
	IsPictureClauseContext()
}

type PictureClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureClauseContext() *PictureClauseContext {
	var p = new(PictureClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_pictureClause
	return p
}

func InitEmptyPictureClauseContext(p *PictureClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_pictureClause
}

func (*PictureClauseContext) IsPictureClauseContext() {}

func NewPictureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureClauseContext {
	var p = new(PictureClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_pictureClause

	return p
}

func (s *PictureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPICTURE, 0)
}

func (s *PictureClauseContext) PicturePattern() IPicturePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPicturePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPicturePatternContext)
}

func (s *PictureClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserIS, 0)
}

func (s *PictureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterPictureClause(s)
	}
}

func (s *PictureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitPictureClause(s)
	}
}

func (s *PictureClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitPictureClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) PictureClause() (localctx IPictureClauseContext) {
	localctx = NewPictureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, bbyCBLParserRULE_pictureClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(260)
		p.Match(bbyCBLParserPICTURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserIS {
		{
			p.SetState(261)
			p.Match(bbyCBLParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(264)
		p.PicturePattern()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPicturePatternContext is an interface to support dynamic dispatch.
type IPicturePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPictureElement() []IPictureElementContext
	PictureElement(i int) IPictureElementContext

	// IsPicturePatternContext differentiates from other interfaces.
	IsPicturePatternContext()
}

type PicturePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPicturePatternContext() *PicturePatternContext {
	var p = new(PicturePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_picturePattern
	return p
}

func InitEmptyPicturePatternContext(p *PicturePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_picturePattern
}

func (*PicturePatternContext) IsPicturePatternContext() {}

func NewPicturePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PicturePatternContext {
	var p = new(PicturePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_picturePattern

	return p
}

func (s *PicturePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PicturePatternContext) AllPictureElement() []IPictureElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPictureElementContext); ok {
			len++
		}
	}

	tst := make([]IPictureElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPictureElementContext); ok {
			tst[i] = t.(IPictureElementContext)
			i++
		}
	}

	return tst
}

func (s *PicturePatternContext) PictureElement(i int) IPictureElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPictureElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPictureElementContext)
}

func (s *PicturePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PicturePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PicturePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterPicturePattern(s)
	}
}

func (s *PicturePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitPicturePattern(s)
	}
}

func (s *PicturePatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitPicturePattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) PicturePattern() (localctx IPicturePatternContext) {
	localctx = NewPicturePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, bbyCBLParserRULE_picturePattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7292) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&137452584961) != 0) {
		{
			p.SetState(266)
			p.PictureElement()
		}

		p.SetState(269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPictureElementContext is an interface to support dynamic dispatch.
type IPictureElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNUMBER() []antlr.TerminalNode
	NUMBER(i int) antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PROGRAM_ID() antlr.TerminalNode
	AUTHOR() antlr.TerminalNode
	DATE_WRITTEN() antlr.TerminalNode
	STOP() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATE_UNDERSCORE() antlr.TerminalNode
	ANY_DATE() antlr.TerminalNode
	ANY_DATE_UNDERSCORE() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsPictureElementContext differentiates from other interfaces.
	IsPictureElementContext()
}

type PictureElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureElementContext() *PictureElementContext {
	var p = new(PictureElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_pictureElement
	return p
}

func InitEmptyPictureElementContext(p *PictureElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_pictureElement
}

func (*PictureElementContext) IsPictureElementContext() {}

func NewPictureElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureElementContext {
	var p = new(PictureElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_pictureElement

	return p
}

func (s *PictureElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureElementContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserNUMBER)
}

func (s *PictureElementContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNUMBER, i)
}

func (s *PictureElementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserIDENTIFIER, 0)
}

func (s *PictureElementContext) PROGRAM_ID() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPROGRAM_ID, 0)
}

func (s *PictureElementContext) AUTHOR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserAUTHOR, 0)
}

func (s *PictureElementContext) DATE_WRITTEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_WRITTEN, 0)
}

func (s *PictureElementContext) STOP() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSTOP, 0)
}

func (s *PictureElementContext) DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE, 0)
}

func (s *PictureElementContext) DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_UNDERSCORE, 0)
}

func (s *PictureElementContext) ANY_DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE, 0)
}

func (s *PictureElementContext) ANY_DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE_UNDERSCORE, 0)
}

func (s *PictureElementContext) MINUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMINUS, 0)
}

func (s *PictureElementContext) PLUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPLUS, 0)
}

func (s *PictureElementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLPAREN, 0)
}

func (s *PictureElementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserRPAREN, 0)
}

func (s *PictureElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterPictureElement(s)
	}
}

func (s *PictureElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitPictureElement(s)
	}
}

func (s *PictureElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitPictureElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) PictureElement() (localctx IPictureElementContext) {
	localctx = NewPictureElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, bbyCBLParserRULE_pictureElement)
	var _la int

	p.SetState(280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserNUMBER, bbyCBLParserDATE, bbyCBLParserDATE_UNDERSCORE, bbyCBLParserANY_DATE, bbyCBLParserANY_DATE_UNDERSCORE, bbyCBLParserPROGRAM_ID, bbyCBLParserAUTHOR, bbyCBLParserDATE_WRITTEN, bbyCBLParserSTOP, bbyCBLParserPLUS, bbyCBLParserMINUS, bbyCBLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(271)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7292) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&137451536385) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(275)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(272)
				p.Match(bbyCBLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(273)
				p.Match(bbyCBLParserNUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(274)
				p.Match(bbyCBLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case bbyCBLParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(277)
			p.Match(bbyCBLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(278)
			_la = p.GetTokenStream().LA(1)

			if !(_la == bbyCBLParserNUMBER || _la == bbyCBLParserIDENTIFIER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(279)
			p.Match(bbyCBLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILikeClauseContext is an interface to support dynamic dispatch.
type ILikeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	AllIdentifierSegment() []IIdentifierSegmentContext
	IdentifierSegment(i int) IIdentifierSegmentContext
	AllOF() []antlr.TerminalNode
	OF(i int) antlr.TerminalNode

	// IsLikeClauseContext differentiates from other interfaces.
	IsLikeClauseContext()
}

type LikeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLikeClauseContext() *LikeClauseContext {
	var p = new(LikeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_likeClause
	return p
}

func InitEmptyLikeClauseContext(p *LikeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_likeClause
}

func (*LikeClauseContext) IsLikeClauseContext() {}

func NewLikeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeClauseContext {
	var p = new(LikeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_likeClause

	return p
}

func (s *LikeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeClauseContext) LIKE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLIKE, 0)
}

func (s *LikeClauseContext) AllIdentifierSegment() []IIdentifierSegmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierSegmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierSegmentContext); ok {
			tst[i] = t.(IIdentifierSegmentContext)
			i++
		}
	}

	return tst
}

func (s *LikeClauseContext) IdentifierSegment(i int) IIdentifierSegmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSegmentContext)
}

func (s *LikeClauseContext) AllOF() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserOF)
}

func (s *LikeClauseContext) OF(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOF, i)
}

func (s *LikeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLikeClause(s)
	}
}

func (s *LikeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLikeClause(s)
	}
}

func (s *LikeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitLikeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) LikeClause() (localctx ILikeClauseContext) {
	localctx = NewLikeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, bbyCBLParserRULE_likeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(282)
		p.Match(bbyCBLParserLIKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(283)
		p.IdentifierSegment()
	}
	p.SetState(288)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserOF {
		{
			p.SetState(284)
			p.Match(bbyCBLParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(285)
			p.IdentifierSegment()
		}

		p.SetState(290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOccursClauseContext is an interface to support dynamic dispatch.
type IOccursClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OCCURS() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	TIMES() antlr.TerminalNode

	// IsOccursClauseContext differentiates from other interfaces.
	IsOccursClauseContext()
}

type OccursClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOccursClauseContext() *OccursClauseContext {
	var p = new(OccursClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_occursClause
	return p
}

func InitEmptyOccursClauseContext(p *OccursClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_occursClause
}

func (*OccursClauseContext) IsOccursClauseContext() {}

func NewOccursClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OccursClauseContext {
	var p = new(OccursClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_occursClause

	return p
}

func (s *OccursClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OccursClauseContext) OCCURS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOCCURS, 0)
}

func (s *OccursClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNUMBER, 0)
}

func (s *OccursClauseContext) TIMES() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTIMES, 0)
}

func (s *OccursClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OccursClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OccursClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterOccursClause(s)
	}
}

func (s *OccursClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitOccursClause(s)
	}
}

func (s *OccursClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitOccursClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) OccursClause() (localctx IOccursClauseContext) {
	localctx = NewOccursClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, bbyCBLParserRULE_occursClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(291)
		p.Match(bbyCBLParserOCCURS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(292)
		p.Match(bbyCBLParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserTIMES {
		{
			p.SetState(293)
			p.Match(bbyCBLParserTIMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureDivisionContext is an interface to support dynamic dispatch.
type IProcedureDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE_DIVISION() antlr.TerminalNode
	DOT() antlr.TerminalNode
	USING() antlr.TerminalNode
	UsingClause() IUsingClauseContext
	AllParagraph() []IParagraphContext
	Paragraph(i int) IParagraphContext
	AllSentence() []ISentenceContext
	Sentence(i int) ISentenceContext

	// IsProcedureDivisionContext differentiates from other interfaces.
	IsProcedureDivisionContext()
}

type ProcedureDivisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionContext() *ProcedureDivisionContext {
	var p = new(ProcedureDivisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_procedureDivision
	return p
}

func InitEmptyProcedureDivisionContext(p *ProcedureDivisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_procedureDivision
}

func (*ProcedureDivisionContext) IsProcedureDivisionContext() {}

func NewProcedureDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionContext {
	var p = new(ProcedureDivisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_procedureDivision

	return p
}

func (s *ProcedureDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionContext) PROCEDURE_DIVISION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPROCEDURE_DIVISION, 0)
}

func (s *ProcedureDivisionContext) DOT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, 0)
}

func (s *ProcedureDivisionContext) USING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserUSING, 0)
}

func (s *ProcedureDivisionContext) UsingClause() IUsingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingClauseContext)
}

func (s *ProcedureDivisionContext) AllParagraph() []IParagraphContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParagraphContext); ok {
			len++
		}
	}

	tst := make([]IParagraphContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParagraphContext); ok {
			tst[i] = t.(IParagraphContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureDivisionContext) Paragraph(i int) IParagraphContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParagraphContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParagraphContext)
}

func (s *ProcedureDivisionContext) AllSentence() []ISentenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISentenceContext); ok {
			len++
		}
	}

	tst := make([]ISentenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISentenceContext); ok {
			tst[i] = t.(ISentenceContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureDivisionContext) Sentence(i int) ISentenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISentenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISentenceContext)
}

func (s *ProcedureDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterProcedureDivision(s)
	}
}

func (s *ProcedureDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitProcedureDivision(s)
	}
}

func (s *ProcedureDivisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitProcedureDivision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) ProcedureDivision() (localctx IProcedureDivisionContext) {
	localctx = NewProcedureDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, bbyCBLParserRULE_procedureDivision)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(296)
		p.Match(bbyCBLParserPROCEDURE_DIVISION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserUSING {
		{
			p.SetState(297)
			p.Match(bbyCBLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(298)
			p.UsingClause()
		}

	}
	{
		p.SetState(301)
		p.Match(bbyCBLParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9223344787428998264) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&6597077893119) != 0) {
		p.SetState(304)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(302)
				p.Paragraph()
			}

		case 2:
			{
				p.SetState(303)
				p.Sentence()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingClauseContext is an interface to support dynamic dispatch.
type IUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllREFERENCE() []antlr.TerminalNode
	REFERENCE(i int) antlr.TerminalNode
	AllVALUE() []antlr.TerminalNode
	VALUE(i int) antlr.TerminalNode
	AllCONTENT() []antlr.TerminalNode
	CONTENT(i int) antlr.TerminalNode

	// IsUsingClauseContext differentiates from other interfaces.
	IsUsingClauseContext()
}

type UsingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingClauseContext() *UsingClauseContext {
	var p = new(UsingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_usingClause
	return p
}

func InitEmptyUsingClauseContext(p *UsingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_usingClause
}

func (*UsingClauseContext) IsUsingClauseContext() {}

func NewUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingClauseContext {
	var p = new(UsingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_usingClause

	return p
}

func (s *UsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingClauseContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserBY)
}

func (s *UsingClauseContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, i)
}

func (s *UsingClauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *UsingClauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UsingClauseContext) AllREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserREFERENCE)
}

func (s *UsingClauseContext) REFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREFERENCE, i)
}

func (s *UsingClauseContext) AllVALUE() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserVALUE)
}

func (s *UsingClauseContext) VALUE(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserVALUE, i)
}

func (s *UsingClauseContext) AllCONTENT() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserCONTENT)
}

func (s *UsingClauseContext) CONTENT(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCONTENT, i)
}

func (s *UsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterUsingClause(s)
	}
}

func (s *UsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitUsingClause(s)
	}
}

func (s *UsingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitUsingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) UsingClause() (localctx IUsingClauseContext) {
	localctx = NewUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, bbyCBLParserRULE_usingClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == bbyCBLParserBY {
		{
			p.SetState(309)
			p.Match(bbyCBLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(310)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-30)) & ^0x3f) == 0 && ((int64(1)<<(_la-30))&562954248388609) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(311)
			p.expr(0)
		}

		p.SetState(314)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParagraphContext is an interface to support dynamic dispatch.
type IParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DOT() antlr.TerminalNode
	AllSentence() []ISentenceContext
	Sentence(i int) ISentenceContext

	// IsParagraphContext differentiates from other interfaces.
	IsParagraphContext()
}

type ParagraphContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphContext() *ParagraphContext {
	var p = new(ParagraphContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_paragraph
	return p
}

func InitEmptyParagraphContext(p *ParagraphContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_paragraph
}

func (*ParagraphContext) IsParagraphContext() {}

func NewParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphContext {
	var p = new(ParagraphContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_paragraph

	return p
}

func (s *ParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParagraphContext) DOT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, 0)
}

func (s *ParagraphContext) AllSentence() []ISentenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISentenceContext); ok {
			len++
		}
	}

	tst := make([]ISentenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISentenceContext); ok {
			tst[i] = t.(ISentenceContext)
			i++
		}
	}

	return tst
}

func (s *ParagraphContext) Sentence(i int) ISentenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISentenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISentenceContext)
}

func (s *ParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterParagraph(s)
	}
}

func (s *ParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitParagraph(s)
	}
}

func (s *ParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) Paragraph() (localctx IParagraphContext) {
	localctx = NewParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, bbyCBLParserRULE_paragraph)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(316)
		p.Identifier()
	}
	{
		p.SetState(317)
		p.Match(bbyCBLParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(318)
				p.Sentence()
			}

		}
		p.SetState(323)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISentenceContext is an interface to support dynamic dispatch.
type ISentenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsSentenceContext differentiates from other interfaces.
	IsSentenceContext()
}

type SentenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySentenceContext() *SentenceContext {
	var p = new(SentenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_sentence
	return p
}

func InitEmptySentenceContext(p *SentenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_sentence
}

func (*SentenceContext) IsSentenceContext() {}

func NewSentenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SentenceContext {
	var p = new(SentenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_sentence

	return p
}

func (s *SentenceContext) GetParser() antlr.Parser { return s.parser }

func (s *SentenceContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserDOT)
}

func (s *SentenceContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, i)
}

func (s *SentenceContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *SentenceContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SentenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SentenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SentenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSentence(s)
	}
}

func (s *SentenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSentence(s)
	}
}

func (s *SentenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitSentence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) Sentence() (localctx ISentenceContext) {
	localctx = NewSentenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, bbyCBLParserRULE_sentence)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1170199256724865024) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&16433) != 0) {
		{
			p.SetState(324)
			p.Statement()
		}

		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(329)
		p.Match(bbyCBLParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserDOT {
		{
			p.SetState(330)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AcceptStmt() IAcceptStmtContext
	AddStmt() IAddStmtContext
	SubtractStmt() ISubtractStmtContext
	MultiplyStmt() IMultiplyStmtContext
	DivideStmt() IDivideStmtContext
	MoveStmt() IMoveStmtContext
	DisplayStmt() IDisplayStmtContext
	EvaluateStmt() IEvaluateStmtContext
	IfStmt() IIfStmtContext
	LoopStmt() ILoopStmtContext
	PerformStmt() IPerformStmtContext
	NextSentenceStmt() INextSentenceStmtContext
	GotoStmt() IGotoStmtContext
	CallStmt() ICallStmtContext
	CopyStmt() ICopyStmtContext
	SignalStmt() ISignalStmtContext
	StopStmt() IStopStmtContext
	AlterStmt() IAlterStmtContext
	VaryingStmt() IVaryingStmtContext
	BASE() antlr.TerminalNode

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) AcceptStmt() IAcceptStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAcceptStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAcceptStmtContext)
}

func (s *StatementContext) AddStmt() IAddStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddStmtContext)
}

func (s *StatementContext) SubtractStmt() ISubtractStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractStmtContext)
}

func (s *StatementContext) MultiplyStmt() IMultiplyStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyStmtContext)
}

func (s *StatementContext) DivideStmt() IDivideStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDivideStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDivideStmtContext)
}

func (s *StatementContext) MoveStmt() IMoveStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMoveStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMoveStmtContext)
}

func (s *StatementContext) DisplayStmt() IDisplayStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayStmtContext)
}

func (s *StatementContext) EvaluateStmt() IEvaluateStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateStmtContext)
}

func (s *StatementContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *StatementContext) LoopStmt() ILoopStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStmtContext)
}

func (s *StatementContext) PerformStmt() IPerformStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformStmtContext)
}

func (s *StatementContext) NextSentenceStmt() INextSentenceStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INextSentenceStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INextSentenceStmtContext)
}

func (s *StatementContext) GotoStmt() IGotoStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStmtContext)
}

func (s *StatementContext) CallStmt() ICallStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallStmtContext)
}

func (s *StatementContext) CopyStmt() ICopyStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopyStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopyStmtContext)
}

func (s *StatementContext) SignalStmt() ISignalStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalStmtContext)
}

func (s *StatementContext) StopStmt() IStopStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopStmtContext)
}

func (s *StatementContext) AlterStmt() IAlterStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStmtContext)
}

func (s *StatementContext) VaryingStmt() IVaryingStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVaryingStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVaryingStmtContext)
}

func (s *StatementContext) BASE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBASE, 0)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, bbyCBLParserRULE_statement)
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserACCEPT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(336)
			p.AcceptStmt()
		}

	case bbyCBLParserADD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(337)
			p.AddStmt()
		}

	case bbyCBLParserSUBTRACT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(338)
			p.SubtractStmt()
		}

	case bbyCBLParserMULTIPLY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(339)
			p.MultiplyStmt()
		}

	case bbyCBLParserDIVIDE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(340)
			p.DivideStmt()
		}

	case bbyCBLParserMOVE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(341)
			p.MoveStmt()
		}

	case bbyCBLParserDISPLAY:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(342)
			p.DisplayStmt()
		}

	case bbyCBLParserEVALUATE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(343)
			p.EvaluateStmt()
		}

	case bbyCBLParserIF:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(344)
			p.IfStmt()
		}

	case bbyCBLParserLOOP:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(345)
			p.LoopStmt()
		}

	case bbyCBLParserPERFORM:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(346)
			p.PerformStmt()
		}

	case bbyCBLParserNEXT_SENTENCE, bbyCBLParserNEXT:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(347)
			p.NextSentenceStmt()
		}

	case bbyCBLParserGO:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(348)
			p.GotoStmt()
		}

	case bbyCBLParserCALL:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(349)
			p.CallStmt()
		}

	case bbyCBLParserCOPY:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(350)
			p.CopyStmt()
		}

	case bbyCBLParserSIGNAL:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(351)
			p.SignalStmt()
		}

	case bbyCBLParserSTOP:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(352)
			p.StopStmt()
		}

	case bbyCBLParserALTER:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(353)
			p.AlterStmt()
		}

	case bbyCBLParserVARYING:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(354)
			p.VaryingStmt()
		}

	case bbyCBLParserBASE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(355)
			p.Match(bbyCBLParserBASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyAll(ctx *IdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SingleContext struct {
	IdentifierContext
}

func NewSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleContext {
	var p = new(SingleContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *SingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *SingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSingle(s)
	}
}

func (s *SingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSingle(s)
	}
}

func (s *SingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

type QualifiedContext struct {
	IdentifierContext
}

func NewQualifiedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedContext {
	var p = new(QualifiedContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *QualifiedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedContext) AllSimpleId() []ISimpleIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleIdContext); ok {
			len++
		}
	}

	tst := make([]ISimpleIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleIdContext); ok {
			tst[i] = t.(ISimpleIdContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedContext) SimpleId(i int) ISimpleIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *QualifiedContext) AllOF() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserOF)
}

func (s *QualifiedContext) OF(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOF, i)
}

func (s *QualifiedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterQualified(s)
	}
}

func (s *QualifiedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitQualified(s)
	}
}

func (s *QualifiedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitQualified(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, bbyCBLParserRULE_identifier)
	var _la int

	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQualifiedContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(358)
			p.SimpleId()
		}
		p.SetState(361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == bbyCBLParserOF {
			{
				p.SetState(359)
				p.Match(bbyCBLParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(360)
				p.SimpleId()
			}

			p.SetState(363)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(365)
			p.SimpleId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleIdContext is an interface to support dynamic dispatch.
type ISimpleIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	DESCRIPTION() antlr.TerminalNode
	PROGRAM_ID() antlr.TerminalNode
	AUTHOR() antlr.TerminalNode
	DATE_WRITTEN() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATE_UNDERSCORE() antlr.TerminalNode
	ANY_DATE() antlr.TerminalNode
	ANY_DATE_UNDERSCORE() antlr.TerminalNode
	HIGH_VALUES() antlr.TerminalNode
	LOW_VALUES() antlr.TerminalNode
	SPACE() antlr.TerminalNode
	SPACES() antlr.TerminalNode
	BASE() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	END() antlr.TerminalNode
	ADD() antlr.TerminalNode
	MOVE() antlr.TerminalNode
	TO() antlr.TerminalNode
	THEN() antlr.TerminalNode
	INSTALLATION() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	DATE_COMPILED() antlr.TerminalNode
	OF() antlr.TerminalNode
	BY() antlr.TerminalNode
	COPY() antlr.TerminalNode
	VARYING() antlr.TerminalNode
	STOP() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	OFF() antlr.TerminalNode
	ON() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	PROCEED() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	CONTENT() antlr.TerminalNode
	OTHER() antlr.TerminalNode
	NOT() antlr.TerminalNode
	OR() antlr.TerminalNode
	AND() antlr.TerminalNode
	XOR() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	USING() antlr.TerminalNode
	WHILE() antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	INTO() antlr.TerminalNode
	THROUGH() antlr.TerminalNode
	GO() antlr.TerminalNode
	IF() antlr.TerminalNode
	LOOP() antlr.TerminalNode
	MULTIPLY() antlr.TerminalNode
	DIVIDE() antlr.TerminalNode
	SUBTRACT() antlr.TerminalNode
	CALL() antlr.TerminalNode
	ACCEPT() antlr.TerminalNode
	PERFORM() antlr.TerminalNode
	SIGNAL() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	EVALUATE() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	RUN() antlr.TerminalNode
	SIZE() antlr.TerminalNode
	DELIMITED() antlr.TerminalNode
	WITH() antlr.TerminalNode
	NO() antlr.TerminalNode
	ADVANCING() antlr.TerminalNode
	ALSO() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	SENTENCE() antlr.TerminalNode

	// IsSimpleIdContext differentiates from other interfaces.
	IsSimpleIdContext()
}

type SimpleIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdContext() *SimpleIdContext {
	var p = new(SimpleIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_simpleId
	return p
}

func InitEmptySimpleIdContext(p *SimpleIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_simpleId
}

func (*SimpleIdContext) IsSimpleIdContext() {}

func NewSimpleIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdContext {
	var p = new(SimpleIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_simpleId

	return p
}

func (s *SimpleIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserIDENTIFIER, 0)
}

func (s *SimpleIdContext) DESCRIPTION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDESCRIPTION, 0)
}

func (s *SimpleIdContext) PROGRAM_ID() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPROGRAM_ID, 0)
}

func (s *SimpleIdContext) AUTHOR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserAUTHOR, 0)
}

func (s *SimpleIdContext) DATE_WRITTEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_WRITTEN, 0)
}

func (s *SimpleIdContext) DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE, 0)
}

func (s *SimpleIdContext) DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_UNDERSCORE, 0)
}

func (s *SimpleIdContext) ANY_DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE, 0)
}

func (s *SimpleIdContext) ANY_DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE_UNDERSCORE, 0)
}

func (s *SimpleIdContext) HIGH_VALUES() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserHIGH_VALUES, 0)
}

func (s *SimpleIdContext) LOW_VALUES() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLOW_VALUES, 0)
}

func (s *SimpleIdContext) SPACE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSPACE, 0)
}

func (s *SimpleIdContext) SPACES() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSPACES, 0)
}

func (s *SimpleIdContext) BASE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBASE, 0)
}

func (s *SimpleIdContext) TRUE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTRUE, 0)
}

func (s *SimpleIdContext) FALSE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserFALSE, 0)
}

func (s *SimpleIdContext) END() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND, 0)
}

func (s *SimpleIdContext) ADD() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserADD, 0)
}

func (s *SimpleIdContext) MOVE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMOVE, 0)
}

func (s *SimpleIdContext) TO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, 0)
}

func (s *SimpleIdContext) THEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTHEN, 0)
}

func (s *SimpleIdContext) INSTALLATION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserINSTALLATION, 0)
}

func (s *SimpleIdContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSECURITY, 0)
}

func (s *SimpleIdContext) DATE_COMPILED() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_COMPILED, 0)
}

func (s *SimpleIdContext) OF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOF, 0)
}

func (s *SimpleIdContext) BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, 0)
}

func (s *SimpleIdContext) COPY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCOPY, 0)
}

func (s *SimpleIdContext) VARYING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserVARYING, 0)
}

func (s *SimpleIdContext) STOP() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSTOP, 0)
}

func (s *SimpleIdContext) LIKE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLIKE, 0)
}

func (s *SimpleIdContext) OFF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOFF, 0)
}

func (s *SimpleIdContext) ON() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserON, 0)
}

func (s *SimpleIdContext) ERROR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserERROR, 0)
}

func (s *SimpleIdContext) PROCEED() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPROCEED, 0)
}

func (s *SimpleIdContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREFERENCE, 0)
}

func (s *SimpleIdContext) VALUE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserVALUE, 0)
}

func (s *SimpleIdContext) CONTENT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCONTENT, 0)
}

func (s *SimpleIdContext) OTHER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOTHER, 0)
}

func (s *SimpleIdContext) NOT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNOT, 0)
}

func (s *SimpleIdContext) OR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOR, 0)
}

func (s *SimpleIdContext) AND() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserAND, 0)
}

func (s *SimpleIdContext) XOR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserXOR, 0)
}

func (s *SimpleIdContext) TIMES() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTIMES, 0)
}

func (s *SimpleIdContext) USING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserUSING, 0)
}

func (s *SimpleIdContext) WHILE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWHILE, 0)
}

func (s *SimpleIdContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserUNTIL, 0)
}

func (s *SimpleIdContext) INTO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserINTO, 0)
}

func (s *SimpleIdContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTHROUGH, 0)
}

func (s *SimpleIdContext) GO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserGO, 0)
}

func (s *SimpleIdContext) IF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserIF, 0)
}

func (s *SimpleIdContext) LOOP() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLOOP, 0)
}

func (s *SimpleIdContext) MULTIPLY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMULTIPLY, 0)
}

func (s *SimpleIdContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDIVIDE, 0)
}

func (s *SimpleIdContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSUBTRACT, 0)
}

func (s *SimpleIdContext) CALL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCALL, 0)
}

func (s *SimpleIdContext) ACCEPT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserACCEPT, 0)
}

func (s *SimpleIdContext) PERFORM() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPERFORM, 0)
}

func (s *SimpleIdContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSIGNAL, 0)
}

func (s *SimpleIdContext) ALTER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserALTER, 0)
}

func (s *SimpleIdContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEVALUATE, 0)
}

func (s *SimpleIdContext) WHEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWHEN, 0)
}

func (s *SimpleIdContext) RUN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserRUN, 0)
}

func (s *SimpleIdContext) SIZE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSIZE, 0)
}

func (s *SimpleIdContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDELIMITED, 0)
}

func (s *SimpleIdContext) WITH() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWITH, 0)
}

func (s *SimpleIdContext) NO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNO, 0)
}

func (s *SimpleIdContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserADVANCING, 0)
}

func (s *SimpleIdContext) ALSO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserALSO, 0)
}

func (s *SimpleIdContext) NEXT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNEXT, 0)
}

func (s *SimpleIdContext) SENTENCE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSENTENCE, 0)
}

func (s *SimpleIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSimpleId(s)
	}
}

func (s *SimpleIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSimpleId(s)
	}
}

func (s *SimpleIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitSimpleId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) SimpleId() (localctx ISimpleIdContext) {
	localctx = NewSimpleIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, bbyCBLParserRULE_simpleId)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9218841179211693176) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&6597077893119) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEvalSubjectContext is an interface to support dynamic dispatch.
type IEvalSubjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExprList() IExprListContext
	Condition() IConditionContext

	// IsEvalSubjectContext differentiates from other interfaces.
	IsEvalSubjectContext()
}

type EvalSubjectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvalSubjectContext() *EvalSubjectContext {
	var p = new(EvalSubjectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_evalSubject
	return p
}

func InitEmptyEvalSubjectContext(p *EvalSubjectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_evalSubject
}

func (*EvalSubjectContext) IsEvalSubjectContext() {}

func NewEvalSubjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvalSubjectContext {
	var p = new(EvalSubjectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_evalSubject

	return p
}

func (s *EvalSubjectContext) GetParser() antlr.Parser { return s.parser }

func (s *EvalSubjectContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *EvalSubjectContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *EvalSubjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvalSubjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvalSubjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterEvalSubject(s)
	}
}

func (s *EvalSubjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitEvalSubject(s)
	}
}

func (s *EvalSubjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitEvalSubject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) EvalSubject() (localctx IEvalSubjectContext) {
	localctx = NewEvalSubjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, bbyCBLParserRULE_evalSubject)
	p.SetState(372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(370)
			p.ExprList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(371)
			p.Condition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAcceptStmtContext is an interface to support dynamic dispatch.
type IAcceptStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCEPT() antlr.TerminalNode
	ExprList() IExprListContext

	// IsAcceptStmtContext differentiates from other interfaces.
	IsAcceptStmtContext()
}

type AcceptStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptStmtContext() *AcceptStmtContext {
	var p = new(AcceptStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_acceptStmt
	return p
}

func InitEmptyAcceptStmtContext(p *AcceptStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_acceptStmt
}

func (*AcceptStmtContext) IsAcceptStmtContext() {}

func NewAcceptStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptStmtContext {
	var p = new(AcceptStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_acceptStmt

	return p
}

func (s *AcceptStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptStmtContext) ACCEPT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserACCEPT, 0)
}

func (s *AcceptStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *AcceptStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterAcceptStmt(s)
	}
}

func (s *AcceptStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitAcceptStmt(s)
	}
}

func (s *AcceptStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitAcceptStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) AcceptStmt() (localctx IAcceptStmtContext) {
	localctx = NewAcceptStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, bbyCBLParserRULE_acceptStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(374)
		p.Match(bbyCBLParserACCEPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(375)
		p.ExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddStmtContext is an interface to support dynamic dispatch.
type IAddStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAddStmtContext differentiates from other interfaces.
	IsAddStmtContext()
}

type AddStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddStmtContext() *AddStmtContext {
	var p = new(AddStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_addStmt
	return p
}

func InitEmptyAddStmtContext(p *AddStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_addStmt
}

func (*AddStmtContext) IsAddStmtContext() {}

func NewAddStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddStmtContext {
	var p = new(AddStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_addStmt

	return p
}

func (s *AddStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AddStmtContext) CopyAll(ctx *AddStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AddStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AddToFormContext struct {
	AddStmtContext
}

func NewAddToFormContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddToFormContext {
	var p = new(AddToFormContext)

	InitEmptyAddStmtContext(&p.AddStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*AddStmtContext))

	return p
}

func (s *AddToFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToFormContext) ADD() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserADD, 0)
}

func (s *AddToFormContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *AddToFormContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *AddToFormContext) TO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, 0)
}

func (s *AddToFormContext) AllGivingClause() []IGivingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGivingClauseContext); ok {
			len++
		}
	}

	tst := make([]IGivingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGivingClauseContext); ok {
			tst[i] = t.(IGivingClauseContext)
			i++
		}
	}

	return tst
}

func (s *AddToFormContext) GivingClause(i int) IGivingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGivingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGivingClauseContext)
}

func (s *AddToFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterAddToForm(s)
	}
}

func (s *AddToFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitAddToForm(s)
	}
}

func (s *AddToFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitAddToForm(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddGivingFormContext struct {
	AddStmtContext
}

func NewAddGivingFormContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddGivingFormContext {
	var p = new(AddGivingFormContext)

	InitEmptyAddStmtContext(&p.AddStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*AddStmtContext))

	return p
}

func (s *AddGivingFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddGivingFormContext) ADD() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserADD, 0)
}

func (s *AddGivingFormContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *AddGivingFormContext) GivingClause() IGivingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGivingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGivingClauseContext)
}

func (s *AddGivingFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterAddGivingForm(s)
	}
}

func (s *AddGivingFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitAddGivingForm(s)
	}
}

func (s *AddGivingFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitAddGivingForm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) AddStmt() (localctx IAddStmtContext) {
	localctx = NewAddStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, bbyCBLParserRULE_addStmt)
	var _la int

	p.SetState(391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddToFormContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(377)
			p.Match(bbyCBLParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(378)
			p.ExprList()
		}
		{
			p.SetState(379)
			p.Match(bbyCBLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(380)
			p.ExprList()
		}
		p.SetState(384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == bbyCBLParserGIVING {
			{
				p.SetState(381)
				p.GivingClause()
			}

			p.SetState(386)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewAddGivingFormContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(387)
			p.Match(bbyCBLParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(388)
			p.ExprList()
		}
		{
			p.SetState(389)
			p.GivingClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStmtContext is an interface to support dynamic dispatch.
type IAlterStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllTO() []antlr.TerminalNode
	TO(i int) antlr.TerminalNode
	PROCEED() antlr.TerminalNode

	// IsAlterStmtContext differentiates from other interfaces.
	IsAlterStmtContext()
}

type AlterStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStmtContext() *AlterStmtContext {
	var p = new(AlterStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_alterStmt
	return p
}

func InitEmptyAlterStmtContext(p *AlterStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_alterStmt
}

func (*AlterStmtContext) IsAlterStmtContext() {}

func NewAlterStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStmtContext {
	var p = new(AlterStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_alterStmt

	return p
}

func (s *AlterStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserALTER, 0)
}

func (s *AlterStmtContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterStmtContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterStmtContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserTO)
}

func (s *AlterStmtContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, i)
}

func (s *AlterStmtContext) PROCEED() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPROCEED, 0)
}

func (s *AlterStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterAlterStmt(s)
	}
}

func (s *AlterStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitAlterStmt(s)
	}
}

func (s *AlterStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitAlterStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) AlterStmt() (localctx IAlterStmtContext) {
	localctx = NewAlterStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, bbyCBLParserRULE_alterStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(393)
		p.Match(bbyCBLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(394)
		p.Identifier()
	}
	{
		p.SetState(395)
		p.Match(bbyCBLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(396)
		p.Match(bbyCBLParserPROCEED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(397)
		p.Match(bbyCBLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(398)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallStmtContext is an interface to support dynamic dispatch.
type ICallStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALL() antlr.TerminalNode
	Expr() IExprContext
	USING() antlr.TerminalNode
	UsingClause() IUsingClauseContext

	// IsCallStmtContext differentiates from other interfaces.
	IsCallStmtContext()
}

type CallStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStmtContext() *CallStmtContext {
	var p = new(CallStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_callStmt
	return p
}

func InitEmptyCallStmtContext(p *CallStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_callStmt
}

func (*CallStmtContext) IsCallStmtContext() {}

func NewCallStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStmtContext {
	var p = new(CallStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_callStmt

	return p
}

func (s *CallStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStmtContext) CALL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCALL, 0)
}

func (s *CallStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CallStmtContext) USING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserUSING, 0)
}

func (s *CallStmtContext) UsingClause() IUsingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingClauseContext)
}

func (s *CallStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterCallStmt(s)
	}
}

func (s *CallStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitCallStmt(s)
	}
}

func (s *CallStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitCallStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) CallStmt() (localctx ICallStmtContext) {
	localctx = NewCallStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, bbyCBLParserRULE_callStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(400)
		p.Match(bbyCBLParserCALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(401)
		p.expr(0)
	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserUSING {
		{
			p.SetState(402)
			p.Match(bbyCBLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(403)
			p.UsingClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopySourceContext is an interface to support dynamic dispatch.
type ICopySourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	SimpleId() ISimpleIdContext

	// IsCopySourceContext differentiates from other interfaces.
	IsCopySourceContext()
}

type CopySourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopySourceContext() *CopySourceContext {
	var p = new(CopySourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_copySource
	return p
}

func InitEmptyCopySourceContext(p *CopySourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_copySource
}

func (*CopySourceContext) IsCopySourceContext() {}

func NewCopySourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CopySourceContext {
	var p = new(CopySourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_copySource

	return p
}

func (s *CopySourceContext) GetParser() antlr.Parser { return s.parser }

func (s *CopySourceContext) STRING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSTRING, 0)
}

func (s *CopySourceContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *CopySourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopySourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CopySourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterCopySource(s)
	}
}

func (s *CopySourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitCopySource(s)
	}
}

func (s *CopySourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitCopySource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) CopySource() (localctx ICopySourceContext) {
	localctx = NewCopySourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, bbyCBLParserRULE_copySource)
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(406)
			p.Match(bbyCBLParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bbyCBLParserDATE, bbyCBLParserDATE_UNDERSCORE, bbyCBLParserANY_DATE, bbyCBLParserANY_DATE_UNDERSCORE, bbyCBLParserPROGRAM_ID, bbyCBLParserAUTHOR, bbyCBLParserDATE_WRITTEN, bbyCBLParserINSTALLATION, bbyCBLParserSECURITY, bbyCBLParserDATE_COMPILED, bbyCBLParserBASE, bbyCBLParserCOPY, bbyCBLParserDESCRIPTION, bbyCBLParserLIKE, bbyCBLParserACCEPT, bbyCBLParserADD, bbyCBLParserALSO, bbyCBLParserALTER, bbyCBLParserAND, bbyCBLParserBY, bbyCBLParserCALL, bbyCBLParserCONTENT, bbyCBLParserDELIMITED, bbyCBLParserDIVIDE, bbyCBLParserEND, bbyCBLParserOFF, bbyCBLParserERROR, bbyCBLParserEVALUATE, bbyCBLParserFALSE, bbyCBLParserGO, bbyCBLParserIF, bbyCBLParserINTO, bbyCBLParserLOOP, bbyCBLParserLOW_VALUES, bbyCBLParserMOVE, bbyCBLParserMULTIPLY, bbyCBLParserNEXT, bbyCBLParserSENTENCE, bbyCBLParserNOT, bbyCBLParserOF, bbyCBLParserON, bbyCBLParserOR, bbyCBLParserOTHER, bbyCBLParserPERFORM, bbyCBLParserPROCEED, bbyCBLParserREFERENCE, bbyCBLParserRUN, bbyCBLParserSIGNAL, bbyCBLParserSIZE, bbyCBLParserSPACE, bbyCBLParserSPACES, bbyCBLParserSTOP, bbyCBLParserSUBTRACT, bbyCBLParserTHEN, bbyCBLParserTHROUGH, bbyCBLParserTIMES, bbyCBLParserTO, bbyCBLParserTRUE, bbyCBLParserUNTIL, bbyCBLParserUSING, bbyCBLParserVALUE, bbyCBLParserVARYING, bbyCBLParserWHEN, bbyCBLParserWHILE, bbyCBLParserWITH, bbyCBLParserNO, bbyCBLParserADVANCING, bbyCBLParserXOR, bbyCBLParserHIGH_VALUES, bbyCBLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(407)
			p.SimpleId()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopyStmtContext is an interface to support dynamic dispatch.
type ICopyStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COPY() antlr.TerminalNode
	CopySource() ICopySourceContext
	REPLACING() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllReplacePair() []IReplacePairContext
	ReplacePair(i int) IReplacePairContext

	// IsCopyStmtContext differentiates from other interfaces.
	IsCopyStmtContext()
}

type CopyStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopyStmtContext() *CopyStmtContext {
	var p = new(CopyStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_copyStmt
	return p
}

func InitEmptyCopyStmtContext(p *CopyStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_copyStmt
}

func (*CopyStmtContext) IsCopyStmtContext() {}

func NewCopyStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CopyStmtContext {
	var p = new(CopyStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_copyStmt

	return p
}

func (s *CopyStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CopyStmtContext) COPY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCOPY, 0)
}

func (s *CopyStmtContext) CopySource() ICopySourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopySourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopySourceContext)
}

func (s *CopyStmtContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREPLACING, 0)
}

func (s *CopyStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CopyStmtContext) AllReplacePair() []IReplacePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplacePairContext); ok {
			len++
		}
	}

	tst := make([]IReplacePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplacePairContext); ok {
			tst[i] = t.(IReplacePairContext)
			i++
		}
	}

	return tst
}

func (s *CopyStmtContext) ReplacePair(i int) IReplacePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePairContext)
}

func (s *CopyStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CopyStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterCopyStmt(s)
	}
}

func (s *CopyStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitCopyStmt(s)
	}
}

func (s *CopyStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitCopyStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) CopyStmt() (localctx ICopyStmtContext) {
	localctx = NewCopyStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, bbyCBLParserRULE_copyStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(410)
		p.Match(bbyCBLParserCOPY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(411)
		p.CopySource()
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserREPLACING {
		{
			p.SetState(412)
			p.Match(bbyCBLParserREPLACING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == bbyCBLParserTRIPLE_EQUAL || _la == bbyCBLParserDOUBLE_EQUAL {
			{
				p.SetState(413)
				p.ReplacePair()
			}

			p.SetState(416)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(421)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(420)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplacePairContext is an interface to support dynamic dispatch.
type IReplacePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllReplaceBlock() []IReplaceBlockContext
	ReplaceBlock(i int) IReplaceBlockContext
	BY() antlr.TerminalNode

	// IsReplacePairContext differentiates from other interfaces.
	IsReplacePairContext()
}

type ReplacePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplacePairContext() *ReplacePairContext {
	var p = new(ReplacePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_replacePair
	return p
}

func InitEmptyReplacePairContext(p *ReplacePairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_replacePair
}

func (*ReplacePairContext) IsReplacePairContext() {}

func NewReplacePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplacePairContext {
	var p = new(ReplacePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_replacePair

	return p
}

func (s *ReplacePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplacePairContext) AllReplaceBlock() []IReplaceBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplaceBlockContext); ok {
			len++
		}
	}

	tst := make([]IReplaceBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplaceBlockContext); ok {
			tst[i] = t.(IReplaceBlockContext)
			i++
		}
	}

	return tst
}

func (s *ReplacePairContext) ReplaceBlock(i int) IReplaceBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceBlockContext)
}

func (s *ReplacePairContext) BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, 0)
}

func (s *ReplacePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplacePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterReplacePair(s)
	}
}

func (s *ReplacePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitReplacePair(s)
	}
}

func (s *ReplacePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitReplacePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) ReplacePair() (localctx IReplacePairContext) {
	localctx = NewReplacePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, bbyCBLParserRULE_replacePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(423)
		p.ReplaceBlock()
	}
	{
		p.SetState(424)
		p.Match(bbyCBLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(425)
		p.ReplaceBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceBlockContext is an interface to support dynamic dispatch.
type IReplaceBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEqualDelim() []IEqualDelimContext
	EqualDelim(i int) IEqualDelimContext

	// IsReplaceBlockContext differentiates from other interfaces.
	IsReplaceBlockContext()
}

type ReplaceBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplaceBlockContext() *ReplaceBlockContext {
	var p = new(ReplaceBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_replaceBlock
	return p
}

func InitEmptyReplaceBlockContext(p *ReplaceBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_replaceBlock
}

func (*ReplaceBlockContext) IsReplaceBlockContext() {}

func NewReplaceBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceBlockContext {
	var p = new(ReplaceBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_replaceBlock

	return p
}

func (s *ReplaceBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceBlockContext) AllEqualDelim() []IEqualDelimContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEqualDelimContext); ok {
			len++
		}
	}

	tst := make([]IEqualDelimContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEqualDelimContext); ok {
			tst[i] = t.(IEqualDelimContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceBlockContext) EqualDelim(i int) IEqualDelimContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualDelimContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualDelimContext)
}

func (s *ReplaceBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterReplaceBlock(s)
	}
}

func (s *ReplaceBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitReplaceBlock(s)
	}
}

func (s *ReplaceBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitReplaceBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) ReplaceBlock() (localctx IReplaceBlockContext) {
	localctx = NewReplaceBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, bbyCBLParserRULE_replaceBlock)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(427)
		p.EqualDelim()
	}
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1 + 1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1 + 1:
			p.SetState(428)
			p.MatchWildcard()

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(433)
		p.EqualDelim()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualDelimContext is an interface to support dynamic dispatch.
type IEqualDelimContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_EQUAL() antlr.TerminalNode
	DOUBLE_EQUAL() antlr.TerminalNode

	// IsEqualDelimContext differentiates from other interfaces.
	IsEqualDelimContext()
}

type EqualDelimContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualDelimContext() *EqualDelimContext {
	var p = new(EqualDelimContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_equalDelim
	return p
}

func InitEmptyEqualDelimContext(p *EqualDelimContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_equalDelim
}

func (*EqualDelimContext) IsEqualDelimContext() {}

func NewEqualDelimContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualDelimContext {
	var p = new(EqualDelimContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_equalDelim

	return p
}

func (s *EqualDelimContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualDelimContext) TRIPLE_EQUAL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTRIPLE_EQUAL, 0)
}

func (s *EqualDelimContext) DOUBLE_EQUAL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOUBLE_EQUAL, 0)
}

func (s *EqualDelimContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualDelimContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualDelimContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterEqualDelim(s)
	}
}

func (s *EqualDelimContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitEqualDelim(s)
	}
}

func (s *EqualDelimContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitEqualDelim(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) EqualDelim() (localctx IEqualDelimContext) {
	localctx = NewEqualDelimContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, bbyCBLParserRULE_equalDelim)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(435)
		_la = p.GetTokenStream().LA(1)

		if !(_la == bbyCBLParserTRIPLE_EQUAL || _la == bbyCBLParserDOUBLE_EQUAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisplayItemContext is an interface to support dynamic dispatch.
type IDisplayItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	DelimiterSpec() IDelimiterSpecContext

	// IsDisplayItemContext differentiates from other interfaces.
	IsDisplayItemContext()
}

type DisplayItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayItemContext() *DisplayItemContext {
	var p = new(DisplayItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_displayItem
	return p
}

func InitEmptyDisplayItemContext(p *DisplayItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_displayItem
}

func (*DisplayItemContext) IsDisplayItemContext() {}

func NewDisplayItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayItemContext {
	var p = new(DisplayItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_displayItem

	return p
}

func (s *DisplayItemContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayItemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DisplayItemContext) DelimiterSpec() IDelimiterSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelimiterSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelimiterSpecContext)
}

func (s *DisplayItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDisplayItem(s)
	}
}

func (s *DisplayItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDisplayItem(s)
	}
}

func (s *DisplayItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitDisplayItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) DisplayItem() (localctx IDisplayItemContext) {
	localctx = NewDisplayItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, bbyCBLParserRULE_displayItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(437)
		p.expr(0)
	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(438)
			p.DelimiterSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelimiterSpecContext is an interface to support dynamic dispatch.
type IDelimiterSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELIMITED_BY() antlr.TerminalNode
	ValueSpec() IValueSpecContext
	DELIMITED() antlr.TerminalNode
	BY() antlr.TerminalNode

	// IsDelimiterSpecContext differentiates from other interfaces.
	IsDelimiterSpecContext()
}

type DelimiterSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelimiterSpecContext() *DelimiterSpecContext {
	var p = new(DelimiterSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_delimiterSpec
	return p
}

func InitEmptyDelimiterSpecContext(p *DelimiterSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_delimiterSpec
}

func (*DelimiterSpecContext) IsDelimiterSpecContext() {}

func NewDelimiterSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelimiterSpecContext {
	var p = new(DelimiterSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_delimiterSpec

	return p
}

func (s *DelimiterSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *DelimiterSpecContext) DELIMITED_BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDELIMITED_BY, 0)
}

func (s *DelimiterSpecContext) ValueSpec() IValueSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueSpecContext)
}

func (s *DelimiterSpecContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDELIMITED, 0)
}

func (s *DelimiterSpecContext) BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, 0)
}

func (s *DelimiterSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelimiterSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelimiterSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDelimiterSpec(s)
	}
}

func (s *DelimiterSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDelimiterSpec(s)
	}
}

func (s *DelimiterSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitDelimiterSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) DelimiterSpec() (localctx IDelimiterSpecContext) {
	localctx = NewDelimiterSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, bbyCBLParserRULE_delimiterSpec)
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserDELIMITED_BY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(441)
			p.Match(bbyCBLParserDELIMITED_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(442)
			p.ValueSpec()
		}

	case bbyCBLParserDELIMITED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(443)
			p.Match(bbyCBLParserDELIMITED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(444)
			p.Match(bbyCBLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(445)
			p.ValueSpec()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueSpecContext is an interface to support dynamic dispatch.
type IValueSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	SIZE() antlr.TerminalNode
	SPACE() antlr.TerminalNode

	// IsValueSpecContext differentiates from other interfaces.
	IsValueSpecContext()
}

type ValueSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueSpecContext() *ValueSpecContext {
	var p = new(ValueSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_valueSpec
	return p
}

func InitEmptyValueSpecContext(p *ValueSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_valueSpec
}

func (*ValueSpecContext) IsValueSpecContext() {}

func NewValueSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueSpecContext {
	var p = new(ValueSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_valueSpec

	return p
}

func (s *ValueSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueSpecContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ValueSpecContext) SIZE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSIZE, 0)
}

func (s *ValueSpecContext) SPACE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSPACE, 0)
}

func (s *ValueSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterValueSpec(s)
	}
}

func (s *ValueSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitValueSpec(s)
	}
}

func (s *ValueSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitValueSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) ValueSpec() (localctx IValueSpecContext) {
	localctx = NewValueSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, bbyCBLParserRULE_valueSpec)
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(448)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(449)
			p.Match(bbyCBLParserSIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(450)
			p.Match(bbyCBLParserSPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisplayStmtContext is an interface to support dynamic dispatch.
type IDisplayStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISPLAY() antlr.TerminalNode
	AllDisplayItem() []IDisplayItemContext
	DisplayItem(i int) IDisplayItemContext
	WithNoAdvancingClause() IWithNoAdvancingClauseContext

	// IsDisplayStmtContext differentiates from other interfaces.
	IsDisplayStmtContext()
}

type DisplayStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayStmtContext() *DisplayStmtContext {
	var p = new(DisplayStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_displayStmt
	return p
}

func InitEmptyDisplayStmtContext(p *DisplayStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_displayStmt
}

func (*DisplayStmtContext) IsDisplayStmtContext() {}

func NewDisplayStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayStmtContext {
	var p = new(DisplayStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_displayStmt

	return p
}

func (s *DisplayStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayStmtContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDISPLAY, 0)
}

func (s *DisplayStmtContext) AllDisplayItem() []IDisplayItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDisplayItemContext); ok {
			len++
		}
	}

	tst := make([]IDisplayItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDisplayItemContext); ok {
			tst[i] = t.(IDisplayItemContext)
			i++
		}
	}

	return tst
}

func (s *DisplayStmtContext) DisplayItem(i int) IDisplayItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayItemContext)
}

func (s *DisplayStmtContext) WithNoAdvancingClause() IWithNoAdvancingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithNoAdvancingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithNoAdvancingClauseContext)
}

func (s *DisplayStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDisplayStmt(s)
	}
}

func (s *DisplayStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDisplayStmt(s)
	}
}

func (s *DisplayStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitDisplayStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) DisplayStmt() (localctx IDisplayStmtContext) {
	localctx = NewDisplayStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, bbyCBLParserRULE_displayStmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.Match(bbyCBLParserDISPLAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(454)
				p.DisplayItem()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(459)
			p.WithNoAdvancingClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(462)
				p.DisplayItem()
			}

		}
		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithNoAdvancingClauseContext is an interface to support dynamic dispatch.
type IWithNoAdvancingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	NO() antlr.TerminalNode
	ADVANCING() antlr.TerminalNode
	WITH_NO_ADVANCING() antlr.TerminalNode

	// IsWithNoAdvancingClauseContext differentiates from other interfaces.
	IsWithNoAdvancingClauseContext()
}

type WithNoAdvancingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithNoAdvancingClauseContext() *WithNoAdvancingClauseContext {
	var p = new(WithNoAdvancingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_withNoAdvancingClause
	return p
}

func InitEmptyWithNoAdvancingClauseContext(p *WithNoAdvancingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_withNoAdvancingClause
}

func (*WithNoAdvancingClauseContext) IsWithNoAdvancingClauseContext() {}

func NewWithNoAdvancingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithNoAdvancingClauseContext {
	var p = new(WithNoAdvancingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_withNoAdvancingClause

	return p
}

func (s *WithNoAdvancingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithNoAdvancingClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWITH, 0)
}

func (s *WithNoAdvancingClauseContext) NO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNO, 0)
}

func (s *WithNoAdvancingClauseContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserADVANCING, 0)
}

func (s *WithNoAdvancingClauseContext) WITH_NO_ADVANCING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWITH_NO_ADVANCING, 0)
}

func (s *WithNoAdvancingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithNoAdvancingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithNoAdvancingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterWithNoAdvancingClause(s)
	}
}

func (s *WithNoAdvancingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitWithNoAdvancingClause(s)
	}
}

func (s *WithNoAdvancingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitWithNoAdvancingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) WithNoAdvancingClause() (localctx IWithNoAdvancingClauseContext) {
	localctx = NewWithNoAdvancingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, bbyCBLParserRULE_withNoAdvancingClause)
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(468)
			p.Match(bbyCBLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(469)
			p.Match(bbyCBLParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(470)
			p.Match(bbyCBLParserADVANCING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bbyCBLParserWITH_NO_ADVANCING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(471)
			p.Match(bbyCBLParserWITH_NO_ADVANCING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDivideStmtContext is an interface to support dynamic dispatch.
type IDivideStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDivideStmtContext differentiates from other interfaces.
	IsDivideStmtContext()
}

type DivideStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideStmtContext() *DivideStmtContext {
	var p = new(DivideStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_divideStmt
	return p
}

func InitEmptyDivideStmtContext(p *DivideStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_divideStmt
}

func (*DivideStmtContext) IsDivideStmtContext() {}

func NewDivideStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideStmtContext {
	var p = new(DivideStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_divideStmt

	return p
}

func (s *DivideStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideStmtContext) CopyAll(ctx *DivideStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DivideStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DivideByFormContext struct {
	DivideStmtContext
}

func NewDivideByFormContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DivideByFormContext {
	var p = new(DivideByFormContext)

	InitEmptyDivideStmtContext(&p.DivideStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*DivideStmtContext))

	return p
}

func (s *DivideByFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideByFormContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDIVIDE, 0)
}

func (s *DivideByFormContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *DivideByFormContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *DivideByFormContext) BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, 0)
}

func (s *DivideByFormContext) AllGivingClause() []IGivingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGivingClauseContext); ok {
			len++
		}
	}

	tst := make([]IGivingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGivingClauseContext); ok {
			tst[i] = t.(IGivingClauseContext)
			i++
		}
	}

	return tst
}

func (s *DivideByFormContext) GivingClause(i int) IGivingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGivingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGivingClauseContext)
}

func (s *DivideByFormContext) REMAINDER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREMAINDER, 0)
}

func (s *DivideByFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDivideByForm(s)
	}
}

func (s *DivideByFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDivideByForm(s)
	}
}

func (s *DivideByFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitDivideByForm(s)

	default:
		return t.VisitChildren(s)
	}
}

type DivideIntoFormContext struct {
	DivideStmtContext
}

func NewDivideIntoFormContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DivideIntoFormContext {
	var p = new(DivideIntoFormContext)

	InitEmptyDivideStmtContext(&p.DivideStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*DivideStmtContext))

	return p
}

func (s *DivideIntoFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideIntoFormContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDIVIDE, 0)
}

func (s *DivideIntoFormContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *DivideIntoFormContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *DivideIntoFormContext) INTO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserINTO, 0)
}

func (s *DivideIntoFormContext) AllGivingClause() []IGivingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGivingClauseContext); ok {
			len++
		}
	}

	tst := make([]IGivingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGivingClauseContext); ok {
			tst[i] = t.(IGivingClauseContext)
			i++
		}
	}

	return tst
}

func (s *DivideIntoFormContext) GivingClause(i int) IGivingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGivingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGivingClauseContext)
}

func (s *DivideIntoFormContext) REMAINDER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREMAINDER, 0)
}

func (s *DivideIntoFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDivideIntoForm(s)
	}
}

func (s *DivideIntoFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDivideIntoForm(s)
	}
}

func (s *DivideIntoFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitDivideIntoForm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) DivideStmt() (localctx IDivideStmtContext) {
	localctx = NewDivideStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, bbyCBLParserRULE_divideStmt)
	var _la int

	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDivideIntoFormContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(474)
			p.Match(bbyCBLParserDIVIDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(475)
			p.ExprList()
		}
		{
			p.SetState(476)
			p.Match(bbyCBLParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(477)
			p.ExprList()
		}
		p.SetState(481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == bbyCBLParserGIVING {
			{
				p.SetState(478)
				p.GivingClause()
			}

			p.SetState(483)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(486)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserREMAINDER {
			{
				p.SetState(484)
				p.Match(bbyCBLParserREMAINDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(485)
				p.ExprList()
			}

		}

	case 2:
		localctx = NewDivideByFormContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(488)
			p.Match(bbyCBLParserDIVIDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(489)
			p.ExprList()
		}
		{
			p.SetState(490)
			p.Match(bbyCBLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(491)
			p.ExprList()
		}
		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == bbyCBLParserGIVING {
			{
				p.SetState(492)
				p.GivingClause()
			}

			p.SetState(497)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserREMAINDER {
			{
				p.SetState(498)
				p.Match(bbyCBLParserREMAINDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(499)
				p.ExprList()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEvaluateStmtContext is an interface to support dynamic dispatch.
type IEvaluateStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVALUATE() antlr.TerminalNode
	END_EVALUATE() antlr.TerminalNode
	END() antlr.TerminalNode
	AllEvalSubject() []IEvalSubjectContext
	EvalSubject(i int) IEvalSubjectContext
	AllALSO() []antlr.TerminalNode
	ALSO(i int) antlr.TerminalNode
	AllWhenClause() []IWhenClauseContext
	WhenClause(i int) IWhenClauseContext
	Identifier() IIdentifierContext

	// IsEvaluateStmtContext differentiates from other interfaces.
	IsEvaluateStmtContext()
}

type EvaluateStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateStmtContext() *EvaluateStmtContext {
	var p = new(EvaluateStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_evaluateStmt
	return p
}

func InitEmptyEvaluateStmtContext(p *EvaluateStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_evaluateStmt
}

func (*EvaluateStmtContext) IsEvaluateStmtContext() {}

func NewEvaluateStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateStmtContext {
	var p = new(EvaluateStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_evaluateStmt

	return p
}

func (s *EvaluateStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateStmtContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEVALUATE, 0)
}

func (s *EvaluateStmtContext) END_EVALUATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND_EVALUATE, 0)
}

func (s *EvaluateStmtContext) END() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND, 0)
}

func (s *EvaluateStmtContext) AllEvalSubject() []IEvalSubjectContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEvalSubjectContext); ok {
			len++
		}
	}

	tst := make([]IEvalSubjectContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEvalSubjectContext); ok {
			tst[i] = t.(IEvalSubjectContext)
			i++
		}
	}

	return tst
}

func (s *EvaluateStmtContext) EvalSubject(i int) IEvalSubjectContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvalSubjectContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvalSubjectContext)
}

func (s *EvaluateStmtContext) AllALSO() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserALSO)
}

func (s *EvaluateStmtContext) ALSO(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserALSO, i)
}

func (s *EvaluateStmtContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *EvaluateStmtContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *EvaluateStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EvaluateStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterEvaluateStmt(s)
	}
}

func (s *EvaluateStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitEvaluateStmt(s)
	}
}

func (s *EvaluateStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitEvaluateStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) EvaluateStmt() (localctx IEvaluateStmtContext) {
	localctx = NewEvaluateStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, bbyCBLParserRULE_evaluateStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(504)
		p.Match(bbyCBLParserEVALUATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(506)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(505)
			p.EvalSubject()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserALSO {
		{
			p.SetState(508)
			p.Match(bbyCBLParserALSO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(509)
			p.EvalSubject()
		}

		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == bbyCBLParserWHEN {
		{
			p.SetState(515)
			p.WhenClause()
		}

		p.SetState(518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserEND_EVALUATE:
		{
			p.SetState(520)
			p.Match(bbyCBLParserEND_EVALUATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bbyCBLParserEND:
		{
			p.SetState(521)
			p.Match(bbyCBLParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(523)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(522)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGivingClauseContext is an interface to support dynamic dispatch.
type IGivingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GIVING() antlr.TerminalNode
	ExprList() IExprListContext

	// IsGivingClauseContext differentiates from other interfaces.
	IsGivingClauseContext()
}

type GivingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGivingClauseContext() *GivingClauseContext {
	var p = new(GivingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_givingClause
	return p
}

func InitEmptyGivingClauseContext(p *GivingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_givingClause
}

func (*GivingClauseContext) IsGivingClauseContext() {}

func NewGivingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GivingClauseContext {
	var p = new(GivingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_givingClause

	return p
}

func (s *GivingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GivingClauseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserGIVING, 0)
}

func (s *GivingClauseContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *GivingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GivingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GivingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterGivingClause(s)
	}
}

func (s *GivingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitGivingClause(s)
	}
}

func (s *GivingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitGivingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) GivingClause() (localctx IGivingClauseContext) {
	localctx = NewGivingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, bbyCBLParserRULE_givingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(527)
		p.Match(bbyCBLParserGIVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(528)
		p.ExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGotoStmtContext is an interface to support dynamic dispatch.
type IGotoStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GO() antlr.TerminalNode
	TO() antlr.TerminalNode
	ExprList() IExprListContext

	// IsGotoStmtContext differentiates from other interfaces.
	IsGotoStmtContext()
}

type GotoStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStmtContext() *GotoStmtContext {
	var p = new(GotoStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_gotoStmt
	return p
}

func InitEmptyGotoStmtContext(p *GotoStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_gotoStmt
}

func (*GotoStmtContext) IsGotoStmtContext() {}

func NewGotoStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStmtContext {
	var p = new(GotoStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_gotoStmt

	return p
}

func (s *GotoStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStmtContext) GO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserGO, 0)
}

func (s *GotoStmtContext) TO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, 0)
}

func (s *GotoStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *GotoStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterGotoStmt(s)
	}
}

func (s *GotoStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitGotoStmt(s)
	}
}

func (s *GotoStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitGotoStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) GotoStmt() (localctx IGotoStmtContext) {
	localctx = NewGotoStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, bbyCBLParserRULE_gotoStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Match(bbyCBLParserGO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(531)
		p.Match(bbyCBLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(532)
		p.ExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStmtContext is an interface to support dynamic dispatch.
type IIfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Condition() IConditionContext
	THEN() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode
	END_IF() antlr.TerminalNode
	END() antlr.TerminalNode

	// IsIfStmtContext differentiates from other interfaces.
	IsIfStmtContext()
}

type IfStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStmtContext() *IfStmtContext {
	var p = new(IfStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_ifStmt
	return p
}

func InitEmptyIfStmtContext(p *IfStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_ifStmt
}

func (*IfStmtContext) IsIfStmtContext() {}

func NewIfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStmtContext {
	var p = new(IfStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_ifStmt

	return p
}

func (s *IfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserIF, 0)
}

func (s *IfStmtContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *IfStmtContext) THEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTHEN, 0)
}

func (s *IfStmtContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStmtContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserELSE, 0)
}

func (s *IfStmtContext) END_IF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND_IF, 0)
}

func (s *IfStmtContext) END() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND, 0)
}

func (s *IfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterIfStmt(s)
	}
}

func (s *IfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitIfStmt(s)
	}
}

func (s *IfStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitIfStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) IfStmt() (localctx IIfStmtContext) {
	localctx = NewIfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, bbyCBLParserRULE_ifStmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		p.Match(bbyCBLParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(535)
		p.Condition()
	}
	{
		p.SetState(536)
		p.Match(bbyCBLParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(537)
				p.Statement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(542)
			p.Match(bbyCBLParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(544)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(543)
					p.Statement()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(546)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(550)
			_la = p.GetTokenStream().LA(1)

			if !(_la == bbyCBLParserEND || _la == bbyCBLParserEND_IF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopStmtContext is an interface to support dynamic dispatch.
type ILoopStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOOP() antlr.TerminalNode
	END() antlr.TerminalNode
	AllLoopContent() []ILoopContentContext
	LoopContent(i int) ILoopContentContext
	Identifier() IIdentifierContext

	// IsLoopStmtContext differentiates from other interfaces.
	IsLoopStmtContext()
}

type LoopStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStmtContext() *LoopStmtContext {
	var p = new(LoopStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_loopStmt
	return p
}

func InitEmptyLoopStmtContext(p *LoopStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_loopStmt
}

func (*LoopStmtContext) IsLoopStmtContext() {}

func NewLoopStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStmtContext {
	var p = new(LoopStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_loopStmt

	return p
}

func (s *LoopStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStmtContext) LOOP() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLOOP, 0)
}

func (s *LoopStmtContext) END() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND, 0)
}

func (s *LoopStmtContext) AllLoopContent() []ILoopContentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoopContentContext); ok {
			len++
		}
	}

	tst := make([]ILoopContentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoopContentContext); ok {
			tst[i] = t.(ILoopContentContext)
			i++
		}
	}

	return tst
}

func (s *LoopStmtContext) LoopContent(i int) ILoopContentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopContentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopContentContext)
}

func (s *LoopStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LoopStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLoopStmt(s)
	}
}

func (s *LoopStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLoopStmt(s)
	}
}

func (s *LoopStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitLoopStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) LoopStmt() (localctx ILoopStmtContext) {
	localctx = NewLoopStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, bbyCBLParserRULE_loopStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Match(bbyCBLParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1170199256724865024) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&84017) != 0) {
		{
			p.SetState(554)
			p.LoopContent()
		}

		p.SetState(559)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(560)
		p.Match(bbyCBLParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(561)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopContentContext is an interface to support dynamic dispatch.
type ILoopContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LoopControl() ILoopControlContext
	Statement() IStatementContext
	Sentence() ISentenceContext

	// IsLoopContentContext differentiates from other interfaces.
	IsLoopContentContext()
}

type LoopContentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopContentContext() *LoopContentContext {
	var p = new(LoopContentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_loopContent
	return p
}

func InitEmptyLoopContentContext(p *LoopContentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_loopContent
}

func (*LoopContentContext) IsLoopContentContext() {}

func NewLoopContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopContentContext {
	var p = new(LoopContentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_loopContent

	return p
}

func (s *LoopContentContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopContentContext) LoopControl() ILoopControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopControlContext)
}

func (s *LoopContentContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LoopContentContext) Sentence() ISentenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISentenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISentenceContext)
}

func (s *LoopContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLoopContent(s)
	}
}

func (s *LoopContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLoopContent(s)
	}
}

func (s *LoopContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitLoopContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) LoopContent() (localctx ILoopContentContext) {
	localctx = NewLoopContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, bbyCBLParserRULE_loopContent)
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(564)
			p.LoopControl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(565)
			p.Statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(566)
			p.Sentence()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopControlContext is an interface to support dynamic dispatch.
type ILoopControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VaryingClause() IVaryingClauseContext
	WhileClause() IWhileClauseContext
	UntilClause() IUntilClauseContext

	// IsLoopControlContext differentiates from other interfaces.
	IsLoopControlContext()
}

type LoopControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopControlContext() *LoopControlContext {
	var p = new(LoopControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_loopControl
	return p
}

func InitEmptyLoopControlContext(p *LoopControlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_loopControl
}

func (*LoopControlContext) IsLoopControlContext() {}

func NewLoopControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopControlContext {
	var p = new(LoopControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_loopControl

	return p
}

func (s *LoopControlContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopControlContext) VaryingClause() IVaryingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVaryingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVaryingClauseContext)
}

func (s *LoopControlContext) WhileClause() IWhileClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileClauseContext)
}

func (s *LoopControlContext) UntilClause() IUntilClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUntilClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUntilClauseContext)
}

func (s *LoopControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLoopControl(s)
	}
}

func (s *LoopControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLoopControl(s)
	}
}

func (s *LoopControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitLoopControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) LoopControl() (localctx ILoopControlContext) {
	localctx = NewLoopControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, bbyCBLParserRULE_loopControl)
	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserVARYING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(569)
			p.VaryingClause()
		}

	case bbyCBLParserWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(570)
			p.WhileClause()
		}

	case bbyCBLParserUNTIL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(571)
			p.UntilClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMoveStmtContext is an interface to support dynamic dispatch.
type IMoveStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MOVE() antlr.TerminalNode
	AllExprList() []IExprListContext
	ExprList(i int) IExprListContext
	TO() antlr.TerminalNode

	// IsMoveStmtContext differentiates from other interfaces.
	IsMoveStmtContext()
}

type MoveStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveStmtContext() *MoveStmtContext {
	var p = new(MoveStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_moveStmt
	return p
}

func InitEmptyMoveStmtContext(p *MoveStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_moveStmt
}

func (*MoveStmtContext) IsMoveStmtContext() {}

func NewMoveStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveStmtContext {
	var p = new(MoveStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_moveStmt

	return p
}

func (s *MoveStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveStmtContext) MOVE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMOVE, 0)
}

func (s *MoveStmtContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *MoveStmtContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *MoveStmtContext) TO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, 0)
}

func (s *MoveStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterMoveStmt(s)
	}
}

func (s *MoveStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitMoveStmt(s)
	}
}

func (s *MoveStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitMoveStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) MoveStmt() (localctx IMoveStmtContext) {
	localctx = NewMoveStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, bbyCBLParserRULE_moveStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(bbyCBLParserMOVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(575)
		p.ExprList()
	}
	{
		p.SetState(576)
		p.Match(bbyCBLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(577)
		p.ExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplyStmtContext is an interface to support dynamic dispatch.
type IMultiplyStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULTIPLY() antlr.TerminalNode
	AllExprList() []IExprListContext
	ExprList(i int) IExprListContext
	BY() antlr.TerminalNode
	AllGivingClause() []IGivingClauseContext
	GivingClause(i int) IGivingClauseContext

	// IsMultiplyStmtContext differentiates from other interfaces.
	IsMultiplyStmtContext()
}

type MultiplyStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyStmtContext() *MultiplyStmtContext {
	var p = new(MultiplyStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_multiplyStmt
	return p
}

func InitEmptyMultiplyStmtContext(p *MultiplyStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_multiplyStmt
}

func (*MultiplyStmtContext) IsMultiplyStmtContext() {}

func NewMultiplyStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyStmtContext {
	var p = new(MultiplyStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_multiplyStmt

	return p
}

func (s *MultiplyStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyStmtContext) MULTIPLY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMULTIPLY, 0)
}

func (s *MultiplyStmtContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *MultiplyStmtContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *MultiplyStmtContext) BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, 0)
}

func (s *MultiplyStmtContext) AllGivingClause() []IGivingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGivingClauseContext); ok {
			len++
		}
	}

	tst := make([]IGivingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGivingClauseContext); ok {
			tst[i] = t.(IGivingClauseContext)
			i++
		}
	}

	return tst
}

func (s *MultiplyStmtContext) GivingClause(i int) IGivingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGivingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGivingClauseContext)
}

func (s *MultiplyStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterMultiplyStmt(s)
	}
}

func (s *MultiplyStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitMultiplyStmt(s)
	}
}

func (s *MultiplyStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitMultiplyStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) MultiplyStmt() (localctx IMultiplyStmtContext) {
	localctx = NewMultiplyStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, bbyCBLParserRULE_multiplyStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.Match(bbyCBLParserMULTIPLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(580)
		p.ExprList()
	}
	{
		p.SetState(581)
		p.Match(bbyCBLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(582)
		p.ExprList()
	}
	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserGIVING {
		{
			p.SetState(583)
			p.GivingClause()
		}

		p.SetState(588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INextSentenceStmtContext is an interface to support dynamic dispatch.
type INextSentenceStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEXT_SENTENCE() antlr.TerminalNode
	Identifier() IIdentifierContext
	NEXT() antlr.TerminalNode
	SENTENCE() antlr.TerminalNode

	// IsNextSentenceStmtContext differentiates from other interfaces.
	IsNextSentenceStmtContext()
}

type NextSentenceStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNextSentenceStmtContext() *NextSentenceStmtContext {
	var p = new(NextSentenceStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_nextSentenceStmt
	return p
}

func InitEmptyNextSentenceStmtContext(p *NextSentenceStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_nextSentenceStmt
}

func (*NextSentenceStmtContext) IsNextSentenceStmtContext() {}

func NewNextSentenceStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NextSentenceStmtContext {
	var p = new(NextSentenceStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_nextSentenceStmt

	return p
}

func (s *NextSentenceStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *NextSentenceStmtContext) NEXT_SENTENCE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNEXT_SENTENCE, 0)
}

func (s *NextSentenceStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NextSentenceStmtContext) NEXT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNEXT, 0)
}

func (s *NextSentenceStmtContext) SENTENCE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSENTENCE, 0)
}

func (s *NextSentenceStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NextSentenceStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NextSentenceStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterNextSentenceStmt(s)
	}
}

func (s *NextSentenceStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitNextSentenceStmt(s)
	}
}

func (s *NextSentenceStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitNextSentenceStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) NextSentenceStmt() (localctx INextSentenceStmtContext) {
	localctx = NewNextSentenceStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, bbyCBLParserRULE_nextSentenceStmt)
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserNEXT_SENTENCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(589)
			p.Match(bbyCBLParserNEXT_SENTENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(591)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(590)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case bbyCBLParserNEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(593)
			p.Match(bbyCBLParserNEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(594)
			p.Match(bbyCBLParserSENTENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(596)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(595)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPerformStmtContext is an interface to support dynamic dispatch.
type IPerformStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PERFORM() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	THROUGH() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	ExprList() IExprListContext

	// IsPerformStmtContext differentiates from other interfaces.
	IsPerformStmtContext()
}

type PerformStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformStmtContext() *PerformStmtContext {
	var p = new(PerformStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_performStmt
	return p
}

func InitEmptyPerformStmtContext(p *PerformStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_performStmt
}

func (*PerformStmtContext) IsPerformStmtContext() {}

func NewPerformStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformStmtContext {
	var p = new(PerformStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_performStmt

	return p
}

func (s *PerformStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformStmtContext) PERFORM() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPERFORM, 0)
}

func (s *PerformStmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *PerformStmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PerformStmtContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTHROUGH, 0)
}

func (s *PerformStmtContext) TIMES() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTIMES, 0)
}

func (s *PerformStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *PerformStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterPerformStmt(s)
	}
}

func (s *PerformStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitPerformStmt(s)
	}
}

func (s *PerformStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitPerformStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) PerformStmt() (localctx IPerformStmtContext) {
	localctx = NewPerformStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, bbyCBLParserRULE_performStmt)
	p.SetState(615)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(600)
			p.Match(bbyCBLParserPERFORM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(601)
			p.expr(0)
		}
		p.SetState(604)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(602)
				p.Match(bbyCBLParserTHROUGH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(603)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(609)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(606)
				p.expr(0)
			}
			{
				p.SetState(607)
				p.Match(bbyCBLParserTIMES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(611)
			p.Match(bbyCBLParserPERFORM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)
			p.ExprList()
		}
		{
			p.SetState(613)
			p.Match(bbyCBLParserTIMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignalStmtContext is an interface to support dynamic dispatch.
type ISignalStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSignalStmtContext differentiates from other interfaces.
	IsSignalStmtContext()
}

type SignalStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalStmtContext() *SignalStmtContext {
	var p = new(SignalStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_signalStmt
	return p
}

func InitEmptySignalStmtContext(p *SignalStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_signalStmt
}

func (*SignalStmtContext) IsSignalStmtContext() {}

func NewSignalStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalStmtContext {
	var p = new(SignalStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_signalStmt

	return p
}

func (s *SignalStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalStmtContext) CopyAll(ctx *SignalStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SignalStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SignalEnableContext struct {
	SignalStmtContext
}

func NewSignalEnableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SignalEnableContext {
	var p = new(SignalEnableContext)

	InitEmptySignalStmtContext(&p.SignalStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*SignalStmtContext))

	return p
}

func (s *SignalEnableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalEnableContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSIGNAL, 0)
}

func (s *SignalEnableContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *SignalEnableContext) ON() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserON, 0)
}

func (s *SignalEnableContext) ERROR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserERROR, 0)
}

func (s *SignalEnableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SignalEnableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSignalEnable(s)
	}
}

func (s *SignalEnableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSignalEnable(s)
	}
}

func (s *SignalEnableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitSignalEnable(s)

	default:
		return t.VisitChildren(s)
	}
}

type SignalExprContext struct {
	SignalStmtContext
}

func NewSignalExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SignalExprContext {
	var p = new(SignalExprContext)

	InitEmptySignalStmtContext(&p.SignalStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*SignalStmtContext))

	return p
}

func (s *SignalExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalExprContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSIGNAL, 0)
}

func (s *SignalExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SignalExprContext) ON() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserON, 0)
}

func (s *SignalExprContext) ERROR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserERROR, 0)
}

func (s *SignalExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SignalExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSignalExpr(s)
	}
}

func (s *SignalExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSignalExpr(s)
	}
}

func (s *SignalExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitSignalExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type SignalDisableContext struct {
	SignalStmtContext
}

func NewSignalDisableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SignalDisableContext {
	var p = new(SignalDisableContext)

	InitEmptySignalStmtContext(&p.SignalStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*SignalStmtContext))

	return p
}

func (s *SignalDisableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalDisableContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSIGNAL, 0)
}

func (s *SignalDisableContext) OFF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOFF, 0)
}

func (s *SignalDisableContext) ON() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserON, 0)
}

func (s *SignalDisableContext) ERROR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserERROR, 0)
}

func (s *SignalDisableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SignalDisableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSignalDisable(s)
	}
}

func (s *SignalDisableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSignalDisable(s)
	}
}

func (s *SignalDisableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitSignalDisable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) SignalStmt() (localctx ISignalStmtContext) {
	localctx = NewSignalStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, bbyCBLParserRULE_signalStmt)
	var _la int

	p.SetState(640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSignalDisableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(617)
			p.Match(bbyCBLParserSIGNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(618)
			p.Match(bbyCBLParserOFF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(619)
			p.Match(bbyCBLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(620)
			p.Match(bbyCBLParserERROR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(621)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSignalEnableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(624)
			p.Match(bbyCBLParserSIGNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(625)
			p.SimpleId()
		}
		{
			p.SetState(626)
			p.Match(bbyCBLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(627)
			p.Match(bbyCBLParserERROR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(629)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(628)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSignalExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(631)
			p.Match(bbyCBLParserSIGNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(632)
			p.expr(0)
		}
		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserON {
			{
				p.SetState(633)
				p.Match(bbyCBLParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(634)
				p.Match(bbyCBLParserERROR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(636)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(635)
					p.Identifier()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStopStmtContext is an interface to support dynamic dispatch.
type IStopStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STOP() antlr.TerminalNode
	RUN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsStopStmtContext differentiates from other interfaces.
	IsStopStmtContext()
}

type StopStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopStmtContext() *StopStmtContext {
	var p = new(StopStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_stopStmt
	return p
}

func InitEmptyStopStmtContext(p *StopStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_stopStmt
}

func (*StopStmtContext) IsStopStmtContext() {}

func NewStopStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopStmtContext {
	var p = new(StopStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_stopStmt

	return p
}

func (s *StopStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StopStmtContext) STOP() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSTOP, 0)
}

func (s *StopStmtContext) RUN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserRUN, 0)
}

func (s *StopStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StopStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterStopStmt(s)
	}
}

func (s *StopStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitStopStmt(s)
	}
}

func (s *StopStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitStopStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) StopStmt() (localctx IStopStmtContext) {
	localctx = NewStopStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, bbyCBLParserRULE_stopStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		p.Match(bbyCBLParserSTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(643)
			p.Match(bbyCBLParserRUN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(644)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubtractStmtContext is an interface to support dynamic dispatch.
type ISubtractStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBTRACT() antlr.TerminalNode
	AllExprList() []IExprListContext
	ExprList(i int) IExprListContext
	FROM() antlr.TerminalNode
	AllGivingClause() []IGivingClauseContext
	GivingClause(i int) IGivingClauseContext

	// IsSubtractStmtContext differentiates from other interfaces.
	IsSubtractStmtContext()
}

type SubtractStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractStmtContext() *SubtractStmtContext {
	var p = new(SubtractStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_subtractStmt
	return p
}

func InitEmptySubtractStmtContext(p *SubtractStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_subtractStmt
}

func (*SubtractStmtContext) IsSubtractStmtContext() {}

func NewSubtractStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractStmtContext {
	var p = new(SubtractStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_subtractStmt

	return p
}

func (s *SubtractStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractStmtContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSUBTRACT, 0)
}

func (s *SubtractStmtContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *SubtractStmtContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *SubtractStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserFROM, 0)
}

func (s *SubtractStmtContext) AllGivingClause() []IGivingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGivingClauseContext); ok {
			len++
		}
	}

	tst := make([]IGivingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGivingClauseContext); ok {
			tst[i] = t.(IGivingClauseContext)
			i++
		}
	}

	return tst
}

func (s *SubtractStmtContext) GivingClause(i int) IGivingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGivingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGivingClauseContext)
}

func (s *SubtractStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSubtractStmt(s)
	}
}

func (s *SubtractStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSubtractStmt(s)
	}
}

func (s *SubtractStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitSubtractStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) SubtractStmt() (localctx ISubtractStmtContext) {
	localctx = NewSubtractStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, bbyCBLParserRULE_subtractStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.Match(bbyCBLParserSUBTRACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(648)
		p.ExprList()
	}
	{
		p.SetState(649)
		p.Match(bbyCBLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(650)
		p.ExprList()
	}
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserGIVING {
		{
			p.SetState(651)
			p.GivingClause()
		}

		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUntilClauseContext is an interface to support dynamic dispatch.
type IUntilClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNTIL() antlr.TerminalNode
	Condition() IConditionContext

	// IsUntilClauseContext differentiates from other interfaces.
	IsUntilClauseContext()
}

type UntilClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUntilClauseContext() *UntilClauseContext {
	var p = new(UntilClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_untilClause
	return p
}

func InitEmptyUntilClauseContext(p *UntilClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_untilClause
}

func (*UntilClauseContext) IsUntilClauseContext() {}

func NewUntilClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UntilClauseContext {
	var p = new(UntilClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_untilClause

	return p
}

func (s *UntilClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UntilClauseContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserUNTIL, 0)
}

func (s *UntilClauseContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *UntilClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UntilClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UntilClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterUntilClause(s)
	}
}

func (s *UntilClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitUntilClause(s)
	}
}

func (s *UntilClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitUntilClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) UntilClause() (localctx IUntilClauseContext) {
	localctx = NewUntilClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, bbyCBLParserRULE_untilClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Match(bbyCBLParserUNTIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(658)
		p.Condition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVaryingClauseContext is an interface to support dynamic dispatch.
type IVaryingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARYING() antlr.TerminalNode
	QualifiedId() IQualifiedIdContext
	IdentifierSegment() IIdentifierSegmentContext
	FROM() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	TO() antlr.TerminalNode
	BY() antlr.TerminalNode

	// IsVaryingClauseContext differentiates from other interfaces.
	IsVaryingClauseContext()
}

type VaryingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVaryingClauseContext() *VaryingClauseContext {
	var p = new(VaryingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_varyingClause
	return p
}

func InitEmptyVaryingClauseContext(p *VaryingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_varyingClause
}

func (*VaryingClauseContext) IsVaryingClauseContext() {}

func NewVaryingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VaryingClauseContext {
	var p = new(VaryingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_varyingClause

	return p
}

func (s *VaryingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *VaryingClauseContext) VARYING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserVARYING, 0)
}

func (s *VaryingClauseContext) QualifiedId() IQualifiedIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdContext)
}

func (s *VaryingClauseContext) IdentifierSegment() IIdentifierSegmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSegmentContext)
}

func (s *VaryingClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserFROM, 0)
}

func (s *VaryingClauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *VaryingClauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *VaryingClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, 0)
}

func (s *VaryingClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, 0)
}

func (s *VaryingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VaryingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VaryingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterVaryingClause(s)
	}
}

func (s *VaryingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitVaryingClause(s)
	}
}

func (s *VaryingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitVaryingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) VaryingClause() (localctx IVaryingClauseContext) {
	localctx = NewVaryingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, bbyCBLParserRULE_varyingClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(bbyCBLParserVARYING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(663)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(661)
			p.QualifiedId()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(662)
			p.IdentifierSegment()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserFROM {
		{
			p.SetState(665)
			p.Match(bbyCBLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(666)
			p.expr(0)
		}

	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserTO {
		{
			p.SetState(669)
			p.Match(bbyCBLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(670)
			p.expr(0)
		}

	}
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserBY {
		{
			p.SetState(673)
			p.Match(bbyCBLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(674)
			p.expr(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVaryingStmtContext is an interface to support dynamic dispatch.
type IVaryingStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VaryingClause() IVaryingClauseContext
	VARYING() antlr.TerminalNode

	// IsVaryingStmtContext differentiates from other interfaces.
	IsVaryingStmtContext()
}

type VaryingStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVaryingStmtContext() *VaryingStmtContext {
	var p = new(VaryingStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_varyingStmt
	return p
}

func InitEmptyVaryingStmtContext(p *VaryingStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_varyingStmt
}

func (*VaryingStmtContext) IsVaryingStmtContext() {}

func NewVaryingStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VaryingStmtContext {
	var p = new(VaryingStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_varyingStmt

	return p
}

func (s *VaryingStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *VaryingStmtContext) VaryingClause() IVaryingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVaryingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVaryingClauseContext)
}

func (s *VaryingStmtContext) VARYING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserVARYING, 0)
}

func (s *VaryingStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VaryingStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VaryingStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterVaryingStmt(s)
	}
}

func (s *VaryingStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitVaryingStmt(s)
	}
}

func (s *VaryingStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitVaryingStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) VaryingStmt() (localctx IVaryingStmtContext) {
	localctx = NewVaryingStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, bbyCBLParserRULE_varyingStmt)
	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(677)
			p.VaryingClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(678)
			p.Match(bbyCBLParserVARYING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) CopyAll(ctx *WhenClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WhenValuesContext struct {
	WhenClauseContext
}

func NewWhenValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhenValuesContext {
	var p = new(WhenValuesContext)

	InitEmptyWhenClauseContext(&p.WhenClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*WhenClauseContext))

	return p
}

func (s *WhenValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenValuesContext) WHEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWHEN, 0)
}

func (s *WhenValuesContext) AllEvalSubject() []IEvalSubjectContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEvalSubjectContext); ok {
			len++
		}
	}

	tst := make([]IEvalSubjectContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEvalSubjectContext); ok {
			tst[i] = t.(IEvalSubjectContext)
			i++
		}
	}

	return tst
}

func (s *WhenValuesContext) EvalSubject(i int) IEvalSubjectContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvalSubjectContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvalSubjectContext)
}

func (s *WhenValuesContext) AllTHROUGH() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserTHROUGH)
}

func (s *WhenValuesContext) THROUGH(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTHROUGH, i)
}

func (s *WhenValuesContext) AllALSO() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserALSO)
}

func (s *WhenValuesContext) ALSO(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserALSO, i)
}

func (s *WhenValuesContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *WhenValuesContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhenValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterWhenValues(s)
	}
}

func (s *WhenValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitWhenValues(s)
	}
}

func (s *WhenValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitWhenValues(s)

	default:
		return t.VisitChildren(s)
	}
}

type WhenOtherContext struct {
	WhenClauseContext
}

func NewWhenOtherContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhenOtherContext {
	var p = new(WhenOtherContext)

	InitEmptyWhenClauseContext(&p.WhenClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*WhenClauseContext))

	return p
}

func (s *WhenOtherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenOtherContext) WHEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWHEN, 0)
}

func (s *WhenOtherContext) OTHER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOTHER, 0)
}

func (s *WhenOtherContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *WhenOtherContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhenOtherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterWhenOther(s)
	}
}

func (s *WhenOtherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitWhenOther(s)
	}
}

func (s *WhenOtherContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitWhenOther(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, bbyCBLParserRULE_whenClause)
	var _la int

	var _alt int

	p.SetState(713)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		localctx = NewWhenOtherContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(681)
			p.Match(bbyCBLParserWHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(682)
			p.Match(bbyCBLParserOTHER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1170199256724865024) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&16433) != 0) {
			{
				p.SetState(683)
				p.Statement()
			}

			p.SetState(686)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewWhenValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(688)
			p.Match(bbyCBLParserWHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(689)
			p.EvalSubject()
		}
		p.SetState(692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserTHROUGH {
			{
				p.SetState(690)
				p.Match(bbyCBLParserTHROUGH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(691)
				p.EvalSubject()
			}

		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(694)
					p.Match(bbyCBLParserALSO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(695)
					p.EvalSubject()
				}
				p.SetState(698)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == bbyCBLParserTHROUGH {
					{
						p.SetState(696)
						p.Match(bbyCBLParserTHROUGH)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(697)
						p.EvalSubject()
					}

				}

			}
			p.SetState(704)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserALSO {
			{
				p.SetState(705)
				p.Match(bbyCBLParserALSO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1170199256724865024) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&16433) != 0) {
			{
				p.SetState(708)
				p.Statement()
			}

			p.SetState(711)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileClauseContext is an interface to support dynamic dispatch.
type IWhileClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Condition() IConditionContext

	// IsWhileClauseContext differentiates from other interfaces.
	IsWhileClauseContext()
}

type WhileClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileClauseContext() *WhileClauseContext {
	var p = new(WhileClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_whileClause
	return p
}

func InitEmptyWhileClauseContext(p *WhileClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_whileClause
}

func (*WhileClauseContext) IsWhileClauseContext() {}

func NewWhileClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileClauseContext {
	var p = new(WhileClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_whileClause

	return p
}

func (s *WhileClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileClauseContext) WHILE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWHILE, 0)
}

func (s *WhileClauseContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *WhileClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterWhileClause(s)
	}
}

func (s *WhileClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitWhileClause(s)
	}
}

func (s *WhileClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitWhileClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) WhileClause() (localctx IWhileClauseContext) {
	localctx = NewWhileClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, bbyCBLParserRULE_whileClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(715)
		p.Match(bbyCBLParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(716)
		p.Condition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprListContext is an interface to support dynamic dispatch.
type IExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExprListContext differentiates from other interfaces.
	IsExprListContext()
}

type ExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprListContext() *ExprListContext {
	var p = new(ExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_exprList
	return p
}

func InitEmptyExprListContext(p *ExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_exprList
}

func (*ExprListContext) IsExprListContext() {}

func NewExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprListContext {
	var p = new(ExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_exprList

	return p
}

func (s *ExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprListContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprListContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserCOMMA)
}

func (s *ExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCOMMA, i)
}

func (s *ExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterExprList(s)
	}
}

func (s *ExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitExprList(s)
	}
}

func (s *ExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) ExprList() (localctx IExprListContext) {
	localctx = NewExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, bbyCBLParserRULE_exprList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.expr(0)
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(720)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == bbyCBLParserCOMMA {
				{
					p.SetState(719)
					p.Match(bbyCBLParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(722)
				p.expr(0)
			}

		}
		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleCond() []ISimpleCondContext
	SimpleCond(i int) ISimpleCondContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode
	AllXOR() []antlr.TerminalNode
	XOR(i int) antlr.TerminalNode

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_condition
	return p
}

func InitEmptyConditionContext(p *ConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_condition
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) AllSimpleCond() []ISimpleCondContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleCondContext); ok {
			len++
		}
	}

	tst := make([]ISimpleCondContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleCondContext); ok {
			tst[i] = t.(ISimpleCondContext)
			i++
		}
	}

	return tst
}

func (s *ConditionContext) SimpleCond(i int) ISimpleCondContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleCondContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleCondContext)
}

func (s *ConditionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserAND)
}

func (s *ConditionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserAND, i)
}

func (s *ConditionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserOR)
}

func (s *ConditionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOR, i)
}

func (s *ConditionContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserXOR)
}

func (s *ConditionContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserXOR, i)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitCondition(s)
	}
}

func (s *ConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, bbyCBLParserRULE_condition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.SimpleCond()
	}
	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-27)) & ^0x3f) == 0 && ((int64(1)<<(_la-27))&1152921506754330625) != 0 {
		{
			p.SetState(729)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-27)) & ^0x3f) == 0 && ((int64(1)<<(_la-27))&1152921506754330625) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(730)
			p.SimpleCond()
		}

		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleCondContext is an interface to support dynamic dispatch.
type ISimpleCondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Condition() IConditionContext
	RPAREN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	NOT() antlr.TerminalNode
	Comparator() IComparatorContext

	// IsSimpleCondContext differentiates from other interfaces.
	IsSimpleCondContext()
}

type SimpleCondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleCondContext() *SimpleCondContext {
	var p = new(SimpleCondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_simpleCond
	return p
}

func InitEmptySimpleCondContext(p *SimpleCondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_simpleCond
}

func (*SimpleCondContext) IsSimpleCondContext() {}

func NewSimpleCondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleCondContext {
	var p = new(SimpleCondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_simpleCond

	return p
}

func (s *SimpleCondContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleCondContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLPAREN, 0)
}

func (s *SimpleCondContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *SimpleCondContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserRPAREN, 0)
}

func (s *SimpleCondContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCondContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleCondContext) NOT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNOT, 0)
}

func (s *SimpleCondContext) Comparator() IComparatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparatorContext)
}

func (s *SimpleCondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleCondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSimpleCond(s)
	}
}

func (s *SimpleCondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSimpleCond(s)
	}
}

func (s *SimpleCondContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitSimpleCond(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) SimpleCond() (localctx ISimpleCondContext) {
	localctx = NewSimpleCondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, bbyCBLParserRULE_simpleCond)
	var _la int

	p.SetState(755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(736)
			p.Match(bbyCBLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(737)
			p.Condition()
		}
		{
			p.SetState(738)
			p.Match(bbyCBLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(741)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(740)
				p.Match(bbyCBLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(743)
			p.expr(0)
		}
		p.SetState(747)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-97)) & ^0x3f) == 0 && ((int64(1)<<(_la-97))&63) != 0 {
			{
				p.SetState(744)
				p.Comparator()
			}
			{
				p.SetState(745)
				p.expr(0)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserNOT {
			{
				p.SetState(749)
				p.Match(bbyCBLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(752)
			p.Comparator()
		}
		{
			p.SetState(753)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparatorContext is an interface to support dynamic dispatch.
type IComparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NE() antlr.TerminalNode
	LT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GE() antlr.TerminalNode

	// IsComparatorContext differentiates from other interfaces.
	IsComparatorContext()
}

type ComparatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparatorContext() *ComparatorContext {
	var p = new(ComparatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_comparator
	return p
}

func InitEmptyComparatorContext(p *ComparatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_comparator
}

func (*ComparatorContext) IsComparatorContext() {}

func NewComparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparatorContext {
	var p = new(ComparatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_comparator

	return p
}

func (s *ComparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEQ, 0)
}

func (s *ComparatorContext) NE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNE, 0)
}

func (s *ComparatorContext) LT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLT, 0)
}

func (s *ComparatorContext) LE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLE, 0)
}

func (s *ComparatorContext) GT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserGT, 0)
}

func (s *ComparatorContext) GE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserGE, 0)
}

func (s *ComparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterComparator(s)
	}
}

func (s *ComparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitComparator(s)
	}
}

func (s *ComparatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitComparator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) Comparator() (localctx IComparatorContext) {
	localctx = NewComparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, bbyCBLParserRULE_comparator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-97)) & ^0x3f) == 0 && ((int64(1)<<(_la-97))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierSegmentContext is an interface to support dynamic dispatch.
type IIdentifierSegmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleId() ISimpleIdContext
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode

	// IsIdentifierSegmentContext differentiates from other interfaces.
	IsIdentifierSegmentContext()
}

type IdentifierSegmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierSegmentContext() *IdentifierSegmentContext {
	var p = new(IdentifierSegmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identifierSegment
	return p
}

func InitEmptyIdentifierSegmentContext(p *IdentifierSegmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identifierSegment
}

func (*IdentifierSegmentContext) IsIdentifierSegmentContext() {}

func NewIdentifierSegmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierSegmentContext {
	var p = new(IdentifierSegmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_identifierSegment

	return p
}

func (s *IdentifierSegmentContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierSegmentContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *IdentifierSegmentContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserLPAREN)
}

func (s *IdentifierSegmentContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLPAREN, i)
}

func (s *IdentifierSegmentContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierSegmentContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IdentifierSegmentContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserRPAREN)
}

func (s *IdentifierSegmentContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserRPAREN, i)
}

func (s *IdentifierSegmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierSegmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierSegmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterIdentifierSegment(s)
	}
}

func (s *IdentifierSegmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitIdentifierSegment(s)
	}
}

func (s *IdentifierSegmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitIdentifierSegment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) IdentifierSegment() (localctx IIdentifierSegmentContext) {
	localctx = NewIdentifierSegmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, bbyCBLParserRULE_identifierSegment)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.SimpleId()
	}
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(760)
				p.Match(bbyCBLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(761)
				p.expr(0)
			}
			{
				p.SetState(762)
				p.Match(bbyCBLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedIdContext is an interface to support dynamic dispatch.
type IQualifiedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierSegment() []IIdentifierSegmentContext
	IdentifierSegment(i int) IIdentifierSegmentContext
	AllOF() []antlr.TerminalNode
	OF(i int) antlr.TerminalNode

	// IsQualifiedIdContext differentiates from other interfaces.
	IsQualifiedIdContext()
}

type QualifiedIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdContext() *QualifiedIdContext {
	var p = new(QualifiedIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_qualifiedId
	return p
}

func InitEmptyQualifiedIdContext(p *QualifiedIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_qualifiedId
}

func (*QualifiedIdContext) IsQualifiedIdContext() {}

func NewQualifiedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdContext {
	var p = new(QualifiedIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_qualifiedId

	return p
}

func (s *QualifiedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdContext) AllIdentifierSegment() []IIdentifierSegmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierSegmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierSegmentContext); ok {
			tst[i] = t.(IIdentifierSegmentContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedIdContext) IdentifierSegment(i int) IIdentifierSegmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSegmentContext)
}

func (s *QualifiedIdContext) AllOF() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserOF)
}

func (s *QualifiedIdContext) OF(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOF, i)
}

func (s *QualifiedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterQualifiedId(s)
	}
}

func (s *QualifiedIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitQualifiedId(s)
	}
}

func (s *QualifiedIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitQualifiedId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) QualifiedId() (localctx IQualifiedIdContext) {
	localctx = NewQualifiedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, bbyCBLParserRULE_qualifiedId)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.IdentifierSegment()
	}
	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(770)
				p.Match(bbyCBLParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(771)
				p.IdentifierSegment()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) CopyAll(ctx *ExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QualifiedIdExprContext struct {
	ExprContext
}

func NewQualifiedIdExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedIdExprContext {
	var p = new(QualifiedIdExprContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *QualifiedIdExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdExprContext) QualifiedId() IQualifiedIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdContext)
}

func (s *QualifiedIdExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterQualifiedIdExpr(s)
	}
}

func (s *QualifiedIdExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitQualifiedIdExpr(s)
	}
}

func (s *QualifiedIdExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitQualifiedIdExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type UMinusContext struct {
	ExprContext
}

func NewUMinusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UMinusContext {
	var p = new(UMinusContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *UMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UMinusContext) MINUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMINUS, 0)
}

func (s *UMinusContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UMinusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterUMinus(s)
	}
}

func (s *UMinusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitUMinus(s)
	}
}

func (s *UMinusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitUMinus(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdExprContext struct {
	ExprContext
}

func NewIdExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdExprContext {
	var p = new(IdExprContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *IdExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdExprContext) IdentifierSegment() IIdentifierSegmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSegmentContext)
}

func (s *IdExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterIdExpr(s)
	}
}

func (s *IdExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitIdExpr(s)
	}
}

func (s *IdExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitIdExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type MulDivContext struct {
	ExprContext
}

func NewMulDivContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MulDivContext {
	var p = new(MulDivContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *MulDivContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MulDivContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *MulDivContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MulDivContext) MULT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMULT, 0)
}

func (s *MulDivContext) DIV() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDIV, 0)
}

func (s *MulDivContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterMulDiv(s)
	}
}

func (s *MulDivContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitMulDiv(s)
	}
}

func (s *MulDivContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitMulDiv(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddSubContext struct {
	ExprContext
}

func NewAddSubContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddSubContext {
	var p = new(AddSubContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *AddSubContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSubContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *AddSubContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AddSubContext) PLUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPLUS, 0)
}

func (s *AddSubContext) MINUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMINUS, 0)
}

func (s *AddSubContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterAddSub(s)
	}
}

func (s *AddSubContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitAddSub(s)
	}
}

func (s *AddSubContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitAddSub(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParensContext struct {
	ExprContext
}

func NewParensContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParensContext {
	var p = new(ParensContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParensContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLPAREN, 0)
}

func (s *ParensContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParensContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserRPAREN, 0)
}

func (s *ParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterParens(s)
	}
}

func (s *ParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitParens(s)
	}
}

func (s *ParensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitParens(s)

	default:
		return t.VisitChildren(s)
	}
}

type LitExprContext struct {
	ExprContext
}

func NewLitExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LitExprContext {
	var p = new(LitExprContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *LitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LitExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLitExpr(s)
	}
}

func (s *LitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLitExpr(s)
	}
}

func (s *LitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitLitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type UPlusContext struct {
	ExprContext
}

func NewUPlusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UPlusContext {
	var p = new(UPlusContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *UPlusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UPlusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPLUS, 0)
}

func (s *UPlusContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UPlusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterUPlus(s)
	}
}

func (s *UPlusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitUPlus(s)
	}
}

func (s *UPlusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitUPlus(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExpContext struct {
	ExprContext
}

func NewExpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpContext {
	var p = new(ExpContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExpContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExpContext) POW() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPOW, 0)
}

func (s *ExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterExp(s)
	}
}

func (s *ExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitExp(s)
	}
}

func (s *ExpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitExp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *bbyCBLParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 122
	p.EnterRecursionRule(localctx, 122, bbyCBLParserRULE_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUPlusContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(777)
			p.Match(bbyCBLParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(778)
			p.expr(9)
		}

	case 2:
		localctx = NewUMinusContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(779)
			p.Match(bbyCBLParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(780)
			p.expr(8)
		}

	case 3:
		localctx = NewParensContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(781)
			p.Match(bbyCBLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(782)
			p.expr(0)
		}
		{
			p.SetState(783)
			p.Match(bbyCBLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewLitExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(785)
			p.Literal()
		}

	case 5:
		localctx = NewQualifiedIdExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(786)
			p.QualifiedId()
		}

	case 6:
		localctx = NewIdExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(787)
			p.IdentifierSegment()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(801)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(799)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, bbyCBLParserRULE_expr)
				p.SetState(790)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(791)
					p.Match(bbyCBLParserPOW)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(792)
					p.expr(8)
				}

			case 2:
				localctx = NewMulDivContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, bbyCBLParserRULE_expr)
				p.SetState(793)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(794)
					_la = p.GetTokenStream().LA(1)

					if !(_la == bbyCBLParserMULT || _la == bbyCBLParserDIV) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(795)
					p.expr(7)
				}

			case 3:
				localctx = NewAddSubContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, bbyCBLParserRULE_expr)
				p.SetState(796)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(797)
					_la = p.GetTokenStream().LA(1)

					if !(_la == bbyCBLParserPLUS || _la == bbyCBLParserMINUS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(798)
					p.expr(6)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	STRING() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATE_UNDERSCORE() antlr.TerminalNode
	ANY_DATE() antlr.TerminalNode
	ANY_DATE_UNDERSCORE() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserFLOAT, 0)
}

func (s *LiteralContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNUMBER, 0)
}

func (s *LiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSTRING, 0)
}

func (s *LiteralContext) DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE, 0)
}

func (s *LiteralContext) DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_UNDERSCORE, 0)
}

func (s *LiteralContext) ANY_DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE, 0)
}

func (s *LiteralContext) ANY_DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE_UNDERSCORE, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bbyCBLVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bbyCBLParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, bbyCBLParserRULE_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(804)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&126) != 0) || _la == bbyCBLParserSTRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *bbyCBLParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 61:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *bbyCBLParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
