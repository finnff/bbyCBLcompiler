// Code generated from bbyCBL.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // bbyCBL

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type bbyCBLParser struct {
	*antlr.BaseParser
}

var BbyCBLParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func bbycblParserInit() {
	staticData := &BbyCBLParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "'AUTHOR'", "", "'INSTALLATION'",
		"'SECURITY'", "'DATE-COMPILED'", "'BASE'", "'COPY'", "'DESCRIPTION'",
		"'PICTURE'", "'IS'", "'LIKE'", "'OCCURS'", "'ACCEPT'", "'ADD'", "'ALSO'",
		"'ALTER'", "'AND'", "'BY'", "'CALL'", "'CONTENT'", "", "'DELIMITED'",
		"'DISPLAY'", "'DIVIDE'", "'ELSE'", "'END'", "'OFF'", "'END-EVALUATE'",
		"'END-IF'", "'ERROR'", "'EVALUATE'", "'FALSE'", "'FROM'", "'GIVING'",
		"'GO'", "'IF'", "'INTO'", "'LOOP'", "'LOW-VALUES'", "'MOVE'", "'MULTIPLY'",
		"", "'NOT'", "'OF'", "'ON'", "'OR'", "'OTHER'", "'PERFORM'", "'PROCEED'",
		"'REFERENCE'", "'REMAINDER'", "'REPLACING'", "'RUN'", "'SIGNAL'", "'SIZE'",
		"'SPACE'", "'SPACES'", "'STOP'", "'SUBTRACT'", "'THEN'", "", "'TIMES'",
		"'TO'", "'TRUE'", "'UNTIL'", "'USING'", "'VALUE'", "'VARYING'", "'WHEN'",
		"'WHILE'", "", "'WITH'", "'NO'", "'ADVANCING'", "'XOR'", "','", "'.'",
		"'('", "')'", "'+'", "'-'", "'*'", "'/'", "'**'", "'='", "'<>'", "'<='",
		"'>='", "'<'", "'>'", "'==='", "'=='", "", "'HIGH-VALUES'",
	}
	staticData.SymbolicNames = []string{
		"", "FLOAT", "NUMBER", "DATE", "DATE_UNDERSCORE", "ANY_DATE", "ANY_DATE_UNDERSCORE",
		"IDENTIFICATION_DIVISION", "DATA_DIVISION", "PROCEDURE_DIVISION", "PROGRAM_ID",
		"AUTHOR", "DATE_WRITTEN", "INSTALLATION", "SECURITY", "DATE_COMPILED",
		"BASE", "COPY", "DESCRIPTION", "PICTURE", "IS", "LIKE", "OCCURS", "ACCEPT",
		"ADD", "ALSO", "ALTER", "AND", "BY", "CALL", "CONTENT", "DELIMITED_BY",
		"DELIMITED", "DISPLAY", "DIVIDE", "ELSE", "END", "OFF", "END_EVALUATE",
		"END_IF", "ERROR", "EVALUATE", "FALSE", "FROM", "GIVING", "GO", "IF",
		"INTO", "LOOP", "LOW_VALUES", "MOVE", "MULTIPLY", "NEXT_SENTENCE", "NOT",
		"OF", "ON", "OR", "OTHER", "PERFORM", "PROCEED", "REFERENCE", "REMAINDER",
		"REPLACING", "RUN", "SIGNAL", "SIZE", "SPACE", "SPACES", "STOP", "SUBTRACT",
		"THEN", "THROUGH", "TIMES", "TO", "TRUE", "UNTIL", "USING", "VALUE",
		"VARYING", "WHEN", "WHILE", "WITH_NO_ADVANCING", "WITH", "NO", "ADVANCING",
		"XOR", "COMMA", "DOT", "LPAREN", "RPAREN", "PLUS", "MINUS", "MULT",
		"DIV", "POW", "EQ", "NE", "LE", "GE", "LT", "GT", "TRIPLE_EQUAL", "DOUBLE_EQUAL",
		"STRING", "HIGH_VALUES", "IDENTIFIER", "WS",
	}
	staticData.RuleNames = []string{
		"program", "identificationDivision", "identificationClause", "dataDivision",
		"dataEntry", "dataCopyStmt", "levelNumber", "pictureClause", "picturePattern",
		"pictureElement", "likeClause", "occursClause", "procedureDivision",
		"usingClause", "paragraph", "sentence", "statement", "identifier", "simpleId",
		"evalSubject", "acceptStmt", "addStmt", "alterStmt", "callStmt", "copySource",
		"copyStmt", "replacePair", "replaceBlock", "equalDelim", "displayItem",
		"delimiterSpec", "valueSpec", "displayStmt", "divideStmt", "evaluateStmt",
		"givingClause", "gotoStmt", "ifStmt", "loopStmt", "loopControl", "moveStmt",
		"multiplyStmt", "nextSentenceStmt", "performStmt", "signalStmt", "stopStmt",
		"subtractStmt", "untilClause", "varyingClause", "varyingStmt", "whenClause",
		"whileClause", "exprList", "condition", "simpleCond", "comparator",
		"identifierSegment", "qualifiedId", "expr", "literal",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 106, 749, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 1, 0, 1, 0, 3, 0, 123, 8, 0, 1, 0, 3, 0, 126,
		8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 5, 1, 132, 8, 1, 10, 1, 12, 1, 135, 9, 1,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 144, 8, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 157, 8, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 3, 2, 174, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 4, 2, 186, 8, 2, 11, 2, 12, 2, 187, 3, 2, 190,
		8, 2, 1, 2, 3, 2, 193, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 3, 2, 205, 8, 2, 1, 2, 1, 2, 3, 2, 209, 8, 2, 1, 3, 1,
		3, 1, 3, 5, 3, 214, 8, 3, 10, 3, 12, 3, 217, 9, 3, 1, 4, 1, 4, 1, 4, 1,
		4, 3, 4, 223, 8, 4, 1, 4, 3, 4, 226, 8, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5,
		1, 5, 4, 5, 234, 8, 5, 11, 5, 12, 5, 235, 3, 5, 238, 8, 5, 1, 5, 1, 5,
		1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 4, 8, 249, 8, 8, 11, 8, 12, 8,
		250, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 257, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 262,
		8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 268, 8, 10, 10, 10, 12, 10, 271,
		9, 10, 1, 11, 1, 11, 1, 11, 3, 11, 276, 8, 11, 1, 12, 1, 12, 1, 12, 3,
		12, 281, 8, 12, 1, 12, 1, 12, 1, 12, 5, 12, 286, 8, 12, 10, 12, 12, 12,
		289, 9, 12, 1, 13, 1, 13, 1, 13, 4, 13, 294, 8, 13, 11, 13, 12, 13, 295,
		1, 14, 1, 14, 1, 14, 5, 14, 301, 8, 14, 10, 14, 12, 14, 304, 9, 14, 1,
		15, 4, 15, 307, 8, 15, 11, 15, 12, 15, 308, 1, 15, 1, 15, 5, 15, 313, 8,
		15, 10, 15, 12, 15, 316, 9, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 3, 16, 338, 8, 16, 1, 17, 1, 17, 1, 17, 4, 17,
		343, 8, 17, 11, 17, 12, 17, 344, 1, 17, 3, 17, 348, 8, 17, 1, 18, 1, 18,
		1, 19, 1, 19, 3, 19, 354, 8, 19, 1, 20, 1, 20, 3, 20, 358, 8, 20, 1, 21,
		1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 365, 8, 21, 10, 21, 12, 21, 368, 9,
		21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23,
		1, 23, 3, 23, 381, 8, 23, 1, 24, 1, 24, 3, 24, 385, 8, 24, 1, 25, 1, 25,
		1, 25, 1, 25, 4, 25, 391, 8, 25, 11, 25, 12, 25, 392, 3, 25, 395, 8, 25,
		1, 25, 3, 25, 398, 8, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 4,
		27, 406, 8, 27, 11, 27, 12, 27, 407, 1, 27, 1, 27, 1, 28, 1, 28, 1, 29,
		1, 29, 3, 29, 416, 8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 423,
		8, 30, 1, 31, 1, 31, 1, 31, 3, 31, 428, 8, 31, 1, 32, 1, 32, 4, 32, 432,
		8, 32, 11, 32, 12, 32, 433, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 440, 8,
		32, 1, 32, 5, 32, 443, 8, 32, 10, 32, 12, 32, 446, 9, 32, 1, 33, 1, 33,
		1, 33, 1, 33, 1, 33, 5, 33, 453, 8, 33, 10, 33, 12, 33, 456, 9, 33, 1,
		33, 1, 33, 3, 33, 460, 8, 33, 1, 34, 1, 34, 3, 34, 464, 8, 34, 1, 34, 1,
		34, 5, 34, 468, 8, 34, 10, 34, 12, 34, 471, 9, 34, 1, 34, 4, 34, 474, 8,
		34, 11, 34, 12, 34, 475, 1, 34, 1, 34, 1, 34, 3, 34, 481, 8, 34, 3, 34,
		483, 8, 34, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 37, 1,
		37, 1, 37, 1, 37, 4, 37, 496, 8, 37, 11, 37, 12, 37, 497, 1, 37, 1, 37,
		4, 37, 502, 8, 37, 11, 37, 12, 37, 503, 3, 37, 506, 8, 37, 1, 37, 3, 37,
		509, 8, 37, 1, 38, 1, 38, 1, 38, 5, 38, 514, 8, 38, 10, 38, 12, 38, 517,
		9, 38, 1, 38, 1, 38, 3, 38, 521, 8, 38, 1, 39, 1, 39, 1, 39, 3, 39, 526,
		8, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 5, 41, 538, 8, 41, 10, 41, 12, 41, 541, 9, 41, 1, 42, 1, 42, 3, 42,
		545, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 551, 8, 43, 1, 43, 1, 43,
		1, 43, 3, 43, 556, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 562, 8, 43,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 569, 8, 44, 1, 44, 1, 44, 1,
		44, 1, 44, 1, 44, 3, 44, 576, 8, 44, 3, 44, 578, 8, 44, 3, 44, 580, 8,
		44, 1, 45, 1, 45, 1, 45, 3, 45, 585, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 5, 46, 592, 8, 46, 10, 46, 12, 46, 595, 9, 46, 1, 47, 1, 47, 1,
		47, 1, 48, 1, 48, 1, 48, 3, 48, 603, 8, 48, 1, 48, 1, 48, 3, 48, 607, 8,
		48, 1, 48, 1, 48, 3, 48, 611, 8, 48, 1, 48, 1, 48, 3, 48, 615, 8, 48, 1,
		49, 1, 49, 3, 49, 619, 8, 49, 1, 50, 1, 50, 1, 50, 4, 50, 624, 8, 50, 11,
		50, 12, 50, 625, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 632, 8, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 3, 50, 638, 8, 50, 5, 50, 640, 8, 50, 10, 50, 12,
		50, 643, 9, 50, 1, 50, 3, 50, 646, 8, 50, 1, 50, 4, 50, 649, 8, 50, 11,
		50, 12, 50, 650, 3, 50, 653, 8, 50, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52,
		3, 52, 660, 8, 52, 1, 52, 5, 52, 663, 8, 52, 10, 52, 12, 52, 666, 9, 52,
		1, 53, 1, 53, 1, 53, 5, 53, 671, 8, 53, 10, 53, 12, 53, 674, 9, 53, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 681, 8, 54, 1, 54, 1, 54, 1, 54,
		1, 54, 1, 54, 3, 54, 688, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 694,
		8, 54, 1, 54, 1, 54, 3, 54, 698, 8, 54, 1, 55, 1, 55, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 5, 56, 707, 8, 56, 10, 56, 12, 56, 710, 9, 56, 1, 57,
		1, 57, 1, 57, 4, 57, 715, 8, 57, 11, 57, 12, 57, 716, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58,
		731, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 5, 58, 742, 8, 58, 10, 58, 12, 58, 745, 9, 58, 1, 59, 1, 59, 1, 59,
		1, 407, 1, 116, 60, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
		28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
		64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
		100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 0, 11, 5, 0, 2, 6, 10,
		12, 68, 68, 90, 91, 105, 105, 2, 0, 2, 2, 105, 105, 3, 0, 30, 30, 60, 60,
		77, 77, 15, 0, 3, 6, 10, 18, 21, 21, 24, 24, 28, 28, 33, 33, 35, 36, 42,
		42, 49, 50, 54, 54, 66, 68, 70, 70, 73, 74, 78, 78, 104, 105, 1, 0, 101,
		102, 2, 0, 36, 36, 39, 39, 3, 0, 27, 27, 56, 56, 85, 85, 1, 0, 95, 100,
		1, 0, 92, 93, 1, 0, 90, 91, 2, 0, 1, 6, 103, 103, 831, 0, 120, 1, 0, 0,
		0, 2, 129, 1, 0, 0, 0, 4, 208, 1, 0, 0, 0, 6, 210, 1, 0, 0, 0, 8, 218,
		1, 0, 0, 0, 10, 229, 1, 0, 0, 0, 12, 241, 1, 0, 0, 0, 14, 243, 1, 0, 0,
		0, 16, 248, 1, 0, 0, 0, 18, 261, 1, 0, 0, 0, 20, 263, 1, 0, 0, 0, 22, 272,
		1, 0, 0, 0, 24, 277, 1, 0, 0, 0, 26, 293, 1, 0, 0, 0, 28, 297, 1, 0, 0,
		0, 30, 306, 1, 0, 0, 0, 32, 337, 1, 0, 0, 0, 34, 347, 1, 0, 0, 0, 36, 349,
		1, 0, 0, 0, 38, 353, 1, 0, 0, 0, 40, 355, 1, 0, 0, 0, 42, 359, 1, 0, 0,
		0, 44, 369, 1, 0, 0, 0, 46, 376, 1, 0, 0, 0, 48, 384, 1, 0, 0, 0, 50, 386,
		1, 0, 0, 0, 52, 399, 1, 0, 0, 0, 54, 403, 1, 0, 0, 0, 56, 411, 1, 0, 0,
		0, 58, 413, 1, 0, 0, 0, 60, 422, 1, 0, 0, 0, 62, 427, 1, 0, 0, 0, 64, 429,
		1, 0, 0, 0, 66, 447, 1, 0, 0, 0, 68, 461, 1, 0, 0, 0, 70, 484, 1, 0, 0,
		0, 72, 487, 1, 0, 0, 0, 74, 491, 1, 0, 0, 0, 76, 510, 1, 0, 0, 0, 78, 525,
		1, 0, 0, 0, 80, 527, 1, 0, 0, 0, 82, 532, 1, 0, 0, 0, 84, 542, 1, 0, 0,
		0, 86, 561, 1, 0, 0, 0, 88, 579, 1, 0, 0, 0, 90, 581, 1, 0, 0, 0, 92, 586,
		1, 0, 0, 0, 94, 596, 1, 0, 0, 0, 96, 599, 1, 0, 0, 0, 98, 618, 1, 0, 0,
		0, 100, 652, 1, 0, 0, 0, 102, 654, 1, 0, 0, 0, 104, 657, 1, 0, 0, 0, 106,
		667, 1, 0, 0, 0, 108, 697, 1, 0, 0, 0, 110, 699, 1, 0, 0, 0, 112, 701,
		1, 0, 0, 0, 114, 711, 1, 0, 0, 0, 116, 730, 1, 0, 0, 0, 118, 746, 1, 0,
		0, 0, 120, 122, 3, 2, 1, 0, 121, 123, 3, 6, 3, 0, 122, 121, 1, 0, 0, 0,
		122, 123, 1, 0, 0, 0, 123, 125, 1, 0, 0, 0, 124, 126, 3, 24, 12, 0, 125,
		124, 1, 0, 0, 0, 125, 126, 1, 0, 0, 0, 126, 127, 1, 0, 0, 0, 127, 128,
		5, 0, 0, 1, 128, 1, 1, 0, 0, 0, 129, 133, 5, 7, 0, 0, 130, 132, 3, 4, 2,
		0, 131, 130, 1, 0, 0, 0, 132, 135, 1, 0, 0, 0, 133, 131, 1, 0, 0, 0, 133,
		134, 1, 0, 0, 0, 134, 3, 1, 0, 0, 0, 135, 133, 1, 0, 0, 0, 136, 137, 5,
		10, 0, 0, 137, 143, 5, 87, 0, 0, 138, 144, 3, 34, 17, 0, 139, 144, 5, 3,
		0, 0, 140, 144, 5, 4, 0, 0, 141, 144, 5, 5, 0, 0, 142, 144, 5, 6, 0, 0,
		143, 138, 1, 0, 0, 0, 143, 139, 1, 0, 0, 0, 143, 140, 1, 0, 0, 0, 143,
		141, 1, 0, 0, 0, 143, 142, 1, 0, 0, 0, 144, 145, 1, 0, 0, 0, 145, 209,
		5, 87, 0, 0, 146, 147, 5, 11, 0, 0, 147, 148, 5, 87, 0, 0, 148, 149, 3,
		34, 17, 0, 149, 150, 5, 87, 0, 0, 150, 209, 1, 0, 0, 0, 151, 152, 5, 12,
		0, 0, 152, 156, 5, 87, 0, 0, 153, 157, 5, 3, 0, 0, 154, 157, 5, 4, 0, 0,
		155, 157, 3, 34, 17, 0, 156, 153, 1, 0, 0, 0, 156, 154, 1, 0, 0, 0, 156,
		155, 1, 0, 0, 0, 157, 158, 1, 0, 0, 0, 158, 209, 5, 87, 0, 0, 159, 160,
		5, 13, 0, 0, 160, 161, 5, 87, 0, 0, 161, 162, 3, 34, 17, 0, 162, 163, 5,
		87, 0, 0, 163, 209, 1, 0, 0, 0, 164, 165, 5, 14, 0, 0, 165, 166, 5, 87,
		0, 0, 166, 167, 3, 34, 17, 0, 167, 168, 5, 87, 0, 0, 168, 209, 1, 0, 0,
		0, 169, 170, 5, 15, 0, 0, 170, 173, 5, 87, 0, 0, 171, 174, 5, 3, 0, 0,
		172, 174, 3, 34, 17, 0, 173, 171, 1, 0, 0, 0, 173, 172, 1, 0, 0, 0, 174,
		175, 1, 0, 0, 0, 175, 209, 5, 87, 0, 0, 176, 177, 5, 16, 0, 0, 177, 178,
		5, 87, 0, 0, 178, 179, 3, 34, 17, 0, 179, 180, 5, 87, 0, 0, 180, 209, 1,
		0, 0, 0, 181, 182, 5, 17, 0, 0, 182, 189, 3, 48, 24, 0, 183, 185, 5, 62,
		0, 0, 184, 186, 3, 52, 26, 0, 185, 184, 1, 0, 0, 0, 186, 187, 1, 0, 0,
		0, 187, 185, 1, 0, 0, 0, 187, 188, 1, 0, 0, 0, 188, 190, 1, 0, 0, 0, 189,
		183, 1, 0, 0, 0, 189, 190, 1, 0, 0, 0, 190, 192, 1, 0, 0, 0, 191, 193,
		5, 87, 0, 0, 192, 191, 1, 0, 0, 0, 192, 193, 1, 0, 0, 0, 193, 209, 1, 0,
		0, 0, 194, 195, 5, 18, 0, 0, 195, 196, 5, 87, 0, 0, 196, 197, 3, 34, 17,
		0, 197, 198, 5, 87, 0, 0, 198, 209, 1, 0, 0, 0, 199, 200, 3, 36, 18, 0,
		200, 204, 5, 87, 0, 0, 201, 205, 5, 3, 0, 0, 202, 205, 5, 4, 0, 0, 203,
		205, 3, 34, 17, 0, 204, 201, 1, 0, 0, 0, 204, 202, 1, 0, 0, 0, 204, 203,
		1, 0, 0, 0, 204, 205, 1, 0, 0, 0, 205, 206, 1, 0, 0, 0, 206, 207, 5, 87,
		0, 0, 207, 209, 1, 0, 0, 0, 208, 136, 1, 0, 0, 0, 208, 146, 1, 0, 0, 0,
		208, 151, 1, 0, 0, 0, 208, 159, 1, 0, 0, 0, 208, 164, 1, 0, 0, 0, 208,
		169, 1, 0, 0, 0, 208, 176, 1, 0, 0, 0, 208, 181, 1, 0, 0, 0, 208, 194,
		1, 0, 0, 0, 208, 199, 1, 0, 0, 0, 209, 5, 1, 0, 0, 0, 210, 215, 5, 8, 0,
		0, 211, 214, 3, 8, 4, 0, 212, 214, 3, 10, 5, 0, 213, 211, 1, 0, 0, 0, 213,
		212, 1, 0, 0, 0, 214, 217, 1, 0, 0, 0, 215, 213, 1, 0, 0, 0, 215, 216,
		1, 0, 0, 0, 216, 7, 1, 0, 0, 0, 217, 215, 1, 0, 0, 0, 218, 219, 3, 12,
		6, 0, 219, 222, 3, 34, 17, 0, 220, 223, 3, 14, 7, 0, 221, 223, 3, 20, 10,
		0, 222, 220, 1, 0, 0, 0, 222, 221, 1, 0, 0, 0, 222, 223, 1, 0, 0, 0, 223,
		225, 1, 0, 0, 0, 224, 226, 3, 22, 11, 0, 225, 224, 1, 0, 0, 0, 225, 226,
		1, 0, 0, 0, 226, 227, 1, 0, 0, 0, 227, 228, 5, 87, 0, 0, 228, 9, 1, 0,
		0, 0, 229, 230, 5, 17, 0, 0, 230, 237, 3, 48, 24, 0, 231, 233, 5, 62, 0,
		0, 232, 234, 3, 52, 26, 0, 233, 232, 1, 0, 0, 0, 234, 235, 1, 0, 0, 0,
		235, 233, 1, 0, 0, 0, 235, 236, 1, 0, 0, 0, 236, 238, 1, 0, 0, 0, 237,
		231, 1, 0, 0, 0, 237, 238, 1, 0, 0, 0, 238, 239, 1, 0, 0, 0, 239, 240,
		5, 87, 0, 0, 240, 11, 1, 0, 0, 0, 241, 242, 5, 2, 0, 0, 242, 13, 1, 0,
		0, 0, 243, 244, 5, 19, 0, 0, 244, 245, 5, 20, 0, 0, 245, 246, 3, 16, 8,
		0, 246, 15, 1, 0, 0, 0, 247, 249, 3, 18, 9, 0, 248, 247, 1, 0, 0, 0, 249,
		250, 1, 0, 0, 0, 250, 248, 1, 0, 0, 0, 250, 251, 1, 0, 0, 0, 251, 17, 1,
		0, 0, 0, 252, 256, 7, 0, 0, 0, 253, 254, 5, 88, 0, 0, 254, 255, 5, 2, 0,
		0, 255, 257, 5, 89, 0, 0, 256, 253, 1, 0, 0, 0, 256, 257, 1, 0, 0, 0, 257,
		262, 1, 0, 0, 0, 258, 259, 5, 88, 0, 0, 259, 260, 7, 1, 0, 0, 260, 262,
		5, 89, 0, 0, 261, 252, 1, 0, 0, 0, 261, 258, 1, 0, 0, 0, 262, 19, 1, 0,
		0, 0, 263, 264, 5, 21, 0, 0, 264, 269, 3, 112, 56, 0, 265, 266, 5, 54,
		0, 0, 266, 268, 3, 112, 56, 0, 267, 265, 1, 0, 0, 0, 268, 271, 1, 0, 0,
		0, 269, 267, 1, 0, 0, 0, 269, 270, 1, 0, 0, 0, 270, 21, 1, 0, 0, 0, 271,
		269, 1, 0, 0, 0, 272, 273, 5, 22, 0, 0, 273, 275, 5, 2, 0, 0, 274, 276,
		5, 72, 0, 0, 275, 274, 1, 0, 0, 0, 275, 276, 1, 0, 0, 0, 276, 23, 1, 0,
		0, 0, 277, 280, 5, 9, 0, 0, 278, 279, 5, 76, 0, 0, 279, 281, 3, 26, 13,
		0, 280, 278, 1, 0, 0, 0, 280, 281, 1, 0, 0, 0, 281, 282, 1, 0, 0, 0, 282,
		287, 5, 87, 0, 0, 283, 286, 3, 28, 14, 0, 284, 286, 3, 30, 15, 0, 285,
		283, 1, 0, 0, 0, 285, 284, 1, 0, 0, 0, 286, 289, 1, 0, 0, 0, 287, 285,
		1, 0, 0, 0, 287, 288, 1, 0, 0, 0, 288, 25, 1, 0, 0, 0, 289, 287, 1, 0,
		0, 0, 290, 291, 5, 28, 0, 0, 291, 292, 7, 2, 0, 0, 292, 294, 3, 116, 58,
		0, 293, 290, 1, 0, 0, 0, 294, 295, 1, 0, 0, 0, 295, 293, 1, 0, 0, 0, 295,
		296, 1, 0, 0, 0, 296, 27, 1, 0, 0, 0, 297, 298, 3, 34, 17, 0, 298, 302,
		5, 87, 0, 0, 299, 301, 3, 30, 15, 0, 300, 299, 1, 0, 0, 0, 301, 304, 1,
		0, 0, 0, 302, 300, 1, 0, 0, 0, 302, 303, 1, 0, 0, 0, 303, 29, 1, 0, 0,
		0, 304, 302, 1, 0, 0, 0, 305, 307, 3, 32, 16, 0, 306, 305, 1, 0, 0, 0,
		307, 308, 1, 0, 0, 0, 308, 306, 1, 0, 0, 0, 308, 309, 1, 0, 0, 0, 309,
		310, 1, 0, 0, 0, 310, 314, 5, 87, 0, 0, 311, 313, 5, 87, 0, 0, 312, 311,
		1, 0, 0, 0, 313, 316, 1, 0, 0, 0, 314, 312, 1, 0, 0, 0, 314, 315, 1, 0,
		0, 0, 315, 31, 1, 0, 0, 0, 316, 314, 1, 0, 0, 0, 317, 338, 3, 40, 20, 0,
		318, 338, 3, 42, 21, 0, 319, 338, 3, 92, 46, 0, 320, 338, 3, 82, 41, 0,
		321, 338, 3, 66, 33, 0, 322, 338, 3, 80, 40, 0, 323, 338, 3, 64, 32, 0,
		324, 338, 3, 68, 34, 0, 325, 338, 3, 74, 37, 0, 326, 338, 3, 76, 38, 0,
		327, 338, 3, 86, 43, 0, 328, 338, 3, 84, 42, 0, 329, 338, 3, 72, 36, 0,
		330, 338, 3, 46, 23, 0, 331, 338, 3, 50, 25, 0, 332, 338, 3, 88, 44, 0,
		333, 338, 3, 90, 45, 0, 334, 338, 3, 44, 22, 0, 335, 338, 3, 98, 49, 0,
		336, 338, 5, 16, 0, 0, 337, 317, 1, 0, 0, 0, 337, 318, 1, 0, 0, 0, 337,
		319, 1, 0, 0, 0, 337, 320, 1, 0, 0, 0, 337, 321, 1, 0, 0, 0, 337, 322,
		1, 0, 0, 0, 337, 323, 1, 0, 0, 0, 337, 324, 1, 0, 0, 0, 337, 325, 1, 0,
		0, 0, 337, 326, 1, 0, 0, 0, 337, 327, 1, 0, 0, 0, 337, 328, 1, 0, 0, 0,
		337, 329, 1, 0, 0, 0, 337, 330, 1, 0, 0, 0, 337, 331, 1, 0, 0, 0, 337,
		332, 1, 0, 0, 0, 337, 333, 1, 0, 0, 0, 337, 334, 1, 0, 0, 0, 337, 335,
		1, 0, 0, 0, 337, 336, 1, 0, 0, 0, 338, 33, 1, 0, 0, 0, 339, 342, 3, 36,
		18, 0, 340, 341, 5, 54, 0, 0, 341, 343, 3, 36, 18, 0, 342, 340, 1, 0, 0,
		0, 343, 344, 1, 0, 0, 0, 344, 342, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345,
		348, 1, 0, 0, 0, 346, 348, 3, 36, 18, 0, 347, 339, 1, 0, 0, 0, 347, 346,
		1, 0, 0, 0, 348, 35, 1, 0, 0, 0, 349, 350, 7, 3, 0, 0, 350, 37, 1, 0, 0,
		0, 351, 354, 3, 104, 52, 0, 352, 354, 3, 106, 53, 0, 353, 351, 1, 0, 0,
		0, 353, 352, 1, 0, 0, 0, 354, 39, 1, 0, 0, 0, 355, 357, 5, 23, 0, 0, 356,
		358, 3, 104, 52, 0, 357, 356, 1, 0, 0, 0, 357, 358, 1, 0, 0, 0, 358, 41,
		1, 0, 0, 0, 359, 360, 5, 24, 0, 0, 360, 361, 3, 104, 52, 0, 361, 362, 5,
		73, 0, 0, 362, 366, 3, 104, 52, 0, 363, 365, 3, 70, 35, 0, 364, 363, 1,
		0, 0, 0, 365, 368, 1, 0, 0, 0, 366, 364, 1, 0, 0, 0, 366, 367, 1, 0, 0,
		0, 367, 43, 1, 0, 0, 0, 368, 366, 1, 0, 0, 0, 369, 370, 5, 26, 0, 0, 370,
		371, 3, 34, 17, 0, 371, 372, 5, 73, 0, 0, 372, 373, 5, 59, 0, 0, 373, 374,
		5, 73, 0, 0, 374, 375, 3, 34, 17, 0, 375, 45, 1, 0, 0, 0, 376, 377, 5,
		29, 0, 0, 377, 380, 3, 116, 58, 0, 378, 379, 5, 76, 0, 0, 379, 381, 3,
		26, 13, 0, 380, 378, 1, 0, 0, 0, 380, 381, 1, 0, 0, 0, 381, 47, 1, 0, 0,
		0, 382, 385, 5, 103, 0, 0, 383, 385, 3, 36, 18, 0, 384, 382, 1, 0, 0, 0,
		384, 383, 1, 0, 0, 0, 385, 49, 1, 0, 0, 0, 386, 387, 5, 17, 0, 0, 387,
		394, 3, 48, 24, 0, 388, 390, 5, 62, 0, 0, 389, 391, 3, 52, 26, 0, 390,
		389, 1, 0, 0, 0, 391, 392, 1, 0, 0, 0, 392, 390, 1, 0, 0, 0, 392, 393,
		1, 0, 0, 0, 393, 395, 1, 0, 0, 0, 394, 388, 1, 0, 0, 0, 394, 395, 1, 0,
		0, 0, 395, 397, 1, 0, 0, 0, 396, 398, 3, 34, 17, 0, 397, 396, 1, 0, 0,
		0, 397, 398, 1, 0, 0, 0, 398, 51, 1, 0, 0, 0, 399, 400, 3, 54, 27, 0, 400,
		401, 5, 28, 0, 0, 401, 402, 3, 54, 27, 0, 402, 53, 1, 0, 0, 0, 403, 405,
		3, 56, 28, 0, 404, 406, 9, 0, 0, 0, 405, 404, 1, 0, 0, 0, 406, 407, 1,
		0, 0, 0, 407, 408, 1, 0, 0, 0, 407, 405, 1, 0, 0, 0, 408, 409, 1, 0, 0,
		0, 409, 410, 3, 56, 28, 0, 410, 55, 1, 0, 0, 0, 411, 412, 7, 4, 0, 0, 412,
		57, 1, 0, 0, 0, 413, 415, 3, 116, 58, 0, 414, 416, 3, 60, 30, 0, 415, 414,
		1, 0, 0, 0, 415, 416, 1, 0, 0, 0, 416, 59, 1, 0, 0, 0, 417, 418, 5, 31,
		0, 0, 418, 423, 3, 62, 31, 0, 419, 420, 5, 32, 0, 0, 420, 421, 5, 28, 0,
		0, 421, 423, 3, 62, 31, 0, 422, 417, 1, 0, 0, 0, 422, 419, 1, 0, 0, 0,
		423, 61, 1, 0, 0, 0, 424, 428, 3, 116, 58, 0, 425, 428, 5, 65, 0, 0, 426,
		428, 5, 66, 0, 0, 427, 424, 1, 0, 0, 0, 427, 425, 1, 0, 0, 0, 427, 426,
		1, 0, 0, 0, 428, 63, 1, 0, 0, 0, 429, 431, 5, 33, 0, 0, 430, 432, 3, 58,
		29, 0, 431, 430, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 431, 1, 0, 0, 0,
		433, 434, 1, 0, 0, 0, 434, 439, 1, 0, 0, 0, 435, 440, 5, 81, 0, 0, 436,
		437, 5, 82, 0, 0, 437, 438, 5, 83, 0, 0, 438, 440, 5, 84, 0, 0, 439, 435,
		1, 0, 0, 0, 439, 436, 1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 444, 1, 0,
		0, 0, 441, 443, 3, 58, 29, 0, 442, 441, 1, 0, 0, 0, 443, 446, 1, 0, 0,
		0, 444, 442, 1, 0, 0, 0, 444, 445, 1, 0, 0, 0, 445, 65, 1, 0, 0, 0, 446,
		444, 1, 0, 0, 0, 447, 448, 5, 34, 0, 0, 448, 449, 3, 104, 52, 0, 449, 450,
		5, 47, 0, 0, 450, 454, 3, 104, 52, 0, 451, 453, 3, 70, 35, 0, 452, 451,
		1, 0, 0, 0, 453, 456, 1, 0, 0, 0, 454, 452, 1, 0, 0, 0, 454, 455, 1, 0,
		0, 0, 455, 459, 1, 0, 0, 0, 456, 454, 1, 0, 0, 0, 457, 458, 5, 61, 0, 0,
		458, 460, 3, 104, 52, 0, 459, 457, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460,
		67, 1, 0, 0, 0, 461, 463, 5, 41, 0, 0, 462, 464, 3, 38, 19, 0, 463, 462,
		1, 0, 0, 0, 463, 464, 1, 0, 0, 0, 464, 469, 1, 0, 0, 0, 465, 466, 5, 25,
		0, 0, 466, 468, 3, 38, 19, 0, 467, 465, 1, 0, 0, 0, 468, 471, 1, 0, 0,
		0, 469, 467, 1, 0, 0, 0, 469, 470, 1, 0, 0, 0, 470, 473, 1, 0, 0, 0, 471,
		469, 1, 0, 0, 0, 472, 474, 3, 100, 50, 0, 473, 472, 1, 0, 0, 0, 474, 475,
		1, 0, 0, 0, 475, 473, 1, 0, 0, 0, 475, 476, 1, 0, 0, 0, 476, 482, 1, 0,
		0, 0, 477, 483, 5, 38, 0, 0, 478, 480, 5, 36, 0, 0, 479, 481, 3, 34, 17,
		0, 480, 479, 1, 0, 0, 0, 480, 481, 1, 0, 0, 0, 481, 483, 1, 0, 0, 0, 482,
		477, 1, 0, 0, 0, 482, 478, 1, 0, 0, 0, 483, 69, 1, 0, 0, 0, 484, 485, 5,
		44, 0, 0, 485, 486, 3, 104, 52, 0, 486, 71, 1, 0, 0, 0, 487, 488, 5, 45,
		0, 0, 488, 489, 5, 73, 0, 0, 489, 490, 3, 104, 52, 0, 490, 73, 1, 0, 0,
		0, 491, 492, 5, 46, 0, 0, 492, 493, 3, 106, 53, 0, 493, 495, 5, 70, 0,
		0, 494, 496, 3, 32, 16, 0, 495, 494, 1, 0, 0, 0, 496, 497, 1, 0, 0, 0,
		497, 495, 1, 0, 0, 0, 497, 498, 1, 0, 0, 0, 498, 505, 1, 0, 0, 0, 499,
		501, 5, 35, 0, 0, 500, 502, 3, 32, 16, 0, 501, 500, 1, 0, 0, 0, 502, 503,
		1, 0, 0, 0, 503, 501, 1, 0, 0, 0, 503, 504, 1, 0, 0, 0, 504, 506, 1, 0,
		0, 0, 505, 499, 1, 0, 0, 0, 505, 506, 1, 0, 0, 0, 506, 508, 1, 0, 0, 0,
		507, 509, 7, 5, 0, 0, 508, 507, 1, 0, 0, 0, 508, 509, 1, 0, 0, 0, 509,
		75, 1, 0, 0, 0, 510, 515, 5, 48, 0, 0, 511, 514, 3, 78, 39, 0, 512, 514,
		3, 32, 16, 0, 513, 511, 1, 0, 0, 0, 513, 512, 1, 0, 0, 0, 514, 517, 1,
		0, 0, 0, 515, 513, 1, 0, 0, 0, 515, 516, 1, 0, 0, 0, 516, 518, 1, 0, 0,
		0, 517, 515, 1, 0, 0, 0, 518, 520, 5, 36, 0, 0, 519, 521, 3, 34, 17, 0,
		520, 519, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0, 521, 77, 1, 0, 0, 0, 522, 526,
		3, 96, 48, 0, 523, 526, 3, 102, 51, 0, 524, 526, 3, 94, 47, 0, 525, 522,
		1, 0, 0, 0, 525, 523, 1, 0, 0, 0, 525, 524, 1, 0, 0, 0, 526, 79, 1, 0,
		0, 0, 527, 528, 5, 50, 0, 0, 528, 529, 3, 104, 52, 0, 529, 530, 5, 73,
		0, 0, 530, 531, 3, 104, 52, 0, 531, 81, 1, 0, 0, 0, 532, 533, 5, 51, 0,
		0, 533, 534, 3, 104, 52, 0, 534, 535, 5, 28, 0, 0, 535, 539, 3, 104, 52,
		0, 536, 538, 3, 70, 35, 0, 537, 536, 1, 0, 0, 0, 538, 541, 1, 0, 0, 0,
		539, 537, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 83, 1, 0, 0, 0, 541, 539,
		1, 0, 0, 0, 542, 544, 5, 52, 0, 0, 543, 545, 3, 34, 17, 0, 544, 543, 1,
		0, 0, 0, 544, 545, 1, 0, 0, 0, 545, 85, 1, 0, 0, 0, 546, 547, 5, 58, 0,
		0, 547, 550, 3, 116, 58, 0, 548, 549, 5, 71, 0, 0, 549, 551, 3, 116, 58,
		0, 550, 548, 1, 0, 0, 0, 550, 551, 1, 0, 0, 0, 551, 555, 1, 0, 0, 0, 552,
		553, 3, 116, 58, 0, 553, 554, 5, 72, 0, 0, 554, 556, 1, 0, 0, 0, 555, 552,
		1, 0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 562, 1, 0, 0, 0, 557, 558, 5, 58,
		0, 0, 558, 559, 3, 104, 52, 0, 559, 560, 5, 72, 0, 0, 560, 562, 1, 0, 0,
		0, 561, 546, 1, 0, 0, 0, 561, 557, 1, 0, 0, 0, 562, 87, 1, 0, 0, 0, 563,
		564, 5, 64, 0, 0, 564, 565, 5, 37, 0, 0, 565, 566, 5, 55, 0, 0, 566, 568,
		5, 40, 0, 0, 567, 569, 3, 34, 17, 0, 568, 567, 1, 0, 0, 0, 568, 569, 1,
		0, 0, 0, 569, 580, 1, 0, 0, 0, 570, 571, 5, 64, 0, 0, 571, 577, 3, 116,
		58, 0, 572, 573, 5, 55, 0, 0, 573, 575, 5, 40, 0, 0, 574, 576, 3, 34, 17,
		0, 575, 574, 1, 0, 0, 0, 575, 576, 1, 0, 0, 0, 576, 578, 1, 0, 0, 0, 577,
		572, 1, 0, 0, 0, 577, 578, 1, 0, 0, 0, 578, 580, 1, 0, 0, 0, 579, 563,
		1, 0, 0, 0, 579, 570, 1, 0, 0, 0, 580, 89, 1, 0, 0, 0, 581, 584, 5, 68,
		0, 0, 582, 585, 5, 63, 0, 0, 583, 585, 3, 34, 17, 0, 584, 582, 1, 0, 0,
		0, 584, 583, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 91, 1, 0, 0, 0, 586,
		587, 5, 69, 0, 0, 587, 588, 3, 104, 52, 0, 588, 589, 5, 43, 0, 0, 589,
		593, 3, 104, 52, 0, 590, 592, 3, 70, 35, 0, 591, 590, 1, 0, 0, 0, 592,
		595, 1, 0, 0, 0, 593, 591, 1, 0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 93, 1,
		0, 0, 0, 595, 593, 1, 0, 0, 0, 596, 597, 5, 75, 0, 0, 597, 598, 3, 106,
		53, 0, 598, 95, 1, 0, 0, 0, 599, 602, 5, 78, 0, 0, 600, 603, 3, 114, 57,
		0, 601, 603, 3, 112, 56, 0, 602, 600, 1, 0, 0, 0, 602, 601, 1, 0, 0, 0,
		602, 603, 1, 0, 0, 0, 603, 606, 1, 0, 0, 0, 604, 605, 5, 43, 0, 0, 605,
		607, 3, 116, 58, 0, 606, 604, 1, 0, 0, 0, 606, 607, 1, 0, 0, 0, 607, 610,
		1, 0, 0, 0, 608, 609, 5, 73, 0, 0, 609, 611, 3, 116, 58, 0, 610, 608, 1,
		0, 0, 0, 610, 611, 1, 0, 0, 0, 611, 614, 1, 0, 0, 0, 612, 613, 5, 28, 0,
		0, 613, 615, 3, 116, 58, 0, 614, 612, 1, 0, 0, 0, 614, 615, 1, 0, 0, 0,
		615, 97, 1, 0, 0, 0, 616, 619, 3, 96, 48, 0, 617, 619, 5, 78, 0, 0, 618,
		616, 1, 0, 0, 0, 618, 617, 1, 0, 0, 0, 619, 99, 1, 0, 0, 0, 620, 621, 5,
		79, 0, 0, 621, 623, 5, 57, 0, 0, 622, 624, 3, 32, 16, 0, 623, 622, 1, 0,
		0, 0, 624, 625, 1, 0, 0, 0, 625, 623, 1, 0, 0, 0, 625, 626, 1, 0, 0, 0,
		626, 653, 1, 0, 0, 0, 627, 628, 5, 79, 0, 0, 628, 631, 3, 38, 19, 0, 629,
		630, 5, 71, 0, 0, 630, 632, 3, 38, 19, 0, 631, 629, 1, 0, 0, 0, 631, 632,
		1, 0, 0, 0, 632, 641, 1, 0, 0, 0, 633, 634, 5, 25, 0, 0, 634, 637, 3, 38,
		19, 0, 635, 636, 5, 71, 0, 0, 636, 638, 3, 38, 19, 0, 637, 635, 1, 0, 0,
		0, 637, 638, 1, 0, 0, 0, 638, 640, 1, 0, 0, 0, 639, 633, 1, 0, 0, 0, 640,
		643, 1, 0, 0, 0, 641, 639, 1, 0, 0, 0, 641, 642, 1, 0, 0, 0, 642, 645,
		1, 0, 0, 0, 643, 641, 1, 0, 0, 0, 644, 646, 5, 25, 0, 0, 645, 644, 1, 0,
		0, 0, 645, 646, 1, 0, 0, 0, 646, 648, 1, 0, 0, 0, 647, 649, 3, 32, 16,
		0, 648, 647, 1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 648, 1, 0, 0, 0, 650,
		651, 1, 0, 0, 0, 651, 653, 1, 0, 0, 0, 652, 620, 1, 0, 0, 0, 652, 627,
		1, 0, 0, 0, 653, 101, 1, 0, 0, 0, 654, 655, 5, 80, 0, 0, 655, 656, 3, 106,
		53, 0, 656, 103, 1, 0, 0, 0, 657, 664, 3, 116, 58, 0, 658, 660, 5, 86,
		0, 0, 659, 658, 1, 0, 0, 0, 659, 660, 1, 0, 0, 0, 660, 661, 1, 0, 0, 0,
		661, 663, 3, 116, 58, 0, 662, 659, 1, 0, 0, 0, 663, 666, 1, 0, 0, 0, 664,
		662, 1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 105, 1, 0, 0, 0, 666, 664,
		1, 0, 0, 0, 667, 672, 3, 108, 54, 0, 668, 669, 7, 6, 0, 0, 669, 671, 3,
		108, 54, 0, 670, 668, 1, 0, 0, 0, 671, 674, 1, 0, 0, 0, 672, 670, 1, 0,
		0, 0, 672, 673, 1, 0, 0, 0, 673, 107, 1, 0, 0, 0, 674, 672, 1, 0, 0, 0,
		675, 676, 5, 88, 0, 0, 676, 677, 3, 106, 53, 0, 677, 678, 5, 89, 0, 0,
		678, 698, 1, 0, 0, 0, 679, 681, 5, 53, 0, 0, 680, 679, 1, 0, 0, 0, 680,
		681, 1, 0, 0, 0, 681, 682, 1, 0, 0, 0, 682, 683, 3, 116, 58, 0, 683, 684,
		3, 110, 55, 0, 684, 685, 3, 116, 58, 0, 685, 698, 1, 0, 0, 0, 686, 688,
		5, 53, 0, 0, 687, 686, 1, 0, 0, 0, 687, 688, 1, 0, 0, 0, 688, 689, 1, 0,
		0, 0, 689, 690, 3, 110, 55, 0, 690, 691, 3, 116, 58, 0, 691, 698, 1, 0,
		0, 0, 692, 694, 5, 53, 0, 0, 693, 692, 1, 0, 0, 0, 693, 694, 1, 0, 0, 0,
		694, 695, 1, 0, 0, 0, 695, 698, 3, 116, 58, 0, 696, 698, 3, 116, 58, 0,
		697, 675, 1, 0, 0, 0, 697, 680, 1, 0, 0, 0, 697, 687, 1, 0, 0, 0, 697,
		693, 1, 0, 0, 0, 697, 696, 1, 0, 0, 0, 698, 109, 1, 0, 0, 0, 699, 700,
		7, 7, 0, 0, 700, 111, 1, 0, 0, 0, 701, 708, 3, 36, 18, 0, 702, 703, 5,
		88, 0, 0, 703, 704, 3, 116, 58, 0, 704, 705, 5, 89, 0, 0, 705, 707, 1,
		0, 0, 0, 706, 702, 1, 0, 0, 0, 707, 710, 1, 0, 0, 0, 708, 706, 1, 0, 0,
		0, 708, 709, 1, 0, 0, 0, 709, 113, 1, 0, 0, 0, 710, 708, 1, 0, 0, 0, 711,
		714, 3, 112, 56, 0, 712, 713, 5, 54, 0, 0, 713, 715, 3, 112, 56, 0, 714,
		712, 1, 0, 0, 0, 715, 716, 1, 0, 0, 0, 716, 714, 1, 0, 0, 0, 716, 717,
		1, 0, 0, 0, 717, 115, 1, 0, 0, 0, 718, 719, 6, 58, -1, 0, 719, 720, 5,
		90, 0, 0, 720, 731, 3, 116, 58, 9, 721, 722, 5, 91, 0, 0, 722, 731, 3,
		116, 58, 8, 723, 724, 5, 88, 0, 0, 724, 725, 3, 116, 58, 0, 725, 726, 5,
		89, 0, 0, 726, 731, 1, 0, 0, 0, 727, 731, 3, 118, 59, 0, 728, 731, 3, 114,
		57, 0, 729, 731, 3, 112, 56, 0, 730, 718, 1, 0, 0, 0, 730, 721, 1, 0, 0,
		0, 730, 723, 1, 0, 0, 0, 730, 727, 1, 0, 0, 0, 730, 728, 1, 0, 0, 0, 730,
		729, 1, 0, 0, 0, 731, 743, 1, 0, 0, 0, 732, 733, 10, 7, 0, 0, 733, 734,
		5, 94, 0, 0, 734, 742, 3, 116, 58, 8, 735, 736, 10, 6, 0, 0, 736, 737,
		7, 8, 0, 0, 737, 742, 3, 116, 58, 7, 738, 739, 10, 5, 0, 0, 739, 740, 7,
		9, 0, 0, 740, 742, 3, 116, 58, 6, 741, 732, 1, 0, 0, 0, 741, 735, 1, 0,
		0, 0, 741, 738, 1, 0, 0, 0, 742, 745, 1, 0, 0, 0, 743, 741, 1, 0, 0, 0,
		743, 744, 1, 0, 0, 0, 744, 117, 1, 0, 0, 0, 745, 743, 1, 0, 0, 0, 746,
		747, 7, 10, 0, 0, 747, 119, 1, 0, 0, 0, 97, 122, 125, 133, 143, 156, 173,
		187, 189, 192, 204, 208, 213, 215, 222, 225, 235, 237, 250, 256, 261, 269,
		275, 280, 285, 287, 295, 302, 308, 314, 337, 344, 347, 353, 357, 366, 380,
		384, 392, 394, 397, 407, 415, 422, 427, 433, 439, 444, 454, 459, 463, 469,
		475, 480, 482, 497, 503, 505, 508, 513, 515, 520, 525, 539, 544, 550, 555,
		561, 568, 575, 577, 579, 584, 593, 602, 606, 610, 614, 618, 625, 631, 637,
		641, 645, 650, 652, 659, 664, 672, 680, 687, 693, 697, 708, 716, 730, 741,
		743,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// bbyCBLParserInit initializes any static state used to implement bbyCBLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewbbyCBLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func BbyCBLParserInit() {
	staticData := &BbyCBLParserStaticData
	staticData.once.Do(bbycblParserInit)
}

// NewbbyCBLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewbbyCBLParser(input antlr.TokenStream) *bbyCBLParser {
	BbyCBLParserInit()
	this := new(bbyCBLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &BbyCBLParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "bbyCBL.g4"

	return this
}

// bbyCBLParser tokens.
const (
	bbyCBLParserEOF                     = antlr.TokenEOF
	bbyCBLParserFLOAT                   = 1
	bbyCBLParserNUMBER                  = 2
	bbyCBLParserDATE                    = 3
	bbyCBLParserDATE_UNDERSCORE         = 4
	bbyCBLParserANY_DATE                = 5
	bbyCBLParserANY_DATE_UNDERSCORE     = 6
	bbyCBLParserIDENTIFICATION_DIVISION = 7
	bbyCBLParserDATA_DIVISION           = 8
	bbyCBLParserPROCEDURE_DIVISION      = 9
	bbyCBLParserPROGRAM_ID              = 10
	bbyCBLParserAUTHOR                  = 11
	bbyCBLParserDATE_WRITTEN            = 12
	bbyCBLParserINSTALLATION            = 13
	bbyCBLParserSECURITY                = 14
	bbyCBLParserDATE_COMPILED           = 15
	bbyCBLParserBASE                    = 16
	bbyCBLParserCOPY                    = 17
	bbyCBLParserDESCRIPTION             = 18
	bbyCBLParserPICTURE                 = 19
	bbyCBLParserIS                      = 20
	bbyCBLParserLIKE                    = 21
	bbyCBLParserOCCURS                  = 22
	bbyCBLParserACCEPT                  = 23
	bbyCBLParserADD                     = 24
	bbyCBLParserALSO                    = 25
	bbyCBLParserALTER                   = 26
	bbyCBLParserAND                     = 27
	bbyCBLParserBY                      = 28
	bbyCBLParserCALL                    = 29
	bbyCBLParserCONTENT                 = 30
	bbyCBLParserDELIMITED_BY            = 31
	bbyCBLParserDELIMITED               = 32
	bbyCBLParserDISPLAY                 = 33
	bbyCBLParserDIVIDE                  = 34
	bbyCBLParserELSE                    = 35
	bbyCBLParserEND                     = 36
	bbyCBLParserOFF                     = 37
	bbyCBLParserEND_EVALUATE            = 38
	bbyCBLParserEND_IF                  = 39
	bbyCBLParserERROR                   = 40
	bbyCBLParserEVALUATE                = 41
	bbyCBLParserFALSE                   = 42
	bbyCBLParserFROM                    = 43
	bbyCBLParserGIVING                  = 44
	bbyCBLParserGO                      = 45
	bbyCBLParserIF                      = 46
	bbyCBLParserINTO                    = 47
	bbyCBLParserLOOP                    = 48
	bbyCBLParserLOW_VALUES              = 49
	bbyCBLParserMOVE                    = 50
	bbyCBLParserMULTIPLY                = 51
	bbyCBLParserNEXT_SENTENCE           = 52
	bbyCBLParserNOT                     = 53
	bbyCBLParserOF                      = 54
	bbyCBLParserON                      = 55
	bbyCBLParserOR                      = 56
	bbyCBLParserOTHER                   = 57
	bbyCBLParserPERFORM                 = 58
	bbyCBLParserPROCEED                 = 59
	bbyCBLParserREFERENCE               = 60
	bbyCBLParserREMAINDER               = 61
	bbyCBLParserREPLACING               = 62
	bbyCBLParserRUN                     = 63
	bbyCBLParserSIGNAL                  = 64
	bbyCBLParserSIZE                    = 65
	bbyCBLParserSPACE                   = 66
	bbyCBLParserSPACES                  = 67
	bbyCBLParserSTOP                    = 68
	bbyCBLParserSUBTRACT                = 69
	bbyCBLParserTHEN                    = 70
	bbyCBLParserTHROUGH                 = 71
	bbyCBLParserTIMES                   = 72
	bbyCBLParserTO                      = 73
	bbyCBLParserTRUE                    = 74
	bbyCBLParserUNTIL                   = 75
	bbyCBLParserUSING                   = 76
	bbyCBLParserVALUE                   = 77
	bbyCBLParserVARYING                 = 78
	bbyCBLParserWHEN                    = 79
	bbyCBLParserWHILE                   = 80
	bbyCBLParserWITH_NO_ADVANCING       = 81
	bbyCBLParserWITH                    = 82
	bbyCBLParserNO                      = 83
	bbyCBLParserADVANCING               = 84
	bbyCBLParserXOR                     = 85
	bbyCBLParserCOMMA                   = 86
	bbyCBLParserDOT                     = 87
	bbyCBLParserLPAREN                  = 88
	bbyCBLParserRPAREN                  = 89
	bbyCBLParserPLUS                    = 90
	bbyCBLParserMINUS                   = 91
	bbyCBLParserMULT                    = 92
	bbyCBLParserDIV                     = 93
	bbyCBLParserPOW                     = 94
	bbyCBLParserEQ                      = 95
	bbyCBLParserNE                      = 96
	bbyCBLParserLE                      = 97
	bbyCBLParserGE                      = 98
	bbyCBLParserLT                      = 99
	bbyCBLParserGT                      = 100
	bbyCBLParserTRIPLE_EQUAL            = 101
	bbyCBLParserDOUBLE_EQUAL            = 102
	bbyCBLParserSTRING                  = 103
	bbyCBLParserHIGH_VALUES             = 104
	bbyCBLParserIDENTIFIER              = 105
	bbyCBLParserWS                      = 106
)

// bbyCBLParser rules.
const (
	bbyCBLParserRULE_program                = 0
	bbyCBLParserRULE_identificationDivision = 1
	bbyCBLParserRULE_identificationClause   = 2
	bbyCBLParserRULE_dataDivision           = 3
	bbyCBLParserRULE_dataEntry              = 4
	bbyCBLParserRULE_dataCopyStmt           = 5
	bbyCBLParserRULE_levelNumber            = 6
	bbyCBLParserRULE_pictureClause          = 7
	bbyCBLParserRULE_picturePattern         = 8
	bbyCBLParserRULE_pictureElement         = 9
	bbyCBLParserRULE_likeClause             = 10
	bbyCBLParserRULE_occursClause           = 11
	bbyCBLParserRULE_procedureDivision      = 12
	bbyCBLParserRULE_usingClause            = 13
	bbyCBLParserRULE_paragraph              = 14
	bbyCBLParserRULE_sentence               = 15
	bbyCBLParserRULE_statement              = 16
	bbyCBLParserRULE_identifier             = 17
	bbyCBLParserRULE_simpleId               = 18
	bbyCBLParserRULE_evalSubject            = 19
	bbyCBLParserRULE_acceptStmt             = 20
	bbyCBLParserRULE_addStmt                = 21
	bbyCBLParserRULE_alterStmt              = 22
	bbyCBLParserRULE_callStmt               = 23
	bbyCBLParserRULE_copySource             = 24
	bbyCBLParserRULE_copyStmt               = 25
	bbyCBLParserRULE_replacePair            = 26
	bbyCBLParserRULE_replaceBlock           = 27
	bbyCBLParserRULE_equalDelim             = 28
	bbyCBLParserRULE_displayItem            = 29
	bbyCBLParserRULE_delimiterSpec          = 30
	bbyCBLParserRULE_valueSpec              = 31
	bbyCBLParserRULE_displayStmt            = 32
	bbyCBLParserRULE_divideStmt             = 33
	bbyCBLParserRULE_evaluateStmt           = 34
	bbyCBLParserRULE_givingClause           = 35
	bbyCBLParserRULE_gotoStmt               = 36
	bbyCBLParserRULE_ifStmt                 = 37
	bbyCBLParserRULE_loopStmt               = 38
	bbyCBLParserRULE_loopControl            = 39
	bbyCBLParserRULE_moveStmt               = 40
	bbyCBLParserRULE_multiplyStmt           = 41
	bbyCBLParserRULE_nextSentenceStmt       = 42
	bbyCBLParserRULE_performStmt            = 43
	bbyCBLParserRULE_signalStmt             = 44
	bbyCBLParserRULE_stopStmt               = 45
	bbyCBLParserRULE_subtractStmt           = 46
	bbyCBLParserRULE_untilClause            = 47
	bbyCBLParserRULE_varyingClause          = 48
	bbyCBLParserRULE_varyingStmt            = 49
	bbyCBLParserRULE_whenClause             = 50
	bbyCBLParserRULE_whileClause            = 51
	bbyCBLParserRULE_exprList               = 52
	bbyCBLParserRULE_condition              = 53
	bbyCBLParserRULE_simpleCond             = 54
	bbyCBLParserRULE_comparator             = 55
	bbyCBLParserRULE_identifierSegment      = 56
	bbyCBLParserRULE_qualifiedId            = 57
	bbyCBLParserRULE_expr                   = 58
	bbyCBLParserRULE_literal                = 59
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentificationDivision() IIdentificationDivisionContext
	EOF() antlr.TerminalNode
	DataDivision() IDataDivisionContext
	ProcedureDivision() IProcedureDivisionContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) IdentificationDivision() IIdentificationDivisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentificationDivisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentificationDivisionContext)
}

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEOF, 0)
}

func (s *ProgramContext) DataDivision() IDataDivisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDivisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDivisionContext)
}

func (s *ProgramContext) ProcedureDivision() IProcedureDivisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDivisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (p *bbyCBLParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, bbyCBLParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(120)
		p.IdentificationDivision()
	}
	p.SetState(122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserDATA_DIVISION {
		{
			p.SetState(121)
			p.DataDivision()
		}

	}
	p.SetState(125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserPROCEDURE_DIVISION {
		{
			p.SetState(124)
			p.ProcedureDivision()
		}

	}
	{
		p.SetState(127)
		p.Match(bbyCBLParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentificationDivisionContext is an interface to support dynamic dispatch.
type IIdentificationDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFICATION_DIVISION() antlr.TerminalNode
	AllIdentificationClause() []IIdentificationClauseContext
	IdentificationClause(i int) IIdentificationClauseContext

	// IsIdentificationDivisionContext differentiates from other interfaces.
	IsIdentificationDivisionContext()
}

type IdentificationDivisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentificationDivisionContext() *IdentificationDivisionContext {
	var p = new(IdentificationDivisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identificationDivision
	return p
}

func InitEmptyIdentificationDivisionContext(p *IdentificationDivisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identificationDivision
}

func (*IdentificationDivisionContext) IsIdentificationDivisionContext() {}

func NewIdentificationDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentificationDivisionContext {
	var p = new(IdentificationDivisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_identificationDivision

	return p
}

func (s *IdentificationDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentificationDivisionContext) IDENTIFICATION_DIVISION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserIDENTIFICATION_DIVISION, 0)
}

func (s *IdentificationDivisionContext) AllIdentificationClause() []IIdentificationClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentificationClauseContext); ok {
			len++
		}
	}

	tst := make([]IIdentificationClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentificationClauseContext); ok {
			tst[i] = t.(IIdentificationClauseContext)
			i++
		}
	}

	return tst
}

func (s *IdentificationDivisionContext) IdentificationClause(i int) IIdentificationClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentificationClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentificationClauseContext)
}

func (s *IdentificationDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentificationDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentificationDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterIdentificationDivision(s)
	}
}

func (s *IdentificationDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitIdentificationDivision(s)
	}
}

func (p *bbyCBLParser) IdentificationDivision() (localctx IIdentificationDivisionContext) {
	localctx = NewIdentificationDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, bbyCBLParserRULE_identificationDivision)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(129)
		p.Match(bbyCBLParserIDENTIFICATION_DIVISION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&19707758373239928) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&824633725335) != 0) {
		{
			p.SetState(130)
			p.IdentificationClause()
		}

		p.SetState(135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentificationClauseContext is an interface to support dynamic dispatch.
type IIdentificationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROGRAM_ID() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	DATE() antlr.TerminalNode
	DATE_UNDERSCORE() antlr.TerminalNode
	ANY_DATE() antlr.TerminalNode
	ANY_DATE_UNDERSCORE() antlr.TerminalNode
	AUTHOR() antlr.TerminalNode
	DATE_WRITTEN() antlr.TerminalNode
	INSTALLATION() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	DATE_COMPILED() antlr.TerminalNode
	BASE() antlr.TerminalNode
	COPY() antlr.TerminalNode
	CopySource() ICopySourceContext
	REPLACING() antlr.TerminalNode
	AllReplacePair() []IReplacePairContext
	ReplacePair(i int) IReplacePairContext
	DESCRIPTION() antlr.TerminalNode
	SimpleId() ISimpleIdContext

	// IsIdentificationClauseContext differentiates from other interfaces.
	IsIdentificationClauseContext()
}

type IdentificationClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentificationClauseContext() *IdentificationClauseContext {
	var p = new(IdentificationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identificationClause
	return p
}

func InitEmptyIdentificationClauseContext(p *IdentificationClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identificationClause
}

func (*IdentificationClauseContext) IsIdentificationClauseContext() {}

func NewIdentificationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentificationClauseContext {
	var p = new(IdentificationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_identificationClause

	return p
}

func (s *IdentificationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentificationClauseContext) PROGRAM_ID() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPROGRAM_ID, 0)
}

func (s *IdentificationClauseContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserDOT)
}

func (s *IdentificationClauseContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, i)
}

func (s *IdentificationClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentificationClauseContext) DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE, 0)
}

func (s *IdentificationClauseContext) DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_UNDERSCORE, 0)
}

func (s *IdentificationClauseContext) ANY_DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE, 0)
}

func (s *IdentificationClauseContext) ANY_DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE_UNDERSCORE, 0)
}

func (s *IdentificationClauseContext) AUTHOR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserAUTHOR, 0)
}

func (s *IdentificationClauseContext) DATE_WRITTEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_WRITTEN, 0)
}

func (s *IdentificationClauseContext) INSTALLATION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserINSTALLATION, 0)
}

func (s *IdentificationClauseContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSECURITY, 0)
}

func (s *IdentificationClauseContext) DATE_COMPILED() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_COMPILED, 0)
}

func (s *IdentificationClauseContext) BASE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBASE, 0)
}

func (s *IdentificationClauseContext) COPY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCOPY, 0)
}

func (s *IdentificationClauseContext) CopySource() ICopySourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopySourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopySourceContext)
}

func (s *IdentificationClauseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREPLACING, 0)
}

func (s *IdentificationClauseContext) AllReplacePair() []IReplacePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplacePairContext); ok {
			len++
		}
	}

	tst := make([]IReplacePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplacePairContext); ok {
			tst[i] = t.(IReplacePairContext)
			i++
		}
	}

	return tst
}

func (s *IdentificationClauseContext) ReplacePair(i int) IReplacePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePairContext)
}

func (s *IdentificationClauseContext) DESCRIPTION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDESCRIPTION, 0)
}

func (s *IdentificationClauseContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *IdentificationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentificationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentificationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterIdentificationClause(s)
	}
}

func (s *IdentificationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitIdentificationClause(s)
	}
}

func (p *bbyCBLParser) IdentificationClause() (localctx IIdentificationClauseContext) {
	localctx = NewIdentificationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, bbyCBLParserRULE_identificationClause)
	var _la int

	p.SetState(208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(136)
			p.Match(bbyCBLParserPROGRAM_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(137)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(143)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(138)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(139)
				p.Match(bbyCBLParserDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(140)
				p.Match(bbyCBLParserDATE_UNDERSCORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(141)
				p.Match(bbyCBLParserANY_DATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(142)
				p.Match(bbyCBLParserANY_DATE_UNDERSCORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(145)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(146)
			p.Match(bbyCBLParserAUTHOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(147)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(148)
			p.Identifier()
		}
		{
			p.SetState(149)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(151)
			p.Match(bbyCBLParserDATE_WRITTEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(152)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(153)
				p.Match(bbyCBLParserDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(154)
				p.Match(bbyCBLParserDATE_UNDERSCORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(155)
				p.Identifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(158)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(159)
			p.Match(bbyCBLParserINSTALLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(160)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(161)
			p.Identifier()
		}
		{
			p.SetState(162)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(164)
			p.Match(bbyCBLParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(165)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(166)
			p.Identifier()
		}
		{
			p.SetState(167)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(169)
			p.Match(bbyCBLParserDATE_COMPILED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(170)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(171)
				p.Match(bbyCBLParserDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(172)
				p.Identifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(175)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(176)
			p.Match(bbyCBLParserBASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(177)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(178)
			p.Identifier()
		}
		{
			p.SetState(179)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(181)
			p.Match(bbyCBLParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(182)
			p.CopySource()
		}
		p.SetState(189)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserREPLACING {
			{
				p.SetState(183)
				p.Match(bbyCBLParserREPLACING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(185)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == bbyCBLParserTRIPLE_EQUAL || _la == bbyCBLParserDOUBLE_EQUAL {
				{
					p.SetState(184)
					p.ReplacePair()
				}

				p.SetState(187)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserDOT {
			{
				p.SetState(191)
				p.Match(bbyCBLParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(194)
			p.Match(bbyCBLParserDESCRIPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(195)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(196)
			p.Identifier()
		}
		{
			p.SetState(197)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(199)
			p.SimpleId()
		}
		{
			p.SetState(200)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(204)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(201)
				p.Match(bbyCBLParserDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(202)
				p.Match(bbyCBLParserDATE_UNDERSCORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(203)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(206)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDivisionContext is an interface to support dynamic dispatch.
type IDataDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATA_DIVISION() antlr.TerminalNode
	AllDataEntry() []IDataEntryContext
	DataEntry(i int) IDataEntryContext
	AllDataCopyStmt() []IDataCopyStmtContext
	DataCopyStmt(i int) IDataCopyStmtContext

	// IsDataDivisionContext differentiates from other interfaces.
	IsDataDivisionContext()
}

type DataDivisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDivisionContext() *DataDivisionContext {
	var p = new(DataDivisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataDivision
	return p
}

func InitEmptyDataDivisionContext(p *DataDivisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataDivision
}

func (*DataDivisionContext) IsDataDivisionContext() {}

func NewDataDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDivisionContext {
	var p = new(DataDivisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_dataDivision

	return p
}

func (s *DataDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDivisionContext) DATA_DIVISION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATA_DIVISION, 0)
}

func (s *DataDivisionContext) AllDataEntry() []IDataEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataEntryContext); ok {
			len++
		}
	}

	tst := make([]IDataEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataEntryContext); ok {
			tst[i] = t.(IDataEntryContext)
			i++
		}
	}

	return tst
}

func (s *DataDivisionContext) DataEntry(i int) IDataEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataEntryContext)
}

func (s *DataDivisionContext) AllDataCopyStmt() []IDataCopyStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataCopyStmtContext); ok {
			len++
		}
	}

	tst := make([]IDataCopyStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataCopyStmtContext); ok {
			tst[i] = t.(IDataCopyStmtContext)
			i++
		}
	}

	return tst
}

func (s *DataDivisionContext) DataCopyStmt(i int) IDataCopyStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCopyStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCopyStmtContext)
}

func (s *DataDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDataDivision(s)
	}
}

func (s *DataDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDataDivision(s)
	}
}

func (p *bbyCBLParser) DataDivision() (localctx IDataDivisionContext) {
	localctx = NewDataDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, bbyCBLParserRULE_dataDivision)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(210)
		p.Match(bbyCBLParserDATA_DIVISION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserNUMBER || _la == bbyCBLParserCOPY {
		p.SetState(213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case bbyCBLParserNUMBER:
			{
				p.SetState(211)
				p.DataEntry()
			}

		case bbyCBLParserCOPY:
			{
				p.SetState(212)
				p.DataCopyStmt()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataEntryContext is an interface to support dynamic dispatch.
type IDataEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LevelNumber() ILevelNumberContext
	Identifier() IIdentifierContext
	DOT() antlr.TerminalNode
	PictureClause() IPictureClauseContext
	LikeClause() ILikeClauseContext
	OccursClause() IOccursClauseContext

	// IsDataEntryContext differentiates from other interfaces.
	IsDataEntryContext()
}

type DataEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataEntryContext() *DataEntryContext {
	var p = new(DataEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataEntry
	return p
}

func InitEmptyDataEntryContext(p *DataEntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataEntry
}

func (*DataEntryContext) IsDataEntryContext() {}

func NewDataEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataEntryContext {
	var p = new(DataEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_dataEntry

	return p
}

func (s *DataEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *DataEntryContext) LevelNumber() ILevelNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelNumberContext)
}

func (s *DataEntryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataEntryContext) DOT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, 0)
}

func (s *DataEntryContext) PictureClause() IPictureClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPictureClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPictureClauseContext)
}

func (s *DataEntryContext) LikeClause() ILikeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikeClauseContext)
}

func (s *DataEntryContext) OccursClause() IOccursClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOccursClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOccursClauseContext)
}

func (s *DataEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDataEntry(s)
	}
}

func (s *DataEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDataEntry(s)
	}
}

func (p *bbyCBLParser) DataEntry() (localctx IDataEntryContext) {
	localctx = NewDataEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, bbyCBLParserRULE_dataEntry)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(218)
		p.LevelNumber()
	}
	{
		p.SetState(219)
		p.Identifier()
	}
	p.SetState(222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserPICTURE:
		{
			p.SetState(220)
			p.PictureClause()
		}

	case bbyCBLParserLIKE:
		{
			p.SetState(221)
			p.LikeClause()
		}

	case bbyCBLParserOCCURS, bbyCBLParserDOT:

	default:
	}
	p.SetState(225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserOCCURS {
		{
			p.SetState(224)
			p.OccursClause()
		}

	}
	{
		p.SetState(227)
		p.Match(bbyCBLParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCopyStmtContext is an interface to support dynamic dispatch.
type IDataCopyStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COPY() antlr.TerminalNode
	CopySource() ICopySourceContext
	DOT() antlr.TerminalNode
	REPLACING() antlr.TerminalNode
	AllReplacePair() []IReplacePairContext
	ReplacePair(i int) IReplacePairContext

	// IsDataCopyStmtContext differentiates from other interfaces.
	IsDataCopyStmtContext()
}

type DataCopyStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCopyStmtContext() *DataCopyStmtContext {
	var p = new(DataCopyStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataCopyStmt
	return p
}

func InitEmptyDataCopyStmtContext(p *DataCopyStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_dataCopyStmt
}

func (*DataCopyStmtContext) IsDataCopyStmtContext() {}

func NewDataCopyStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCopyStmtContext {
	var p = new(DataCopyStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_dataCopyStmt

	return p
}

func (s *DataCopyStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCopyStmtContext) COPY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCOPY, 0)
}

func (s *DataCopyStmtContext) CopySource() ICopySourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopySourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopySourceContext)
}

func (s *DataCopyStmtContext) DOT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, 0)
}

func (s *DataCopyStmtContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREPLACING, 0)
}

func (s *DataCopyStmtContext) AllReplacePair() []IReplacePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplacePairContext); ok {
			len++
		}
	}

	tst := make([]IReplacePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplacePairContext); ok {
			tst[i] = t.(IReplacePairContext)
			i++
		}
	}

	return tst
}

func (s *DataCopyStmtContext) ReplacePair(i int) IReplacePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePairContext)
}

func (s *DataCopyStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCopyStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCopyStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDataCopyStmt(s)
	}
}

func (s *DataCopyStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDataCopyStmt(s)
	}
}

func (p *bbyCBLParser) DataCopyStmt() (localctx IDataCopyStmtContext) {
	localctx = NewDataCopyStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, bbyCBLParserRULE_dataCopyStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(229)
		p.Match(bbyCBLParserCOPY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(230)
		p.CopySource()
	}
	p.SetState(237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserREPLACING {
		{
			p.SetState(231)
			p.Match(bbyCBLParserREPLACING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == bbyCBLParserTRIPLE_EQUAL || _la == bbyCBLParserDOUBLE_EQUAL {
			{
				p.SetState(232)
				p.ReplacePair()
			}

			p.SetState(235)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(239)
		p.Match(bbyCBLParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILevelNumberContext is an interface to support dynamic dispatch.
type ILevelNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode

	// IsLevelNumberContext differentiates from other interfaces.
	IsLevelNumberContext()
}

type LevelNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelNumberContext() *LevelNumberContext {
	var p = new(LevelNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_levelNumber
	return p
}

func InitEmptyLevelNumberContext(p *LevelNumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_levelNumber
}

func (*LevelNumberContext) IsLevelNumberContext() {}

func NewLevelNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelNumberContext {
	var p = new(LevelNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_levelNumber

	return p
}

func (s *LevelNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelNumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNUMBER, 0)
}

func (s *LevelNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LevelNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLevelNumber(s)
	}
}

func (s *LevelNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLevelNumber(s)
	}
}

func (p *bbyCBLParser) LevelNumber() (localctx ILevelNumberContext) {
	localctx = NewLevelNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, bbyCBLParserRULE_levelNumber)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(241)
		p.Match(bbyCBLParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPictureClauseContext is an interface to support dynamic dispatch.
type IPictureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PICTURE() antlr.TerminalNode
	IS() antlr.TerminalNode
	PicturePattern() IPicturePatternContext

	// IsPictureClauseContext differentiates from other interfaces.
	IsPictureClauseContext()
}

type PictureClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureClauseContext() *PictureClauseContext {
	var p = new(PictureClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_pictureClause
	return p
}

func InitEmptyPictureClauseContext(p *PictureClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_pictureClause
}

func (*PictureClauseContext) IsPictureClauseContext() {}

func NewPictureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureClauseContext {
	var p = new(PictureClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_pictureClause

	return p
}

func (s *PictureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPICTURE, 0)
}

func (s *PictureClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserIS, 0)
}

func (s *PictureClauseContext) PicturePattern() IPicturePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPicturePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPicturePatternContext)
}

func (s *PictureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterPictureClause(s)
	}
}

func (s *PictureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitPictureClause(s)
	}
}

func (p *bbyCBLParser) PictureClause() (localctx IPictureClauseContext) {
	localctx = NewPictureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, bbyCBLParserRULE_pictureClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(243)
		p.Match(bbyCBLParserPICTURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(244)
		p.Match(bbyCBLParserIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(245)
		p.PicturePattern()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPicturePatternContext is an interface to support dynamic dispatch.
type IPicturePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPictureElement() []IPictureElementContext
	PictureElement(i int) IPictureElementContext

	// IsPicturePatternContext differentiates from other interfaces.
	IsPicturePatternContext()
}

type PicturePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPicturePatternContext() *PicturePatternContext {
	var p = new(PicturePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_picturePattern
	return p
}

func InitEmptyPicturePatternContext(p *PicturePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_picturePattern
}

func (*PicturePatternContext) IsPicturePatternContext() {}

func NewPicturePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PicturePatternContext {
	var p = new(PicturePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_picturePattern

	return p
}

func (s *PicturePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PicturePatternContext) AllPictureElement() []IPictureElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPictureElementContext); ok {
			len++
		}
	}

	tst := make([]IPictureElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPictureElementContext); ok {
			tst[i] = t.(IPictureElementContext)
			i++
		}
	}

	return tst
}

func (s *PicturePatternContext) PictureElement(i int) IPictureElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPictureElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPictureElementContext)
}

func (s *PicturePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PicturePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PicturePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterPicturePattern(s)
	}
}

func (s *PicturePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitPicturePattern(s)
	}
}

func (p *bbyCBLParser) PicturePattern() (localctx IPicturePatternContext) {
	localctx = NewPicturePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, bbyCBLParserRULE_picturePattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7292) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&137452584961) != 0) {
		{
			p.SetState(247)
			p.PictureElement()
		}

		p.SetState(250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPictureElementContext is an interface to support dynamic dispatch.
type IPictureElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNUMBER() []antlr.TerminalNode
	NUMBER(i int) antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PROGRAM_ID() antlr.TerminalNode
	AUTHOR() antlr.TerminalNode
	DATE_WRITTEN() antlr.TerminalNode
	STOP() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATE_UNDERSCORE() antlr.TerminalNode
	ANY_DATE() antlr.TerminalNode
	ANY_DATE_UNDERSCORE() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsPictureElementContext differentiates from other interfaces.
	IsPictureElementContext()
}

type PictureElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureElementContext() *PictureElementContext {
	var p = new(PictureElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_pictureElement
	return p
}

func InitEmptyPictureElementContext(p *PictureElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_pictureElement
}

func (*PictureElementContext) IsPictureElementContext() {}

func NewPictureElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureElementContext {
	var p = new(PictureElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_pictureElement

	return p
}

func (s *PictureElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureElementContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserNUMBER)
}

func (s *PictureElementContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNUMBER, i)
}

func (s *PictureElementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserIDENTIFIER, 0)
}

func (s *PictureElementContext) PROGRAM_ID() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPROGRAM_ID, 0)
}

func (s *PictureElementContext) AUTHOR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserAUTHOR, 0)
}

func (s *PictureElementContext) DATE_WRITTEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_WRITTEN, 0)
}

func (s *PictureElementContext) STOP() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSTOP, 0)
}

func (s *PictureElementContext) DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE, 0)
}

func (s *PictureElementContext) DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_UNDERSCORE, 0)
}

func (s *PictureElementContext) ANY_DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE, 0)
}

func (s *PictureElementContext) ANY_DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE_UNDERSCORE, 0)
}

func (s *PictureElementContext) MINUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMINUS, 0)
}

func (s *PictureElementContext) PLUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPLUS, 0)
}

func (s *PictureElementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLPAREN, 0)
}

func (s *PictureElementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserRPAREN, 0)
}

func (s *PictureElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterPictureElement(s)
	}
}

func (s *PictureElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitPictureElement(s)
	}
}

func (p *bbyCBLParser) PictureElement() (localctx IPictureElementContext) {
	localctx = NewPictureElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, bbyCBLParserRULE_pictureElement)
	var _la int

	p.SetState(261)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserNUMBER, bbyCBLParserDATE, bbyCBLParserDATE_UNDERSCORE, bbyCBLParserANY_DATE, bbyCBLParserANY_DATE_UNDERSCORE, bbyCBLParserPROGRAM_ID, bbyCBLParserAUTHOR, bbyCBLParserDATE_WRITTEN, bbyCBLParserSTOP, bbyCBLParserPLUS, bbyCBLParserMINUS, bbyCBLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(252)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7292) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&137451536385) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(256)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(253)
				p.Match(bbyCBLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(254)
				p.Match(bbyCBLParserNUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(255)
				p.Match(bbyCBLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case bbyCBLParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(258)
			p.Match(bbyCBLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(259)
			_la = p.GetTokenStream().LA(1)

			if !(_la == bbyCBLParserNUMBER || _la == bbyCBLParserIDENTIFIER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(260)
			p.Match(bbyCBLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILikeClauseContext is an interface to support dynamic dispatch.
type ILikeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	AllIdentifierSegment() []IIdentifierSegmentContext
	IdentifierSegment(i int) IIdentifierSegmentContext
	AllOF() []antlr.TerminalNode
	OF(i int) antlr.TerminalNode

	// IsLikeClauseContext differentiates from other interfaces.
	IsLikeClauseContext()
}

type LikeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLikeClauseContext() *LikeClauseContext {
	var p = new(LikeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_likeClause
	return p
}

func InitEmptyLikeClauseContext(p *LikeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_likeClause
}

func (*LikeClauseContext) IsLikeClauseContext() {}

func NewLikeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeClauseContext {
	var p = new(LikeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_likeClause

	return p
}

func (s *LikeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeClauseContext) LIKE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLIKE, 0)
}

func (s *LikeClauseContext) AllIdentifierSegment() []IIdentifierSegmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierSegmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierSegmentContext); ok {
			tst[i] = t.(IIdentifierSegmentContext)
			i++
		}
	}

	return tst
}

func (s *LikeClauseContext) IdentifierSegment(i int) IIdentifierSegmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSegmentContext)
}

func (s *LikeClauseContext) AllOF() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserOF)
}

func (s *LikeClauseContext) OF(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOF, i)
}

func (s *LikeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLikeClause(s)
	}
}

func (s *LikeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLikeClause(s)
	}
}

func (p *bbyCBLParser) LikeClause() (localctx ILikeClauseContext) {
	localctx = NewLikeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, bbyCBLParserRULE_likeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(263)
		p.Match(bbyCBLParserLIKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(264)
		p.IdentifierSegment()
	}
	p.SetState(269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserOF {
		{
			p.SetState(265)
			p.Match(bbyCBLParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(266)
			p.IdentifierSegment()
		}

		p.SetState(271)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOccursClauseContext is an interface to support dynamic dispatch.
type IOccursClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OCCURS() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	TIMES() antlr.TerminalNode

	// IsOccursClauseContext differentiates from other interfaces.
	IsOccursClauseContext()
}

type OccursClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOccursClauseContext() *OccursClauseContext {
	var p = new(OccursClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_occursClause
	return p
}

func InitEmptyOccursClauseContext(p *OccursClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_occursClause
}

func (*OccursClauseContext) IsOccursClauseContext() {}

func NewOccursClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OccursClauseContext {
	var p = new(OccursClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_occursClause

	return p
}

func (s *OccursClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OccursClauseContext) OCCURS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOCCURS, 0)
}

func (s *OccursClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNUMBER, 0)
}

func (s *OccursClauseContext) TIMES() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTIMES, 0)
}

func (s *OccursClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OccursClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OccursClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterOccursClause(s)
	}
}

func (s *OccursClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitOccursClause(s)
	}
}

func (p *bbyCBLParser) OccursClause() (localctx IOccursClauseContext) {
	localctx = NewOccursClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, bbyCBLParserRULE_occursClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(272)
		p.Match(bbyCBLParserOCCURS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(273)
		p.Match(bbyCBLParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserTIMES {
		{
			p.SetState(274)
			p.Match(bbyCBLParserTIMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureDivisionContext is an interface to support dynamic dispatch.
type IProcedureDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE_DIVISION() antlr.TerminalNode
	DOT() antlr.TerminalNode
	USING() antlr.TerminalNode
	UsingClause() IUsingClauseContext
	AllParagraph() []IParagraphContext
	Paragraph(i int) IParagraphContext
	AllSentence() []ISentenceContext
	Sentence(i int) ISentenceContext

	// IsProcedureDivisionContext differentiates from other interfaces.
	IsProcedureDivisionContext()
}

type ProcedureDivisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionContext() *ProcedureDivisionContext {
	var p = new(ProcedureDivisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_procedureDivision
	return p
}

func InitEmptyProcedureDivisionContext(p *ProcedureDivisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_procedureDivision
}

func (*ProcedureDivisionContext) IsProcedureDivisionContext() {}

func NewProcedureDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionContext {
	var p = new(ProcedureDivisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_procedureDivision

	return p
}

func (s *ProcedureDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionContext) PROCEDURE_DIVISION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPROCEDURE_DIVISION, 0)
}

func (s *ProcedureDivisionContext) DOT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, 0)
}

func (s *ProcedureDivisionContext) USING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserUSING, 0)
}

func (s *ProcedureDivisionContext) UsingClause() IUsingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingClauseContext)
}

func (s *ProcedureDivisionContext) AllParagraph() []IParagraphContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParagraphContext); ok {
			len++
		}
	}

	tst := make([]IParagraphContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParagraphContext); ok {
			tst[i] = t.(IParagraphContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureDivisionContext) Paragraph(i int) IParagraphContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParagraphContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParagraphContext)
}

func (s *ProcedureDivisionContext) AllSentence() []ISentenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISentenceContext); ok {
			len++
		}
	}

	tst := make([]ISentenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISentenceContext); ok {
			tst[i] = t.(ISentenceContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureDivisionContext) Sentence(i int) ISentenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISentenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISentenceContext)
}

func (s *ProcedureDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterProcedureDivision(s)
	}
}

func (s *ProcedureDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitProcedureDivision(s)
	}
}

func (p *bbyCBLParser) ProcedureDivision() (localctx IProcedureDivisionContext) {
	localctx = NewProcedureDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, bbyCBLParserRULE_procedureDivision)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(277)
		p.Match(bbyCBLParserPROCEDURE_DIVISION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserUSING {
		{
			p.SetState(278)
			p.Match(bbyCBLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(279)
			p.UsingClause()
		}

	}
	{
		p.SetState(282)
		p.Match(bbyCBLParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&315082778874477688) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&3298534901373) != 0) {
		p.SetState(285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(283)
				p.Paragraph()
			}

		case 2:
			{
				p.SetState(284)
				p.Sentence()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(289)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingClauseContext is an interface to support dynamic dispatch.
type IUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllREFERENCE() []antlr.TerminalNode
	REFERENCE(i int) antlr.TerminalNode
	AllVALUE() []antlr.TerminalNode
	VALUE(i int) antlr.TerminalNode
	AllCONTENT() []antlr.TerminalNode
	CONTENT(i int) antlr.TerminalNode

	// IsUsingClauseContext differentiates from other interfaces.
	IsUsingClauseContext()
}

type UsingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingClauseContext() *UsingClauseContext {
	var p = new(UsingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_usingClause
	return p
}

func InitEmptyUsingClauseContext(p *UsingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_usingClause
}

func (*UsingClauseContext) IsUsingClauseContext() {}

func NewUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingClauseContext {
	var p = new(UsingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_usingClause

	return p
}

func (s *UsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingClauseContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserBY)
}

func (s *UsingClauseContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, i)
}

func (s *UsingClauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *UsingClauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UsingClauseContext) AllREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserREFERENCE)
}

func (s *UsingClauseContext) REFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREFERENCE, i)
}

func (s *UsingClauseContext) AllVALUE() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserVALUE)
}

func (s *UsingClauseContext) VALUE(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserVALUE, i)
}

func (s *UsingClauseContext) AllCONTENT() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserCONTENT)
}

func (s *UsingClauseContext) CONTENT(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCONTENT, i)
}

func (s *UsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterUsingClause(s)
	}
}

func (s *UsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitUsingClause(s)
	}
}

func (p *bbyCBLParser) UsingClause() (localctx IUsingClauseContext) {
	localctx = NewUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, bbyCBLParserRULE_usingClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(293)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == bbyCBLParserBY {
		{
			p.SetState(290)
			p.Match(bbyCBLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(291)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-30)) & ^0x3f) == 0 && ((int64(1)<<(_la-30))&140738562097153) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(292)
			p.expr(0)
		}

		p.SetState(295)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParagraphContext is an interface to support dynamic dispatch.
type IParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DOT() antlr.TerminalNode
	AllSentence() []ISentenceContext
	Sentence(i int) ISentenceContext

	// IsParagraphContext differentiates from other interfaces.
	IsParagraphContext()
}

type ParagraphContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphContext() *ParagraphContext {
	var p = new(ParagraphContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_paragraph
	return p
}

func InitEmptyParagraphContext(p *ParagraphContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_paragraph
}

func (*ParagraphContext) IsParagraphContext() {}

func NewParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphContext {
	var p = new(ParagraphContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_paragraph

	return p
}

func (s *ParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParagraphContext) DOT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, 0)
}

func (s *ParagraphContext) AllSentence() []ISentenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISentenceContext); ok {
			len++
		}
	}

	tst := make([]ISentenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISentenceContext); ok {
			tst[i] = t.(ISentenceContext)
			i++
		}
	}

	return tst
}

func (s *ParagraphContext) Sentence(i int) ISentenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISentenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISentenceContext)
}

func (s *ParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterParagraph(s)
	}
}

func (s *ParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitParagraph(s)
	}
}

func (p *bbyCBLParser) Paragraph() (localctx IParagraphContext) {
	localctx = NewParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, bbyCBLParserRULE_paragraph)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(297)
		p.Identifier()
	}
	{
		p.SetState(298)
		p.Match(bbyCBLParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(299)
				p.Sentence()
			}

		}
		p.SetState(304)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISentenceContext is an interface to support dynamic dispatch.
type ISentenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsSentenceContext differentiates from other interfaces.
	IsSentenceContext()
}

type SentenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySentenceContext() *SentenceContext {
	var p = new(SentenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_sentence
	return p
}

func InitEmptySentenceContext(p *SentenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_sentence
}

func (*SentenceContext) IsSentenceContext() {}

func NewSentenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SentenceContext {
	var p = new(SentenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_sentence

	return p
}

func (s *SentenceContext) GetParser() antlr.Parser { return s.parser }

func (s *SentenceContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserDOT)
}

func (s *SentenceContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOT, i)
}

func (s *SentenceContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *SentenceContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SentenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SentenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SentenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSentence(s)
	}
}

func (s *SentenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSentence(s)
	}
}

func (p *bbyCBLParser) Sentence() (localctx ISentenceContext) {
	localctx = NewSentenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, bbyCBLParserRULE_sentence)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-16)) & ^0x3f) == 0 && ((int64(1)<<(_la-16))&4625482816531342723) != 0) {
		{
			p.SetState(305)
			p.Statement()
		}

		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(310)
		p.Match(bbyCBLParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserDOT {
		{
			p.SetState(311)
			p.Match(bbyCBLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AcceptStmt() IAcceptStmtContext
	AddStmt() IAddStmtContext
	SubtractStmt() ISubtractStmtContext
	MultiplyStmt() IMultiplyStmtContext
	DivideStmt() IDivideStmtContext
	MoveStmt() IMoveStmtContext
	DisplayStmt() IDisplayStmtContext
	EvaluateStmt() IEvaluateStmtContext
	IfStmt() IIfStmtContext
	LoopStmt() ILoopStmtContext
	PerformStmt() IPerformStmtContext
	NextSentenceStmt() INextSentenceStmtContext
	GotoStmt() IGotoStmtContext
	CallStmt() ICallStmtContext
	CopyStmt() ICopyStmtContext
	SignalStmt() ISignalStmtContext
	StopStmt() IStopStmtContext
	AlterStmt() IAlterStmtContext
	VaryingStmt() IVaryingStmtContext
	BASE() antlr.TerminalNode

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) AcceptStmt() IAcceptStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAcceptStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAcceptStmtContext)
}

func (s *StatementContext) AddStmt() IAddStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddStmtContext)
}

func (s *StatementContext) SubtractStmt() ISubtractStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractStmtContext)
}

func (s *StatementContext) MultiplyStmt() IMultiplyStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyStmtContext)
}

func (s *StatementContext) DivideStmt() IDivideStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDivideStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDivideStmtContext)
}

func (s *StatementContext) MoveStmt() IMoveStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMoveStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMoveStmtContext)
}

func (s *StatementContext) DisplayStmt() IDisplayStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayStmtContext)
}

func (s *StatementContext) EvaluateStmt() IEvaluateStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateStmtContext)
}

func (s *StatementContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *StatementContext) LoopStmt() ILoopStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStmtContext)
}

func (s *StatementContext) PerformStmt() IPerformStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformStmtContext)
}

func (s *StatementContext) NextSentenceStmt() INextSentenceStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INextSentenceStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INextSentenceStmtContext)
}

func (s *StatementContext) GotoStmt() IGotoStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStmtContext)
}

func (s *StatementContext) CallStmt() ICallStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallStmtContext)
}

func (s *StatementContext) CopyStmt() ICopyStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopyStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopyStmtContext)
}

func (s *StatementContext) SignalStmt() ISignalStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalStmtContext)
}

func (s *StatementContext) StopStmt() IStopStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopStmtContext)
}

func (s *StatementContext) AlterStmt() IAlterStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStmtContext)
}

func (s *StatementContext) VaryingStmt() IVaryingStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVaryingStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVaryingStmtContext)
}

func (s *StatementContext) BASE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBASE, 0)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *bbyCBLParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, bbyCBLParserRULE_statement)
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserACCEPT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(317)
			p.AcceptStmt()
		}

	case bbyCBLParserADD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(318)
			p.AddStmt()
		}

	case bbyCBLParserSUBTRACT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(319)
			p.SubtractStmt()
		}

	case bbyCBLParserMULTIPLY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(320)
			p.MultiplyStmt()
		}

	case bbyCBLParserDIVIDE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(321)
			p.DivideStmt()
		}

	case bbyCBLParserMOVE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(322)
			p.MoveStmt()
		}

	case bbyCBLParserDISPLAY:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(323)
			p.DisplayStmt()
		}

	case bbyCBLParserEVALUATE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(324)
			p.EvaluateStmt()
		}

	case bbyCBLParserIF:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(325)
			p.IfStmt()
		}

	case bbyCBLParserLOOP:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(326)
			p.LoopStmt()
		}

	case bbyCBLParserPERFORM:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(327)
			p.PerformStmt()
		}

	case bbyCBLParserNEXT_SENTENCE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(328)
			p.NextSentenceStmt()
		}

	case bbyCBLParserGO:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(329)
			p.GotoStmt()
		}

	case bbyCBLParserCALL:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(330)
			p.CallStmt()
		}

	case bbyCBLParserCOPY:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(331)
			p.CopyStmt()
		}

	case bbyCBLParserSIGNAL:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(332)
			p.SignalStmt()
		}

	case bbyCBLParserSTOP:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(333)
			p.StopStmt()
		}

	case bbyCBLParserALTER:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(334)
			p.AlterStmt()
		}

	case bbyCBLParserVARYING:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(335)
			p.VaryingStmt()
		}

	case bbyCBLParserBASE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(336)
			p.Match(bbyCBLParserBASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyAll(ctx *IdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SingleContext struct {
	IdentifierContext
}

func NewSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleContext {
	var p = new(SingleContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *SingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *SingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSingle(s)
	}
}

func (s *SingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSingle(s)
	}
}

type QualifiedContext struct {
	IdentifierContext
}

func NewQualifiedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedContext {
	var p = new(QualifiedContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *QualifiedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedContext) AllSimpleId() []ISimpleIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleIdContext); ok {
			len++
		}
	}

	tst := make([]ISimpleIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleIdContext); ok {
			tst[i] = t.(ISimpleIdContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedContext) SimpleId(i int) ISimpleIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *QualifiedContext) AllOF() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserOF)
}

func (s *QualifiedContext) OF(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOF, i)
}

func (s *QualifiedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterQualified(s)
	}
}

func (s *QualifiedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitQualified(s)
	}
}

func (p *bbyCBLParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, bbyCBLParserRULE_identifier)
	var _la int

	p.SetState(347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQualifiedContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(339)
			p.SimpleId()
		}
		p.SetState(342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == bbyCBLParserOF {
			{
				p.SetState(340)
				p.Match(bbyCBLParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(341)
				p.SimpleId()
			}

			p.SetState(344)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(346)
			p.SimpleId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleIdContext is an interface to support dynamic dispatch.
type ISimpleIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	DESCRIPTION() antlr.TerminalNode
	PROGRAM_ID() antlr.TerminalNode
	AUTHOR() antlr.TerminalNode
	DATE_WRITTEN() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATE_UNDERSCORE() antlr.TerminalNode
	ANY_DATE() antlr.TerminalNode
	ANY_DATE_UNDERSCORE() antlr.TerminalNode
	HIGH_VALUES() antlr.TerminalNode
	LOW_VALUES() antlr.TerminalNode
	SPACE() antlr.TerminalNode
	SPACES() antlr.TerminalNode
	BASE() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	END() antlr.TerminalNode
	ADD() antlr.TerminalNode
	MOVE() antlr.TerminalNode
	TO() antlr.TerminalNode
	THEN() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	INSTALLATION() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	DATE_COMPILED() antlr.TerminalNode
	DISPLAY() antlr.TerminalNode
	OF() antlr.TerminalNode
	BY() antlr.TerminalNode
	COPY() antlr.TerminalNode
	VARYING() antlr.TerminalNode
	STOP() antlr.TerminalNode
	LIKE() antlr.TerminalNode

	// IsSimpleIdContext differentiates from other interfaces.
	IsSimpleIdContext()
}

type SimpleIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdContext() *SimpleIdContext {
	var p = new(SimpleIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_simpleId
	return p
}

func InitEmptySimpleIdContext(p *SimpleIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_simpleId
}

func (*SimpleIdContext) IsSimpleIdContext() {}

func NewSimpleIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdContext {
	var p = new(SimpleIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_simpleId

	return p
}

func (s *SimpleIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserIDENTIFIER, 0)
}

func (s *SimpleIdContext) DESCRIPTION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDESCRIPTION, 0)
}

func (s *SimpleIdContext) PROGRAM_ID() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPROGRAM_ID, 0)
}

func (s *SimpleIdContext) AUTHOR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserAUTHOR, 0)
}

func (s *SimpleIdContext) DATE_WRITTEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_WRITTEN, 0)
}

func (s *SimpleIdContext) DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE, 0)
}

func (s *SimpleIdContext) DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_UNDERSCORE, 0)
}

func (s *SimpleIdContext) ANY_DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE, 0)
}

func (s *SimpleIdContext) ANY_DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE_UNDERSCORE, 0)
}

func (s *SimpleIdContext) HIGH_VALUES() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserHIGH_VALUES, 0)
}

func (s *SimpleIdContext) LOW_VALUES() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLOW_VALUES, 0)
}

func (s *SimpleIdContext) SPACE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSPACE, 0)
}

func (s *SimpleIdContext) SPACES() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSPACES, 0)
}

func (s *SimpleIdContext) BASE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBASE, 0)
}

func (s *SimpleIdContext) TRUE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTRUE, 0)
}

func (s *SimpleIdContext) FALSE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserFALSE, 0)
}

func (s *SimpleIdContext) END() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND, 0)
}

func (s *SimpleIdContext) ADD() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserADD, 0)
}

func (s *SimpleIdContext) MOVE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMOVE, 0)
}

func (s *SimpleIdContext) TO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, 0)
}

func (s *SimpleIdContext) THEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTHEN, 0)
}

func (s *SimpleIdContext) ELSE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserELSE, 0)
}

func (s *SimpleIdContext) INSTALLATION() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserINSTALLATION, 0)
}

func (s *SimpleIdContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSECURITY, 0)
}

func (s *SimpleIdContext) DATE_COMPILED() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_COMPILED, 0)
}

func (s *SimpleIdContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDISPLAY, 0)
}

func (s *SimpleIdContext) OF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOF, 0)
}

func (s *SimpleIdContext) BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, 0)
}

func (s *SimpleIdContext) COPY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCOPY, 0)
}

func (s *SimpleIdContext) VARYING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserVARYING, 0)
}

func (s *SimpleIdContext) STOP() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSTOP, 0)
}

func (s *SimpleIdContext) LIKE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLIKE, 0)
}

func (s *SimpleIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSimpleId(s)
	}
}

func (s *SimpleIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSimpleId(s)
	}
}

func (p *bbyCBLParser) SimpleId() (localctx ISimpleIdContext) {
	localctx = NewSimpleIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, bbyCBLParserRULE_simpleId)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(349)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&19707758373239928) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&824633725335) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEvalSubjectContext is an interface to support dynamic dispatch.
type IEvalSubjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExprList() IExprListContext
	Condition() IConditionContext

	// IsEvalSubjectContext differentiates from other interfaces.
	IsEvalSubjectContext()
}

type EvalSubjectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvalSubjectContext() *EvalSubjectContext {
	var p = new(EvalSubjectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_evalSubject
	return p
}

func InitEmptyEvalSubjectContext(p *EvalSubjectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_evalSubject
}

func (*EvalSubjectContext) IsEvalSubjectContext() {}

func NewEvalSubjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvalSubjectContext {
	var p = new(EvalSubjectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_evalSubject

	return p
}

func (s *EvalSubjectContext) GetParser() antlr.Parser { return s.parser }

func (s *EvalSubjectContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *EvalSubjectContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *EvalSubjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvalSubjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvalSubjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterEvalSubject(s)
	}
}

func (s *EvalSubjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitEvalSubject(s)
	}
}

func (p *bbyCBLParser) EvalSubject() (localctx IEvalSubjectContext) {
	localctx = NewEvalSubjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, bbyCBLParserRULE_evalSubject)
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(351)
			p.ExprList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(352)
			p.Condition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAcceptStmtContext is an interface to support dynamic dispatch.
type IAcceptStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCEPT() antlr.TerminalNode
	ExprList() IExprListContext

	// IsAcceptStmtContext differentiates from other interfaces.
	IsAcceptStmtContext()
}

type AcceptStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptStmtContext() *AcceptStmtContext {
	var p = new(AcceptStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_acceptStmt
	return p
}

func InitEmptyAcceptStmtContext(p *AcceptStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_acceptStmt
}

func (*AcceptStmtContext) IsAcceptStmtContext() {}

func NewAcceptStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptStmtContext {
	var p = new(AcceptStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_acceptStmt

	return p
}

func (s *AcceptStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptStmtContext) ACCEPT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserACCEPT, 0)
}

func (s *AcceptStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *AcceptStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterAcceptStmt(s)
	}
}

func (s *AcceptStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitAcceptStmt(s)
	}
}

func (p *bbyCBLParser) AcceptStmt() (localctx IAcceptStmtContext) {
	localctx = NewAcceptStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, bbyCBLParserRULE_acceptStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.Match(bbyCBLParserACCEPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(356)
			p.ExprList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddStmtContext is an interface to support dynamic dispatch.
type IAddStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	AllExprList() []IExprListContext
	ExprList(i int) IExprListContext
	TO() antlr.TerminalNode
	AllGivingClause() []IGivingClauseContext
	GivingClause(i int) IGivingClauseContext

	// IsAddStmtContext differentiates from other interfaces.
	IsAddStmtContext()
}

type AddStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddStmtContext() *AddStmtContext {
	var p = new(AddStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_addStmt
	return p
}

func InitEmptyAddStmtContext(p *AddStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_addStmt
}

func (*AddStmtContext) IsAddStmtContext() {}

func NewAddStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddStmtContext {
	var p = new(AddStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_addStmt

	return p
}

func (s *AddStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AddStmtContext) ADD() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserADD, 0)
}

func (s *AddStmtContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *AddStmtContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *AddStmtContext) TO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, 0)
}

func (s *AddStmtContext) AllGivingClause() []IGivingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGivingClauseContext); ok {
			len++
		}
	}

	tst := make([]IGivingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGivingClauseContext); ok {
			tst[i] = t.(IGivingClauseContext)
			i++
		}
	}

	return tst
}

func (s *AddStmtContext) GivingClause(i int) IGivingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGivingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGivingClauseContext)
}

func (s *AddStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterAddStmt(s)
	}
}

func (s *AddStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitAddStmt(s)
	}
}

func (p *bbyCBLParser) AddStmt() (localctx IAddStmtContext) {
	localctx = NewAddStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, bbyCBLParserRULE_addStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.Match(bbyCBLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(360)
		p.ExprList()
	}
	{
		p.SetState(361)
		p.Match(bbyCBLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(362)
		p.ExprList()
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserGIVING {
		{
			p.SetState(363)
			p.GivingClause()
		}

		p.SetState(368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStmtContext is an interface to support dynamic dispatch.
type IAlterStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllTO() []antlr.TerminalNode
	TO(i int) antlr.TerminalNode
	PROCEED() antlr.TerminalNode

	// IsAlterStmtContext differentiates from other interfaces.
	IsAlterStmtContext()
}

type AlterStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStmtContext() *AlterStmtContext {
	var p = new(AlterStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_alterStmt
	return p
}

func InitEmptyAlterStmtContext(p *AlterStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_alterStmt
}

func (*AlterStmtContext) IsAlterStmtContext() {}

func NewAlterStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStmtContext {
	var p = new(AlterStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_alterStmt

	return p
}

func (s *AlterStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserALTER, 0)
}

func (s *AlterStmtContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterStmtContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterStmtContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserTO)
}

func (s *AlterStmtContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, i)
}

func (s *AlterStmtContext) PROCEED() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPROCEED, 0)
}

func (s *AlterStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterAlterStmt(s)
	}
}

func (s *AlterStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitAlterStmt(s)
	}
}

func (p *bbyCBLParser) AlterStmt() (localctx IAlterStmtContext) {
	localctx = NewAlterStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, bbyCBLParserRULE_alterStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(369)
		p.Match(bbyCBLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(370)
		p.Identifier()
	}
	{
		p.SetState(371)
		p.Match(bbyCBLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(372)
		p.Match(bbyCBLParserPROCEED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(373)
		p.Match(bbyCBLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(374)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallStmtContext is an interface to support dynamic dispatch.
type ICallStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALL() antlr.TerminalNode
	Expr() IExprContext
	USING() antlr.TerminalNode
	UsingClause() IUsingClauseContext

	// IsCallStmtContext differentiates from other interfaces.
	IsCallStmtContext()
}

type CallStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStmtContext() *CallStmtContext {
	var p = new(CallStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_callStmt
	return p
}

func InitEmptyCallStmtContext(p *CallStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_callStmt
}

func (*CallStmtContext) IsCallStmtContext() {}

func NewCallStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStmtContext {
	var p = new(CallStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_callStmt

	return p
}

func (s *CallStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStmtContext) CALL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCALL, 0)
}

func (s *CallStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CallStmtContext) USING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserUSING, 0)
}

func (s *CallStmtContext) UsingClause() IUsingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingClauseContext)
}

func (s *CallStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterCallStmt(s)
	}
}

func (s *CallStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitCallStmt(s)
	}
}

func (p *bbyCBLParser) CallStmt() (localctx ICallStmtContext) {
	localctx = NewCallStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, bbyCBLParserRULE_callStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(376)
		p.Match(bbyCBLParserCALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(377)
		p.expr(0)
	}
	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserUSING {
		{
			p.SetState(378)
			p.Match(bbyCBLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(379)
			p.UsingClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopySourceContext is an interface to support dynamic dispatch.
type ICopySourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	SimpleId() ISimpleIdContext

	// IsCopySourceContext differentiates from other interfaces.
	IsCopySourceContext()
}

type CopySourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopySourceContext() *CopySourceContext {
	var p = new(CopySourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_copySource
	return p
}

func InitEmptyCopySourceContext(p *CopySourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_copySource
}

func (*CopySourceContext) IsCopySourceContext() {}

func NewCopySourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CopySourceContext {
	var p = new(CopySourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_copySource

	return p
}

func (s *CopySourceContext) GetParser() antlr.Parser { return s.parser }

func (s *CopySourceContext) STRING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSTRING, 0)
}

func (s *CopySourceContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *CopySourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopySourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CopySourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterCopySource(s)
	}
}

func (s *CopySourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitCopySource(s)
	}
}

func (p *bbyCBLParser) CopySource() (localctx ICopySourceContext) {
	localctx = NewCopySourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, bbyCBLParserRULE_copySource)
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(382)
			p.Match(bbyCBLParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bbyCBLParserDATE, bbyCBLParserDATE_UNDERSCORE, bbyCBLParserANY_DATE, bbyCBLParserANY_DATE_UNDERSCORE, bbyCBLParserPROGRAM_ID, bbyCBLParserAUTHOR, bbyCBLParserDATE_WRITTEN, bbyCBLParserINSTALLATION, bbyCBLParserSECURITY, bbyCBLParserDATE_COMPILED, bbyCBLParserBASE, bbyCBLParserCOPY, bbyCBLParserDESCRIPTION, bbyCBLParserLIKE, bbyCBLParserADD, bbyCBLParserBY, bbyCBLParserDISPLAY, bbyCBLParserELSE, bbyCBLParserEND, bbyCBLParserFALSE, bbyCBLParserLOW_VALUES, bbyCBLParserMOVE, bbyCBLParserOF, bbyCBLParserSPACE, bbyCBLParserSPACES, bbyCBLParserSTOP, bbyCBLParserTHEN, bbyCBLParserTO, bbyCBLParserTRUE, bbyCBLParserVARYING, bbyCBLParserHIGH_VALUES, bbyCBLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(383)
			p.SimpleId()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopyStmtContext is an interface to support dynamic dispatch.
type ICopyStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COPY() antlr.TerminalNode
	CopySource() ICopySourceContext
	REPLACING() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllReplacePair() []IReplacePairContext
	ReplacePair(i int) IReplacePairContext

	// IsCopyStmtContext differentiates from other interfaces.
	IsCopyStmtContext()
}

type CopyStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopyStmtContext() *CopyStmtContext {
	var p = new(CopyStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_copyStmt
	return p
}

func InitEmptyCopyStmtContext(p *CopyStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_copyStmt
}

func (*CopyStmtContext) IsCopyStmtContext() {}

func NewCopyStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CopyStmtContext {
	var p = new(CopyStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_copyStmt

	return p
}

func (s *CopyStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CopyStmtContext) COPY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCOPY, 0)
}

func (s *CopyStmtContext) CopySource() ICopySourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopySourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopySourceContext)
}

func (s *CopyStmtContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREPLACING, 0)
}

func (s *CopyStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CopyStmtContext) AllReplacePair() []IReplacePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplacePairContext); ok {
			len++
		}
	}

	tst := make([]IReplacePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplacePairContext); ok {
			tst[i] = t.(IReplacePairContext)
			i++
		}
	}

	return tst
}

func (s *CopyStmtContext) ReplacePair(i int) IReplacePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePairContext)
}

func (s *CopyStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CopyStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterCopyStmt(s)
	}
}

func (s *CopyStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitCopyStmt(s)
	}
}

func (p *bbyCBLParser) CopyStmt() (localctx ICopyStmtContext) {
	localctx = NewCopyStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, bbyCBLParserRULE_copyStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		p.Match(bbyCBLParserCOPY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(387)
		p.CopySource()
	}
	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserREPLACING {
		{
			p.SetState(388)
			p.Match(bbyCBLParserREPLACING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(390)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == bbyCBLParserTRIPLE_EQUAL || _la == bbyCBLParserDOUBLE_EQUAL {
			{
				p.SetState(389)
				p.ReplacePair()
			}

			p.SetState(392)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(396)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplacePairContext is an interface to support dynamic dispatch.
type IReplacePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllReplaceBlock() []IReplaceBlockContext
	ReplaceBlock(i int) IReplaceBlockContext
	BY() antlr.TerminalNode

	// IsReplacePairContext differentiates from other interfaces.
	IsReplacePairContext()
}

type ReplacePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplacePairContext() *ReplacePairContext {
	var p = new(ReplacePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_replacePair
	return p
}

func InitEmptyReplacePairContext(p *ReplacePairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_replacePair
}

func (*ReplacePairContext) IsReplacePairContext() {}

func NewReplacePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplacePairContext {
	var p = new(ReplacePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_replacePair

	return p
}

func (s *ReplacePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplacePairContext) AllReplaceBlock() []IReplaceBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplaceBlockContext); ok {
			len++
		}
	}

	tst := make([]IReplaceBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplaceBlockContext); ok {
			tst[i] = t.(IReplaceBlockContext)
			i++
		}
	}

	return tst
}

func (s *ReplacePairContext) ReplaceBlock(i int) IReplaceBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceBlockContext)
}

func (s *ReplacePairContext) BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, 0)
}

func (s *ReplacePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplacePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterReplacePair(s)
	}
}

func (s *ReplacePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitReplacePair(s)
	}
}

func (p *bbyCBLParser) ReplacePair() (localctx IReplacePairContext) {
	localctx = NewReplacePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, bbyCBLParserRULE_replacePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(399)
		p.ReplaceBlock()
	}
	{
		p.SetState(400)
		p.Match(bbyCBLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(401)
		p.ReplaceBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceBlockContext is an interface to support dynamic dispatch.
type IReplaceBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEqualDelim() []IEqualDelimContext
	EqualDelim(i int) IEqualDelimContext

	// IsReplaceBlockContext differentiates from other interfaces.
	IsReplaceBlockContext()
}

type ReplaceBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplaceBlockContext() *ReplaceBlockContext {
	var p = new(ReplaceBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_replaceBlock
	return p
}

func InitEmptyReplaceBlockContext(p *ReplaceBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_replaceBlock
}

func (*ReplaceBlockContext) IsReplaceBlockContext() {}

func NewReplaceBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceBlockContext {
	var p = new(ReplaceBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_replaceBlock

	return p
}

func (s *ReplaceBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceBlockContext) AllEqualDelim() []IEqualDelimContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEqualDelimContext); ok {
			len++
		}
	}

	tst := make([]IEqualDelimContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEqualDelimContext); ok {
			tst[i] = t.(IEqualDelimContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceBlockContext) EqualDelim(i int) IEqualDelimContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualDelimContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualDelimContext)
}

func (s *ReplaceBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterReplaceBlock(s)
	}
}

func (s *ReplaceBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitReplaceBlock(s)
	}
}

func (p *bbyCBLParser) ReplaceBlock() (localctx IReplaceBlockContext) {
	localctx = NewReplaceBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, bbyCBLParserRULE_replaceBlock)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(403)
		p.EqualDelim()
	}
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1 + 1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1 + 1:
			p.SetState(404)
			p.MatchWildcard()

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(407)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(409)
		p.EqualDelim()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualDelimContext is an interface to support dynamic dispatch.
type IEqualDelimContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_EQUAL() antlr.TerminalNode
	DOUBLE_EQUAL() antlr.TerminalNode

	// IsEqualDelimContext differentiates from other interfaces.
	IsEqualDelimContext()
}

type EqualDelimContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualDelimContext() *EqualDelimContext {
	var p = new(EqualDelimContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_equalDelim
	return p
}

func InitEmptyEqualDelimContext(p *EqualDelimContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_equalDelim
}

func (*EqualDelimContext) IsEqualDelimContext() {}

func NewEqualDelimContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualDelimContext {
	var p = new(EqualDelimContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_equalDelim

	return p
}

func (s *EqualDelimContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualDelimContext) TRIPLE_EQUAL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTRIPLE_EQUAL, 0)
}

func (s *EqualDelimContext) DOUBLE_EQUAL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDOUBLE_EQUAL, 0)
}

func (s *EqualDelimContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualDelimContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualDelimContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterEqualDelim(s)
	}
}

func (s *EqualDelimContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitEqualDelim(s)
	}
}

func (p *bbyCBLParser) EqualDelim() (localctx IEqualDelimContext) {
	localctx = NewEqualDelimContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, bbyCBLParserRULE_equalDelim)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(411)
		_la = p.GetTokenStream().LA(1)

		if !(_la == bbyCBLParserTRIPLE_EQUAL || _la == bbyCBLParserDOUBLE_EQUAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisplayItemContext is an interface to support dynamic dispatch.
type IDisplayItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	DelimiterSpec() IDelimiterSpecContext

	// IsDisplayItemContext differentiates from other interfaces.
	IsDisplayItemContext()
}

type DisplayItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayItemContext() *DisplayItemContext {
	var p = new(DisplayItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_displayItem
	return p
}

func InitEmptyDisplayItemContext(p *DisplayItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_displayItem
}

func (*DisplayItemContext) IsDisplayItemContext() {}

func NewDisplayItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayItemContext {
	var p = new(DisplayItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_displayItem

	return p
}

func (s *DisplayItemContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayItemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DisplayItemContext) DelimiterSpec() IDelimiterSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelimiterSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelimiterSpecContext)
}

func (s *DisplayItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDisplayItem(s)
	}
}

func (s *DisplayItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDisplayItem(s)
	}
}

func (p *bbyCBLParser) DisplayItem() (localctx IDisplayItemContext) {
	localctx = NewDisplayItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, bbyCBLParserRULE_displayItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.expr(0)
	}
	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserDELIMITED_BY || _la == bbyCBLParserDELIMITED {
		{
			p.SetState(414)
			p.DelimiterSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelimiterSpecContext is an interface to support dynamic dispatch.
type IDelimiterSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELIMITED_BY() antlr.TerminalNode
	ValueSpec() IValueSpecContext
	DELIMITED() antlr.TerminalNode
	BY() antlr.TerminalNode

	// IsDelimiterSpecContext differentiates from other interfaces.
	IsDelimiterSpecContext()
}

type DelimiterSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelimiterSpecContext() *DelimiterSpecContext {
	var p = new(DelimiterSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_delimiterSpec
	return p
}

func InitEmptyDelimiterSpecContext(p *DelimiterSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_delimiterSpec
}

func (*DelimiterSpecContext) IsDelimiterSpecContext() {}

func NewDelimiterSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelimiterSpecContext {
	var p = new(DelimiterSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_delimiterSpec

	return p
}

func (s *DelimiterSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *DelimiterSpecContext) DELIMITED_BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDELIMITED_BY, 0)
}

func (s *DelimiterSpecContext) ValueSpec() IValueSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueSpecContext)
}

func (s *DelimiterSpecContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDELIMITED, 0)
}

func (s *DelimiterSpecContext) BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, 0)
}

func (s *DelimiterSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelimiterSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelimiterSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDelimiterSpec(s)
	}
}

func (s *DelimiterSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDelimiterSpec(s)
	}
}

func (p *bbyCBLParser) DelimiterSpec() (localctx IDelimiterSpecContext) {
	localctx = NewDelimiterSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, bbyCBLParserRULE_delimiterSpec)
	p.SetState(422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserDELIMITED_BY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(417)
			p.Match(bbyCBLParserDELIMITED_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(418)
			p.ValueSpec()
		}

	case bbyCBLParserDELIMITED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(419)
			p.Match(bbyCBLParserDELIMITED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(420)
			p.Match(bbyCBLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(421)
			p.ValueSpec()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueSpecContext is an interface to support dynamic dispatch.
type IValueSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	SIZE() antlr.TerminalNode
	SPACE() antlr.TerminalNode

	// IsValueSpecContext differentiates from other interfaces.
	IsValueSpecContext()
}

type ValueSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueSpecContext() *ValueSpecContext {
	var p = new(ValueSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_valueSpec
	return p
}

func InitEmptyValueSpecContext(p *ValueSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_valueSpec
}

func (*ValueSpecContext) IsValueSpecContext() {}

func NewValueSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueSpecContext {
	var p = new(ValueSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_valueSpec

	return p
}

func (s *ValueSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueSpecContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ValueSpecContext) SIZE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSIZE, 0)
}

func (s *ValueSpecContext) SPACE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSPACE, 0)
}

func (s *ValueSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterValueSpec(s)
	}
}

func (s *ValueSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitValueSpec(s)
	}
}

func (p *bbyCBLParser) ValueSpec() (localctx IValueSpecContext) {
	localctx = NewValueSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, bbyCBLParserRULE_valueSpec)
	p.SetState(427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(424)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(425)
			p.Match(bbyCBLParserSIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(426)
			p.Match(bbyCBLParserSPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisplayStmtContext is an interface to support dynamic dispatch.
type IDisplayStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISPLAY() antlr.TerminalNode
	AllDisplayItem() []IDisplayItemContext
	DisplayItem(i int) IDisplayItemContext
	WITH_NO_ADVANCING() antlr.TerminalNode
	WITH() antlr.TerminalNode
	NO() antlr.TerminalNode
	ADVANCING() antlr.TerminalNode

	// IsDisplayStmtContext differentiates from other interfaces.
	IsDisplayStmtContext()
}

type DisplayStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayStmtContext() *DisplayStmtContext {
	var p = new(DisplayStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_displayStmt
	return p
}

func InitEmptyDisplayStmtContext(p *DisplayStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_displayStmt
}

func (*DisplayStmtContext) IsDisplayStmtContext() {}

func NewDisplayStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayStmtContext {
	var p = new(DisplayStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_displayStmt

	return p
}

func (s *DisplayStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayStmtContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDISPLAY, 0)
}

func (s *DisplayStmtContext) AllDisplayItem() []IDisplayItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDisplayItemContext); ok {
			len++
		}
	}

	tst := make([]IDisplayItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDisplayItemContext); ok {
			tst[i] = t.(IDisplayItemContext)
			i++
		}
	}

	return tst
}

func (s *DisplayStmtContext) DisplayItem(i int) IDisplayItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayItemContext)
}

func (s *DisplayStmtContext) WITH_NO_ADVANCING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWITH_NO_ADVANCING, 0)
}

func (s *DisplayStmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWITH, 0)
}

func (s *DisplayStmtContext) NO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNO, 0)
}

func (s *DisplayStmtContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserADVANCING, 0)
}

func (s *DisplayStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDisplayStmt(s)
	}
}

func (s *DisplayStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDisplayStmt(s)
	}
}

func (p *bbyCBLParser) DisplayStmt() (localctx IDisplayStmtContext) {
	localctx = NewDisplayStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, bbyCBLParserRULE_displayStmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(429)
		p.Match(bbyCBLParserDISPLAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(430)
				p.DisplayItem()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(433)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserWITH_NO_ADVANCING:
		{
			p.SetState(435)
			p.Match(bbyCBLParserWITH_NO_ADVANCING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bbyCBLParserWITH:
		{
			p.SetState(436)
			p.Match(bbyCBLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(437)
			p.Match(bbyCBLParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(438)
			p.Match(bbyCBLParserADVANCING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bbyCBLParserFLOAT, bbyCBLParserNUMBER, bbyCBLParserDATE, bbyCBLParserDATE_UNDERSCORE, bbyCBLParserANY_DATE, bbyCBLParserANY_DATE_UNDERSCORE, bbyCBLParserPROGRAM_ID, bbyCBLParserAUTHOR, bbyCBLParserDATE_WRITTEN, bbyCBLParserINSTALLATION, bbyCBLParserSECURITY, bbyCBLParserDATE_COMPILED, bbyCBLParserBASE, bbyCBLParserCOPY, bbyCBLParserDESCRIPTION, bbyCBLParserLIKE, bbyCBLParserACCEPT, bbyCBLParserADD, bbyCBLParserALTER, bbyCBLParserBY, bbyCBLParserCALL, bbyCBLParserDISPLAY, bbyCBLParserDIVIDE, bbyCBLParserELSE, bbyCBLParserEND, bbyCBLParserEND_EVALUATE, bbyCBLParserEND_IF, bbyCBLParserEVALUATE, bbyCBLParserFALSE, bbyCBLParserGO, bbyCBLParserIF, bbyCBLParserLOOP, bbyCBLParserLOW_VALUES, bbyCBLParserMOVE, bbyCBLParserMULTIPLY, bbyCBLParserNEXT_SENTENCE, bbyCBLParserOF, bbyCBLParserPERFORM, bbyCBLParserSIGNAL, bbyCBLParserSPACE, bbyCBLParserSPACES, bbyCBLParserSTOP, bbyCBLParserSUBTRACT, bbyCBLParserTHEN, bbyCBLParserTO, bbyCBLParserTRUE, bbyCBLParserUNTIL, bbyCBLParserVARYING, bbyCBLParserWHEN, bbyCBLParserWHILE, bbyCBLParserDOT, bbyCBLParserLPAREN, bbyCBLParserPLUS, bbyCBLParserMINUS, bbyCBLParserSTRING, bbyCBLParserHIGH_VALUES, bbyCBLParserIDENTIFIER:

	default:
	}
	p.SetState(444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(441)
				p.DisplayItem()
			}

		}
		p.SetState(446)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDivideStmtContext is an interface to support dynamic dispatch.
type IDivideStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIVIDE() antlr.TerminalNode
	AllExprList() []IExprListContext
	ExprList(i int) IExprListContext
	INTO() antlr.TerminalNode
	AllGivingClause() []IGivingClauseContext
	GivingClause(i int) IGivingClauseContext
	REMAINDER() antlr.TerminalNode

	// IsDivideStmtContext differentiates from other interfaces.
	IsDivideStmtContext()
}

type DivideStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideStmtContext() *DivideStmtContext {
	var p = new(DivideStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_divideStmt
	return p
}

func InitEmptyDivideStmtContext(p *DivideStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_divideStmt
}

func (*DivideStmtContext) IsDivideStmtContext() {}

func NewDivideStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideStmtContext {
	var p = new(DivideStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_divideStmt

	return p
}

func (s *DivideStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideStmtContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDIVIDE, 0)
}

func (s *DivideStmtContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *DivideStmtContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *DivideStmtContext) INTO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserINTO, 0)
}

func (s *DivideStmtContext) AllGivingClause() []IGivingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGivingClauseContext); ok {
			len++
		}
	}

	tst := make([]IGivingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGivingClauseContext); ok {
			tst[i] = t.(IGivingClauseContext)
			i++
		}
	}

	return tst
}

func (s *DivideStmtContext) GivingClause(i int) IGivingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGivingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGivingClauseContext)
}

func (s *DivideStmtContext) REMAINDER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserREMAINDER, 0)
}

func (s *DivideStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterDivideStmt(s)
	}
}

func (s *DivideStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitDivideStmt(s)
	}
}

func (p *bbyCBLParser) DivideStmt() (localctx IDivideStmtContext) {
	localctx = NewDivideStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, bbyCBLParserRULE_divideStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Match(bbyCBLParserDIVIDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(448)
		p.ExprList()
	}
	{
		p.SetState(449)
		p.Match(bbyCBLParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(450)
		p.ExprList()
	}
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserGIVING {
		{
			p.SetState(451)
			p.GivingClause()
		}

		p.SetState(456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserREMAINDER {
		{
			p.SetState(457)
			p.Match(bbyCBLParserREMAINDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(458)
			p.ExprList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEvaluateStmtContext is an interface to support dynamic dispatch.
type IEvaluateStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVALUATE() antlr.TerminalNode
	END_EVALUATE() antlr.TerminalNode
	END() antlr.TerminalNode
	AllEvalSubject() []IEvalSubjectContext
	EvalSubject(i int) IEvalSubjectContext
	AllALSO() []antlr.TerminalNode
	ALSO(i int) antlr.TerminalNode
	AllWhenClause() []IWhenClauseContext
	WhenClause(i int) IWhenClauseContext
	Identifier() IIdentifierContext

	// IsEvaluateStmtContext differentiates from other interfaces.
	IsEvaluateStmtContext()
}

type EvaluateStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateStmtContext() *EvaluateStmtContext {
	var p = new(EvaluateStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_evaluateStmt
	return p
}

func InitEmptyEvaluateStmtContext(p *EvaluateStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_evaluateStmt
}

func (*EvaluateStmtContext) IsEvaluateStmtContext() {}

func NewEvaluateStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateStmtContext {
	var p = new(EvaluateStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_evaluateStmt

	return p
}

func (s *EvaluateStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateStmtContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEVALUATE, 0)
}

func (s *EvaluateStmtContext) END_EVALUATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND_EVALUATE, 0)
}

func (s *EvaluateStmtContext) END() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND, 0)
}

func (s *EvaluateStmtContext) AllEvalSubject() []IEvalSubjectContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEvalSubjectContext); ok {
			len++
		}
	}

	tst := make([]IEvalSubjectContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEvalSubjectContext); ok {
			tst[i] = t.(IEvalSubjectContext)
			i++
		}
	}

	return tst
}

func (s *EvaluateStmtContext) EvalSubject(i int) IEvalSubjectContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvalSubjectContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvalSubjectContext)
}

func (s *EvaluateStmtContext) AllALSO() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserALSO)
}

func (s *EvaluateStmtContext) ALSO(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserALSO, i)
}

func (s *EvaluateStmtContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *EvaluateStmtContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *EvaluateStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EvaluateStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterEvaluateStmt(s)
	}
}

func (s *EvaluateStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitEvaluateStmt(s)
	}
}

func (p *bbyCBLParser) EvaluateStmt() (localctx IEvaluateStmtContext) {
	localctx = NewEvaluateStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, bbyCBLParserRULE_evaluateStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(461)
		p.Match(bbyCBLParserEVALUATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&28714957627980926) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&995950072215) != 0) {
		{
			p.SetState(462)
			p.EvalSubject()
		}

	}
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserALSO {
		{
			p.SetState(465)
			p.Match(bbyCBLParserALSO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(466)
			p.EvalSubject()
		}

		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == bbyCBLParserWHEN {
		{
			p.SetState(472)
			p.WhenClause()
		}

		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserEND_EVALUATE:
		{
			p.SetState(477)
			p.Match(bbyCBLParserEND_EVALUATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bbyCBLParserEND:
		{
			p.SetState(478)
			p.Match(bbyCBLParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(480)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(479)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGivingClauseContext is an interface to support dynamic dispatch.
type IGivingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GIVING() antlr.TerminalNode
	ExprList() IExprListContext

	// IsGivingClauseContext differentiates from other interfaces.
	IsGivingClauseContext()
}

type GivingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGivingClauseContext() *GivingClauseContext {
	var p = new(GivingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_givingClause
	return p
}

func InitEmptyGivingClauseContext(p *GivingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_givingClause
}

func (*GivingClauseContext) IsGivingClauseContext() {}

func NewGivingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GivingClauseContext {
	var p = new(GivingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_givingClause

	return p
}

func (s *GivingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GivingClauseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserGIVING, 0)
}

func (s *GivingClauseContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *GivingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GivingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GivingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterGivingClause(s)
	}
}

func (s *GivingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitGivingClause(s)
	}
}

func (p *bbyCBLParser) GivingClause() (localctx IGivingClauseContext) {
	localctx = NewGivingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, bbyCBLParserRULE_givingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(484)
		p.Match(bbyCBLParserGIVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(485)
		p.ExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGotoStmtContext is an interface to support dynamic dispatch.
type IGotoStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GO() antlr.TerminalNode
	TO() antlr.TerminalNode
	ExprList() IExprListContext

	// IsGotoStmtContext differentiates from other interfaces.
	IsGotoStmtContext()
}

type GotoStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStmtContext() *GotoStmtContext {
	var p = new(GotoStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_gotoStmt
	return p
}

func InitEmptyGotoStmtContext(p *GotoStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_gotoStmt
}

func (*GotoStmtContext) IsGotoStmtContext() {}

func NewGotoStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStmtContext {
	var p = new(GotoStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_gotoStmt

	return p
}

func (s *GotoStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStmtContext) GO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserGO, 0)
}

func (s *GotoStmtContext) TO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, 0)
}

func (s *GotoStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *GotoStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterGotoStmt(s)
	}
}

func (s *GotoStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitGotoStmt(s)
	}
}

func (p *bbyCBLParser) GotoStmt() (localctx IGotoStmtContext) {
	localctx = NewGotoStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, bbyCBLParserRULE_gotoStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(bbyCBLParserGO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(488)
		p.Match(bbyCBLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(489)
		p.ExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStmtContext is an interface to support dynamic dispatch.
type IIfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Condition() IConditionContext
	THEN() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode
	END_IF() antlr.TerminalNode
	END() antlr.TerminalNode

	// IsIfStmtContext differentiates from other interfaces.
	IsIfStmtContext()
}

type IfStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStmtContext() *IfStmtContext {
	var p = new(IfStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_ifStmt
	return p
}

func InitEmptyIfStmtContext(p *IfStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_ifStmt
}

func (*IfStmtContext) IsIfStmtContext() {}

func NewIfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStmtContext {
	var p = new(IfStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_ifStmt

	return p
}

func (s *IfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserIF, 0)
}

func (s *IfStmtContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *IfStmtContext) THEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTHEN, 0)
}

func (s *IfStmtContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStmtContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserELSE, 0)
}

func (s *IfStmtContext) END_IF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND_IF, 0)
}

func (s *IfStmtContext) END() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND, 0)
}

func (s *IfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterIfStmt(s)
	}
}

func (s *IfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitIfStmt(s)
	}
}

func (p *bbyCBLParser) IfStmt() (localctx IIfStmtContext) {
	localctx = NewIfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, bbyCBLParserRULE_ifStmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.Match(bbyCBLParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(492)
		p.Condition()
	}
	{
		p.SetState(493)
		p.Match(bbyCBLParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(494)
				p.Statement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(497)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(505)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(499)
			p.Match(bbyCBLParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(500)
					p.Statement()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(503)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(508)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(507)
			_la = p.GetTokenStream().LA(1)

			if !(_la == bbyCBLParserEND || _la == bbyCBLParserEND_IF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopStmtContext is an interface to support dynamic dispatch.
type ILoopStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOOP() antlr.TerminalNode
	END() antlr.TerminalNode
	AllLoopControl() []ILoopControlContext
	LoopControl(i int) ILoopControlContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	Identifier() IIdentifierContext

	// IsLoopStmtContext differentiates from other interfaces.
	IsLoopStmtContext()
}

type LoopStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStmtContext() *LoopStmtContext {
	var p = new(LoopStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_loopStmt
	return p
}

func InitEmptyLoopStmtContext(p *LoopStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_loopStmt
}

func (*LoopStmtContext) IsLoopStmtContext() {}

func NewLoopStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStmtContext {
	var p = new(LoopStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_loopStmt

	return p
}

func (s *LoopStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStmtContext) LOOP() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLOOP, 0)
}

func (s *LoopStmtContext) END() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEND, 0)
}

func (s *LoopStmtContext) AllLoopControl() []ILoopControlContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoopControlContext); ok {
			len++
		}
	}

	tst := make([]ILoopControlContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoopControlContext); ok {
			tst[i] = t.(ILoopControlContext)
			i++
		}
	}

	return tst
}

func (s *LoopStmtContext) LoopControl(i int) ILoopControlContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopControlContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopControlContext)
}

func (s *LoopStmtContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *LoopStmtContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LoopStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LoopStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLoopStmt(s)
	}
}

func (s *LoopStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLoopStmt(s)
	}
}

func (p *bbyCBLParser) LoopStmt() (localctx ILoopStmtContext) {
	localctx = NewLoopStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, bbyCBLParserRULE_loopStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)
		p.Match(bbyCBLParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&296500929014988800) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&84017) != 0) {
		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(511)
				p.LoopControl()
			}

		case 2:
			{
				p.SetState(512)
				p.Statement()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(517)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(518)
		p.Match(bbyCBLParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(520)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(519)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopControlContext is an interface to support dynamic dispatch.
type ILoopControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VaryingClause() IVaryingClauseContext
	WhileClause() IWhileClauseContext
	UntilClause() IUntilClauseContext

	// IsLoopControlContext differentiates from other interfaces.
	IsLoopControlContext()
}

type LoopControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopControlContext() *LoopControlContext {
	var p = new(LoopControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_loopControl
	return p
}

func InitEmptyLoopControlContext(p *LoopControlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_loopControl
}

func (*LoopControlContext) IsLoopControlContext() {}

func NewLoopControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopControlContext {
	var p = new(LoopControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_loopControl

	return p
}

func (s *LoopControlContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopControlContext) VaryingClause() IVaryingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVaryingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVaryingClauseContext)
}

func (s *LoopControlContext) WhileClause() IWhileClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileClauseContext)
}

func (s *LoopControlContext) UntilClause() IUntilClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUntilClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUntilClauseContext)
}

func (s *LoopControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLoopControl(s)
	}
}

func (s *LoopControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLoopControl(s)
	}
}

func (p *bbyCBLParser) LoopControl() (localctx ILoopControlContext) {
	localctx = NewLoopControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, bbyCBLParserRULE_loopControl)
	p.SetState(525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bbyCBLParserVARYING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(522)
			p.VaryingClause()
		}

	case bbyCBLParserWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(523)
			p.WhileClause()
		}

	case bbyCBLParserUNTIL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(524)
			p.UntilClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMoveStmtContext is an interface to support dynamic dispatch.
type IMoveStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MOVE() antlr.TerminalNode
	AllExprList() []IExprListContext
	ExprList(i int) IExprListContext
	TO() antlr.TerminalNode

	// IsMoveStmtContext differentiates from other interfaces.
	IsMoveStmtContext()
}

type MoveStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveStmtContext() *MoveStmtContext {
	var p = new(MoveStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_moveStmt
	return p
}

func InitEmptyMoveStmtContext(p *MoveStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_moveStmt
}

func (*MoveStmtContext) IsMoveStmtContext() {}

func NewMoveStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveStmtContext {
	var p = new(MoveStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_moveStmt

	return p
}

func (s *MoveStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveStmtContext) MOVE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMOVE, 0)
}

func (s *MoveStmtContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *MoveStmtContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *MoveStmtContext) TO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, 0)
}

func (s *MoveStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterMoveStmt(s)
	}
}

func (s *MoveStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitMoveStmt(s)
	}
}

func (p *bbyCBLParser) MoveStmt() (localctx IMoveStmtContext) {
	localctx = NewMoveStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, bbyCBLParserRULE_moveStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(527)
		p.Match(bbyCBLParserMOVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(528)
		p.ExprList()
	}
	{
		p.SetState(529)
		p.Match(bbyCBLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(530)
		p.ExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplyStmtContext is an interface to support dynamic dispatch.
type IMultiplyStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULTIPLY() antlr.TerminalNode
	AllExprList() []IExprListContext
	ExprList(i int) IExprListContext
	BY() antlr.TerminalNode
	AllGivingClause() []IGivingClauseContext
	GivingClause(i int) IGivingClauseContext

	// IsMultiplyStmtContext differentiates from other interfaces.
	IsMultiplyStmtContext()
}

type MultiplyStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyStmtContext() *MultiplyStmtContext {
	var p = new(MultiplyStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_multiplyStmt
	return p
}

func InitEmptyMultiplyStmtContext(p *MultiplyStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_multiplyStmt
}

func (*MultiplyStmtContext) IsMultiplyStmtContext() {}

func NewMultiplyStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyStmtContext {
	var p = new(MultiplyStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_multiplyStmt

	return p
}

func (s *MultiplyStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyStmtContext) MULTIPLY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMULTIPLY, 0)
}

func (s *MultiplyStmtContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *MultiplyStmtContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *MultiplyStmtContext) BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, 0)
}

func (s *MultiplyStmtContext) AllGivingClause() []IGivingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGivingClauseContext); ok {
			len++
		}
	}

	tst := make([]IGivingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGivingClauseContext); ok {
			tst[i] = t.(IGivingClauseContext)
			i++
		}
	}

	return tst
}

func (s *MultiplyStmtContext) GivingClause(i int) IGivingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGivingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGivingClauseContext)
}

func (s *MultiplyStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterMultiplyStmt(s)
	}
}

func (s *MultiplyStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitMultiplyStmt(s)
	}
}

func (p *bbyCBLParser) MultiplyStmt() (localctx IMultiplyStmtContext) {
	localctx = NewMultiplyStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, bbyCBLParserRULE_multiplyStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(532)
		p.Match(bbyCBLParserMULTIPLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(533)
		p.ExprList()
	}
	{
		p.SetState(534)
		p.Match(bbyCBLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(535)
		p.ExprList()
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserGIVING {
		{
			p.SetState(536)
			p.GivingClause()
		}

		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INextSentenceStmtContext is an interface to support dynamic dispatch.
type INextSentenceStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEXT_SENTENCE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsNextSentenceStmtContext differentiates from other interfaces.
	IsNextSentenceStmtContext()
}

type NextSentenceStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNextSentenceStmtContext() *NextSentenceStmtContext {
	var p = new(NextSentenceStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_nextSentenceStmt
	return p
}

func InitEmptyNextSentenceStmtContext(p *NextSentenceStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_nextSentenceStmt
}

func (*NextSentenceStmtContext) IsNextSentenceStmtContext() {}

func NewNextSentenceStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NextSentenceStmtContext {
	var p = new(NextSentenceStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_nextSentenceStmt

	return p
}

func (s *NextSentenceStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *NextSentenceStmtContext) NEXT_SENTENCE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNEXT_SENTENCE, 0)
}

func (s *NextSentenceStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NextSentenceStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NextSentenceStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NextSentenceStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterNextSentenceStmt(s)
	}
}

func (s *NextSentenceStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitNextSentenceStmt(s)
	}
}

func (p *bbyCBLParser) NextSentenceStmt() (localctx INextSentenceStmtContext) {
	localctx = NewNextSentenceStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, bbyCBLParserRULE_nextSentenceStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		p.Match(bbyCBLParserNEXT_SENTENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(544)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(543)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPerformStmtContext is an interface to support dynamic dispatch.
type IPerformStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PERFORM() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	THROUGH() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	ExprList() IExprListContext

	// IsPerformStmtContext differentiates from other interfaces.
	IsPerformStmtContext()
}

type PerformStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformStmtContext() *PerformStmtContext {
	var p = new(PerformStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_performStmt
	return p
}

func InitEmptyPerformStmtContext(p *PerformStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_performStmt
}

func (*PerformStmtContext) IsPerformStmtContext() {}

func NewPerformStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformStmtContext {
	var p = new(PerformStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_performStmt

	return p
}

func (s *PerformStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformStmtContext) PERFORM() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPERFORM, 0)
}

func (s *PerformStmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *PerformStmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PerformStmtContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTHROUGH, 0)
}

func (s *PerformStmtContext) TIMES() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTIMES, 0)
}

func (s *PerformStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *PerformStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterPerformStmt(s)
	}
}

func (s *PerformStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitPerformStmt(s)
	}
}

func (p *bbyCBLParser) PerformStmt() (localctx IPerformStmtContext) {
	localctx = NewPerformStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, bbyCBLParserRULE_performStmt)
	var _la int

	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(546)
			p.Match(bbyCBLParserPERFORM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(547)
			p.expr(0)
		}
		p.SetState(550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserTHROUGH {
			{
				p.SetState(548)
				p.Match(bbyCBLParserTHROUGH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(549)
				p.expr(0)
			}

		}
		p.SetState(555)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(552)
				p.expr(0)
			}
			{
				p.SetState(553)
				p.Match(bbyCBLParserTIMES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(557)
			p.Match(bbyCBLParserPERFORM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(558)
			p.ExprList()
		}
		{
			p.SetState(559)
			p.Match(bbyCBLParserTIMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignalStmtContext is an interface to support dynamic dispatch.
type ISignalStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSignalStmtContext differentiates from other interfaces.
	IsSignalStmtContext()
}

type SignalStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalStmtContext() *SignalStmtContext {
	var p = new(SignalStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_signalStmt
	return p
}

func InitEmptySignalStmtContext(p *SignalStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_signalStmt
}

func (*SignalStmtContext) IsSignalStmtContext() {}

func NewSignalStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalStmtContext {
	var p = new(SignalStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_signalStmt

	return p
}

func (s *SignalStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalStmtContext) CopyAll(ctx *SignalStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SignalStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SignalEnableContext struct {
	SignalStmtContext
}

func NewSignalEnableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SignalEnableContext {
	var p = new(SignalEnableContext)

	InitEmptySignalStmtContext(&p.SignalStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*SignalStmtContext))

	return p
}

func (s *SignalEnableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalEnableContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSIGNAL, 0)
}

func (s *SignalEnableContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SignalEnableContext) ON() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserON, 0)
}

func (s *SignalEnableContext) ERROR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserERROR, 0)
}

func (s *SignalEnableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SignalEnableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSignalEnable(s)
	}
}

func (s *SignalEnableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSignalEnable(s)
	}
}

type SignalDisableContext struct {
	SignalStmtContext
}

func NewSignalDisableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SignalDisableContext {
	var p = new(SignalDisableContext)

	InitEmptySignalStmtContext(&p.SignalStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*SignalStmtContext))

	return p
}

func (s *SignalDisableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalDisableContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSIGNAL, 0)
}

func (s *SignalDisableContext) OFF() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOFF, 0)
}

func (s *SignalDisableContext) ON() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserON, 0)
}

func (s *SignalDisableContext) ERROR() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserERROR, 0)
}

func (s *SignalDisableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SignalDisableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSignalDisable(s)
	}
}

func (s *SignalDisableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSignalDisable(s)
	}
}

func (p *bbyCBLParser) SignalStmt() (localctx ISignalStmtContext) {
	localctx = NewSignalStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, bbyCBLParserRULE_signalStmt)
	var _la int

	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSignalDisableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(563)
			p.Match(bbyCBLParserSIGNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(564)
			p.Match(bbyCBLParserOFF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(565)
			p.Match(bbyCBLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(566)
			p.Match(bbyCBLParserERROR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(568)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(567)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSignalEnableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(570)
			p.Match(bbyCBLParserSIGNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(571)
			p.expr(0)
		}
		p.SetState(577)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserON {
			{
				p.SetState(572)
				p.Match(bbyCBLParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(573)
				p.Match(bbyCBLParserERROR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(575)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(574)
					p.Identifier()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStopStmtContext is an interface to support dynamic dispatch.
type IStopStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STOP() antlr.TerminalNode
	RUN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsStopStmtContext differentiates from other interfaces.
	IsStopStmtContext()
}

type StopStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopStmtContext() *StopStmtContext {
	var p = new(StopStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_stopStmt
	return p
}

func InitEmptyStopStmtContext(p *StopStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_stopStmt
}

func (*StopStmtContext) IsStopStmtContext() {}

func NewStopStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopStmtContext {
	var p = new(StopStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_stopStmt

	return p
}

func (s *StopStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StopStmtContext) STOP() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSTOP, 0)
}

func (s *StopStmtContext) RUN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserRUN, 0)
}

func (s *StopStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StopStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterStopStmt(s)
	}
}

func (s *StopStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitStopStmt(s)
	}
}

func (p *bbyCBLParser) StopStmt() (localctx IStopStmtContext) {
	localctx = NewStopStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, bbyCBLParserRULE_stopStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(581)
		p.Match(bbyCBLParserSTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(584)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(582)
			p.Match(bbyCBLParserRUN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(583)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubtractStmtContext is an interface to support dynamic dispatch.
type ISubtractStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBTRACT() antlr.TerminalNode
	AllExprList() []IExprListContext
	ExprList(i int) IExprListContext
	FROM() antlr.TerminalNode
	AllGivingClause() []IGivingClauseContext
	GivingClause(i int) IGivingClauseContext

	// IsSubtractStmtContext differentiates from other interfaces.
	IsSubtractStmtContext()
}

type SubtractStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractStmtContext() *SubtractStmtContext {
	var p = new(SubtractStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_subtractStmt
	return p
}

func InitEmptySubtractStmtContext(p *SubtractStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_subtractStmt
}

func (*SubtractStmtContext) IsSubtractStmtContext() {}

func NewSubtractStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractStmtContext {
	var p = new(SubtractStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_subtractStmt

	return p
}

func (s *SubtractStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractStmtContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSUBTRACT, 0)
}

func (s *SubtractStmtContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *SubtractStmtContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *SubtractStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserFROM, 0)
}

func (s *SubtractStmtContext) AllGivingClause() []IGivingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGivingClauseContext); ok {
			len++
		}
	}

	tst := make([]IGivingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGivingClauseContext); ok {
			tst[i] = t.(IGivingClauseContext)
			i++
		}
	}

	return tst
}

func (s *SubtractStmtContext) GivingClause(i int) IGivingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGivingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGivingClauseContext)
}

func (s *SubtractStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSubtractStmt(s)
	}
}

func (s *SubtractStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSubtractStmt(s)
	}
}

func (p *bbyCBLParser) SubtractStmt() (localctx ISubtractStmtContext) {
	localctx = NewSubtractStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, bbyCBLParserRULE_subtractStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.Match(bbyCBLParserSUBTRACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(587)
		p.ExprList()
	}
	{
		p.SetState(588)
		p.Match(bbyCBLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(589)
		p.ExprList()
	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bbyCBLParserGIVING {
		{
			p.SetState(590)
			p.GivingClause()
		}

		p.SetState(595)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUntilClauseContext is an interface to support dynamic dispatch.
type IUntilClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNTIL() antlr.TerminalNode
	Condition() IConditionContext

	// IsUntilClauseContext differentiates from other interfaces.
	IsUntilClauseContext()
}

type UntilClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUntilClauseContext() *UntilClauseContext {
	var p = new(UntilClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_untilClause
	return p
}

func InitEmptyUntilClauseContext(p *UntilClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_untilClause
}

func (*UntilClauseContext) IsUntilClauseContext() {}

func NewUntilClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UntilClauseContext {
	var p = new(UntilClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_untilClause

	return p
}

func (s *UntilClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UntilClauseContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserUNTIL, 0)
}

func (s *UntilClauseContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *UntilClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UntilClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UntilClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterUntilClause(s)
	}
}

func (s *UntilClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitUntilClause(s)
	}
}

func (p *bbyCBLParser) UntilClause() (localctx IUntilClauseContext) {
	localctx = NewUntilClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, bbyCBLParserRULE_untilClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.Match(bbyCBLParserUNTIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(597)
		p.Condition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVaryingClauseContext is an interface to support dynamic dispatch.
type IVaryingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARYING() antlr.TerminalNode
	QualifiedId() IQualifiedIdContext
	IdentifierSegment() IIdentifierSegmentContext
	FROM() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	TO() antlr.TerminalNode
	BY() antlr.TerminalNode

	// IsVaryingClauseContext differentiates from other interfaces.
	IsVaryingClauseContext()
}

type VaryingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVaryingClauseContext() *VaryingClauseContext {
	var p = new(VaryingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_varyingClause
	return p
}

func InitEmptyVaryingClauseContext(p *VaryingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_varyingClause
}

func (*VaryingClauseContext) IsVaryingClauseContext() {}

func NewVaryingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VaryingClauseContext {
	var p = new(VaryingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_varyingClause

	return p
}

func (s *VaryingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *VaryingClauseContext) VARYING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserVARYING, 0)
}

func (s *VaryingClauseContext) QualifiedId() IQualifiedIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdContext)
}

func (s *VaryingClauseContext) IdentifierSegment() IIdentifierSegmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSegmentContext)
}

func (s *VaryingClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserFROM, 0)
}

func (s *VaryingClauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *VaryingClauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *VaryingClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTO, 0)
}

func (s *VaryingClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserBY, 0)
}

func (s *VaryingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VaryingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VaryingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterVaryingClause(s)
	}
}

func (s *VaryingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitVaryingClause(s)
	}
}

func (p *bbyCBLParser) VaryingClause() (localctx IVaryingClauseContext) {
	localctx = NewVaryingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, bbyCBLParserRULE_varyingClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(599)
		p.Match(bbyCBLParserVARYING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(602)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(600)
			p.QualifiedId()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(601)
			p.IdentifierSegment()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserFROM {
		{
			p.SetState(604)
			p.Match(bbyCBLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(605)
			p.expr(0)
		}

	}
	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserTO {
		{
			p.SetState(608)
			p.Match(bbyCBLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(609)
			p.expr(0)
		}

	}
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bbyCBLParserBY {
		{
			p.SetState(612)
			p.Match(bbyCBLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(613)
			p.expr(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVaryingStmtContext is an interface to support dynamic dispatch.
type IVaryingStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VaryingClause() IVaryingClauseContext
	VARYING() antlr.TerminalNode

	// IsVaryingStmtContext differentiates from other interfaces.
	IsVaryingStmtContext()
}

type VaryingStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVaryingStmtContext() *VaryingStmtContext {
	var p = new(VaryingStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_varyingStmt
	return p
}

func InitEmptyVaryingStmtContext(p *VaryingStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_varyingStmt
}

func (*VaryingStmtContext) IsVaryingStmtContext() {}

func NewVaryingStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VaryingStmtContext {
	var p = new(VaryingStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_varyingStmt

	return p
}

func (s *VaryingStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *VaryingStmtContext) VaryingClause() IVaryingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVaryingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVaryingClauseContext)
}

func (s *VaryingStmtContext) VARYING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserVARYING, 0)
}

func (s *VaryingStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VaryingStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VaryingStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterVaryingStmt(s)
	}
}

func (s *VaryingStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitVaryingStmt(s)
	}
}

func (p *bbyCBLParser) VaryingStmt() (localctx IVaryingStmtContext) {
	localctx = NewVaryingStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, bbyCBLParserRULE_varyingStmt)
	p.SetState(618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(616)
			p.VaryingClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(617)
			p.Match(bbyCBLParserVARYING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) CopyAll(ctx *WhenClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WhenValuesContext struct {
	WhenClauseContext
}

func NewWhenValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhenValuesContext {
	var p = new(WhenValuesContext)

	InitEmptyWhenClauseContext(&p.WhenClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*WhenClauseContext))

	return p
}

func (s *WhenValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenValuesContext) WHEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWHEN, 0)
}

func (s *WhenValuesContext) AllEvalSubject() []IEvalSubjectContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEvalSubjectContext); ok {
			len++
		}
	}

	tst := make([]IEvalSubjectContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEvalSubjectContext); ok {
			tst[i] = t.(IEvalSubjectContext)
			i++
		}
	}

	return tst
}

func (s *WhenValuesContext) EvalSubject(i int) IEvalSubjectContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvalSubjectContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvalSubjectContext)
}

func (s *WhenValuesContext) AllTHROUGH() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserTHROUGH)
}

func (s *WhenValuesContext) THROUGH(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserTHROUGH, i)
}

func (s *WhenValuesContext) AllALSO() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserALSO)
}

func (s *WhenValuesContext) ALSO(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserALSO, i)
}

func (s *WhenValuesContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *WhenValuesContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhenValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterWhenValues(s)
	}
}

func (s *WhenValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitWhenValues(s)
	}
}

type WhenOtherContext struct {
	WhenClauseContext
}

func NewWhenOtherContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhenOtherContext {
	var p = new(WhenOtherContext)

	InitEmptyWhenClauseContext(&p.WhenClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*WhenClauseContext))

	return p
}

func (s *WhenOtherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenOtherContext) WHEN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWHEN, 0)
}

func (s *WhenOtherContext) OTHER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOTHER, 0)
}

func (s *WhenOtherContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *WhenOtherContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhenOtherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterWhenOther(s)
	}
}

func (s *WhenOtherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitWhenOther(s)
	}
}

func (p *bbyCBLParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, bbyCBLParserRULE_whenClause)
	var _la int

	var _alt int

	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		localctx = NewWhenOtherContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(620)
			p.Match(bbyCBLParserWHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(621)
			p.Match(bbyCBLParserOTHER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64((_la-16)) & ^0x3f) == 0 && ((int64(1)<<(_la-16))&4625482816531342723) != 0) {
			{
				p.SetState(622)
				p.Statement()
			}

			p.SetState(625)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewWhenValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(627)
			p.Match(bbyCBLParserWHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(628)
			p.EvalSubject()
		}
		p.SetState(631)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserTHROUGH {
			{
				p.SetState(629)
				p.Match(bbyCBLParserTHROUGH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(630)
				p.EvalSubject()
			}

		}
		p.SetState(641)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(633)
					p.Match(bbyCBLParserALSO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(634)
					p.EvalSubject()
				}
				p.SetState(637)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == bbyCBLParserTHROUGH {
					{
						p.SetState(635)
						p.Match(bbyCBLParserTHROUGH)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(636)
						p.EvalSubject()
					}

				}

			}
			p.SetState(643)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserALSO {
			{
				p.SetState(644)
				p.Match(bbyCBLParserALSO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64((_la-16)) & ^0x3f) == 0 && ((int64(1)<<(_la-16))&4625482816531342723) != 0) {
			{
				p.SetState(647)
				p.Statement()
			}

			p.SetState(650)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileClauseContext is an interface to support dynamic dispatch.
type IWhileClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Condition() IConditionContext

	// IsWhileClauseContext differentiates from other interfaces.
	IsWhileClauseContext()
}

type WhileClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileClauseContext() *WhileClauseContext {
	var p = new(WhileClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_whileClause
	return p
}

func InitEmptyWhileClauseContext(p *WhileClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_whileClause
}

func (*WhileClauseContext) IsWhileClauseContext() {}

func NewWhileClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileClauseContext {
	var p = new(WhileClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_whileClause

	return p
}

func (s *WhileClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileClauseContext) WHILE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserWHILE, 0)
}

func (s *WhileClauseContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *WhileClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterWhileClause(s)
	}
}

func (s *WhileClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitWhileClause(s)
	}
}

func (p *bbyCBLParser) WhileClause() (localctx IWhileClauseContext) {
	localctx = NewWhileClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, bbyCBLParserRULE_whileClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(654)
		p.Match(bbyCBLParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(655)
		p.Condition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprListContext is an interface to support dynamic dispatch.
type IExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExprListContext differentiates from other interfaces.
	IsExprListContext()
}

type ExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprListContext() *ExprListContext {
	var p = new(ExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_exprList
	return p
}

func InitEmptyExprListContext(p *ExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_exprList
}

func (*ExprListContext) IsExprListContext() {}

func NewExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprListContext {
	var p = new(ExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_exprList

	return p
}

func (s *ExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprListContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprListContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserCOMMA)
}

func (s *ExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserCOMMA, i)
}

func (s *ExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterExprList(s)
	}
}

func (s *ExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitExprList(s)
	}
}

func (p *bbyCBLParser) ExprList() (localctx IExprListContext) {
	localctx = NewExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, bbyCBLParserRULE_exprList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.expr(0)
	}
	p.SetState(664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(659)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == bbyCBLParserCOMMA {
				{
					p.SetState(658)
					p.Match(bbyCBLParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(661)
				p.expr(0)
			}

		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleCond() []ISimpleCondContext
	SimpleCond(i int) ISimpleCondContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode
	AllXOR() []antlr.TerminalNode
	XOR(i int) antlr.TerminalNode

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_condition
	return p
}

func InitEmptyConditionContext(p *ConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_condition
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) AllSimpleCond() []ISimpleCondContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleCondContext); ok {
			len++
		}
	}

	tst := make([]ISimpleCondContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleCondContext); ok {
			tst[i] = t.(ISimpleCondContext)
			i++
		}
	}

	return tst
}

func (s *ConditionContext) SimpleCond(i int) ISimpleCondContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleCondContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleCondContext)
}

func (s *ConditionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserAND)
}

func (s *ConditionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserAND, i)
}

func (s *ConditionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserOR)
}

func (s *ConditionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOR, i)
}

func (s *ConditionContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserXOR)
}

func (s *ConditionContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserXOR, i)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitCondition(s)
	}
}

func (p *bbyCBLParser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, bbyCBLParserRULE_condition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.SimpleCond()
	}
	p.SetState(672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-27)) & ^0x3f) == 0 && ((int64(1)<<(_la-27))&288230376688582657) != 0 {
		{
			p.SetState(668)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-27)) & ^0x3f) == 0 && ((int64(1)<<(_la-27))&288230376688582657) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(669)
			p.SimpleCond()
		}

		p.SetState(674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleCondContext is an interface to support dynamic dispatch.
type ISimpleCondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Condition() IConditionContext
	RPAREN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Comparator() IComparatorContext
	NOT() antlr.TerminalNode

	// IsSimpleCondContext differentiates from other interfaces.
	IsSimpleCondContext()
}

type SimpleCondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleCondContext() *SimpleCondContext {
	var p = new(SimpleCondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_simpleCond
	return p
}

func InitEmptySimpleCondContext(p *SimpleCondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_simpleCond
}

func (*SimpleCondContext) IsSimpleCondContext() {}

func NewSimpleCondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleCondContext {
	var p = new(SimpleCondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_simpleCond

	return p
}

func (s *SimpleCondContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleCondContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLPAREN, 0)
}

func (s *SimpleCondContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *SimpleCondContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserRPAREN, 0)
}

func (s *SimpleCondContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCondContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleCondContext) Comparator() IComparatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparatorContext)
}

func (s *SimpleCondContext) NOT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNOT, 0)
}

func (s *SimpleCondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleCondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterSimpleCond(s)
	}
}

func (s *SimpleCondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitSimpleCond(s)
	}
}

func (p *bbyCBLParser) SimpleCond() (localctx ISimpleCondContext) {
	localctx = NewSimpleCondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, bbyCBLParserRULE_simpleCond)
	var _la int

	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(675)
			p.Match(bbyCBLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(676)
			p.Condition()
		}
		{
			p.SetState(677)
			p.Match(bbyCBLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserNOT {
			{
				p.SetState(679)
				p.Match(bbyCBLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(682)
			p.expr(0)
		}
		{
			p.SetState(683)
			p.Comparator()
		}
		{
			p.SetState(684)
			p.expr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserNOT {
			{
				p.SetState(686)
				p.Match(bbyCBLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(689)
			p.Comparator()
		}
		{
			p.SetState(690)
			p.expr(0)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bbyCBLParserNOT {
			{
				p.SetState(692)
				p.Match(bbyCBLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(695)
			p.expr(0)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(696)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparatorContext is an interface to support dynamic dispatch.
type IComparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NE() antlr.TerminalNode
	LT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GE() antlr.TerminalNode

	// IsComparatorContext differentiates from other interfaces.
	IsComparatorContext()
}

type ComparatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparatorContext() *ComparatorContext {
	var p = new(ComparatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_comparator
	return p
}

func InitEmptyComparatorContext(p *ComparatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_comparator
}

func (*ComparatorContext) IsComparatorContext() {}

func NewComparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparatorContext {
	var p = new(ComparatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_comparator

	return p
}

func (s *ComparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserEQ, 0)
}

func (s *ComparatorContext) NE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNE, 0)
}

func (s *ComparatorContext) LT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLT, 0)
}

func (s *ComparatorContext) LE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLE, 0)
}

func (s *ComparatorContext) GT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserGT, 0)
}

func (s *ComparatorContext) GE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserGE, 0)
}

func (s *ComparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterComparator(s)
	}
}

func (s *ComparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitComparator(s)
	}
}

func (p *bbyCBLParser) Comparator() (localctx IComparatorContext) {
	localctx = NewComparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, bbyCBLParserRULE_comparator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(699)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierSegmentContext is an interface to support dynamic dispatch.
type IIdentifierSegmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleId() ISimpleIdContext
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode

	// IsIdentifierSegmentContext differentiates from other interfaces.
	IsIdentifierSegmentContext()
}

type IdentifierSegmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierSegmentContext() *IdentifierSegmentContext {
	var p = new(IdentifierSegmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identifierSegment
	return p
}

func InitEmptyIdentifierSegmentContext(p *IdentifierSegmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_identifierSegment
}

func (*IdentifierSegmentContext) IsIdentifierSegmentContext() {}

func NewIdentifierSegmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierSegmentContext {
	var p = new(IdentifierSegmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_identifierSegment

	return p
}

func (s *IdentifierSegmentContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierSegmentContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *IdentifierSegmentContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserLPAREN)
}

func (s *IdentifierSegmentContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLPAREN, i)
}

func (s *IdentifierSegmentContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierSegmentContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IdentifierSegmentContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserRPAREN)
}

func (s *IdentifierSegmentContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserRPAREN, i)
}

func (s *IdentifierSegmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierSegmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierSegmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterIdentifierSegment(s)
	}
}

func (s *IdentifierSegmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitIdentifierSegment(s)
	}
}

func (p *bbyCBLParser) IdentifierSegment() (localctx IIdentifierSegmentContext) {
	localctx = NewIdentifierSegmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, bbyCBLParserRULE_identifierSegment)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(701)
		p.SimpleId()
	}
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(702)
				p.Match(bbyCBLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(703)
				p.expr(0)
			}
			{
				p.SetState(704)
				p.Match(bbyCBLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedIdContext is an interface to support dynamic dispatch.
type IQualifiedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierSegment() []IIdentifierSegmentContext
	IdentifierSegment(i int) IIdentifierSegmentContext
	AllOF() []antlr.TerminalNode
	OF(i int) antlr.TerminalNode

	// IsQualifiedIdContext differentiates from other interfaces.
	IsQualifiedIdContext()
}

type QualifiedIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdContext() *QualifiedIdContext {
	var p = new(QualifiedIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_qualifiedId
	return p
}

func InitEmptyQualifiedIdContext(p *QualifiedIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_qualifiedId
}

func (*QualifiedIdContext) IsQualifiedIdContext() {}

func NewQualifiedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdContext {
	var p = new(QualifiedIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_qualifiedId

	return p
}

func (s *QualifiedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdContext) AllIdentifierSegment() []IIdentifierSegmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierSegmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierSegmentContext); ok {
			tst[i] = t.(IIdentifierSegmentContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedIdContext) IdentifierSegment(i int) IIdentifierSegmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSegmentContext)
}

func (s *QualifiedIdContext) AllOF() []antlr.TerminalNode {
	return s.GetTokens(bbyCBLParserOF)
}

func (s *QualifiedIdContext) OF(i int) antlr.TerminalNode {
	return s.GetToken(bbyCBLParserOF, i)
}

func (s *QualifiedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterQualifiedId(s)
	}
}

func (s *QualifiedIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitQualifiedId(s)
	}
}

func (p *bbyCBLParser) QualifiedId() (localctx IQualifiedIdContext) {
	localctx = NewQualifiedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, bbyCBLParserRULE_qualifiedId)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(711)
		p.IdentifierSegment()
	}
	p.SetState(714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(712)
				p.Match(bbyCBLParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(713)
				p.IdentifierSegment()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(716)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) CopyAll(ctx *ExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QualifiedIdExprContext struct {
	ExprContext
}

func NewQualifiedIdExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedIdExprContext {
	var p = new(QualifiedIdExprContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *QualifiedIdExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdExprContext) QualifiedId() IQualifiedIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdContext)
}

func (s *QualifiedIdExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterQualifiedIdExpr(s)
	}
}

func (s *QualifiedIdExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitQualifiedIdExpr(s)
	}
}

type UMinusContext struct {
	ExprContext
}

func NewUMinusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UMinusContext {
	var p = new(UMinusContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *UMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UMinusContext) MINUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMINUS, 0)
}

func (s *UMinusContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UMinusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterUMinus(s)
	}
}

func (s *UMinusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitUMinus(s)
	}
}

type IdExprContext struct {
	ExprContext
}

func NewIdExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdExprContext {
	var p = new(IdExprContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *IdExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdExprContext) IdentifierSegment() IIdentifierSegmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSegmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSegmentContext)
}

func (s *IdExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterIdExpr(s)
	}
}

func (s *IdExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitIdExpr(s)
	}
}

type MulDivContext struct {
	ExprContext
}

func NewMulDivContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MulDivContext {
	var p = new(MulDivContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *MulDivContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MulDivContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *MulDivContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MulDivContext) MULT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMULT, 0)
}

func (s *MulDivContext) DIV() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDIV, 0)
}

func (s *MulDivContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterMulDiv(s)
	}
}

func (s *MulDivContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitMulDiv(s)
	}
}

type AddSubContext struct {
	ExprContext
}

func NewAddSubContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddSubContext {
	var p = new(AddSubContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *AddSubContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSubContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *AddSubContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AddSubContext) PLUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPLUS, 0)
}

func (s *AddSubContext) MINUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserMINUS, 0)
}

func (s *AddSubContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterAddSub(s)
	}
}

func (s *AddSubContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitAddSub(s)
	}
}

type ParensContext struct {
	ExprContext
}

func NewParensContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParensContext {
	var p = new(ParensContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParensContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserLPAREN, 0)
}

func (s *ParensContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParensContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserRPAREN, 0)
}

func (s *ParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterParens(s)
	}
}

func (s *ParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitParens(s)
	}
}

type LitExprContext struct {
	ExprContext
}

func NewLitExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LitExprContext {
	var p = new(LitExprContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *LitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LitExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLitExpr(s)
	}
}

func (s *LitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLitExpr(s)
	}
}

type UPlusContext struct {
	ExprContext
}

func NewUPlusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UPlusContext {
	var p = new(UPlusContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *UPlusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UPlusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPLUS, 0)
}

func (s *UPlusContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UPlusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterUPlus(s)
	}
}

func (s *UPlusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitUPlus(s)
	}
}

type ExpContext struct {
	ExprContext
}

func NewExpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpContext {
	var p = new(ExpContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExpContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExpContext) POW() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserPOW, 0)
}

func (s *ExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterExp(s)
	}
}

func (s *ExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitExp(s)
	}
}

func (p *bbyCBLParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *bbyCBLParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 116
	p.EnterRecursionRule(localctx, 116, bbyCBLParserRULE_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUPlusContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(719)
			p.Match(bbyCBLParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(720)
			p.expr(9)
		}

	case 2:
		localctx = NewUMinusContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(721)
			p.Match(bbyCBLParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(722)
			p.expr(8)
		}

	case 3:
		localctx = NewParensContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(723)
			p.Match(bbyCBLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(724)
			p.expr(0)
		}
		{
			p.SetState(725)
			p.Match(bbyCBLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewLitExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(727)
			p.Literal()
		}

	case 5:
		localctx = NewQualifiedIdExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(728)
			p.QualifiedId()
		}

	case 6:
		localctx = NewIdExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(729)
			p.IdentifierSegment()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(741)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, bbyCBLParserRULE_expr)
				p.SetState(732)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(733)
					p.Match(bbyCBLParserPOW)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(734)
					p.expr(8)
				}

			case 2:
				localctx = NewMulDivContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, bbyCBLParserRULE_expr)
				p.SetState(735)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(736)
					_la = p.GetTokenStream().LA(1)

					if !(_la == bbyCBLParserMULT || _la == bbyCBLParserDIV) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(737)
					p.expr(7)
				}

			case 3:
				localctx = NewAddSubContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, bbyCBLParserRULE_expr)
				p.SetState(738)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(739)
					_la = p.GetTokenStream().LA(1)

					if !(_la == bbyCBLParserPLUS || _la == bbyCBLParserMINUS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(740)
					p.expr(6)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	STRING() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATE_UNDERSCORE() antlr.TerminalNode
	ANY_DATE() antlr.TerminalNode
	ANY_DATE_UNDERSCORE() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bbyCBLParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bbyCBLParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserFLOAT, 0)
}

func (s *LiteralContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserNUMBER, 0)
}

func (s *LiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserSTRING, 0)
}

func (s *LiteralContext) DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE, 0)
}

func (s *LiteralContext) DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserDATE_UNDERSCORE, 0)
}

func (s *LiteralContext) ANY_DATE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE, 0)
}

func (s *LiteralContext) ANY_DATE_UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(bbyCBLParserANY_DATE_UNDERSCORE, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bbyCBLListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *bbyCBLParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, bbyCBLParserRULE_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&126) != 0) || _la == bbyCBLParserSTRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *bbyCBLParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 58:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *bbyCBLParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
